# Pipulate: The Local-First Revolution in AI-Assisted Development

![Pipulate Free & Open Source SEO with & for LLMs](/static/pipulate.svg)

> **Your data. Your AI. Your machine. Your control.**  
> No subscriptions, no vendor lock-in, no cloud costs.

# About Pipulate

> Pipulate is a local-first, AI-assisted development framework that transforms how you run SEO workflows by embracing Notebooks without any code.

```
      ğŸ¤– AGENTIC MODE (Chaos)           ğŸš‚ AI ON RAILS (Pipulate)
      â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
          ğŸ’¥ GOES OFF                      ğŸ“Š LINEAR WORKFLOWS
          HALF-COCKED!                      BY DOMAIN EXPERTS
               â”‚                                   â”‚
               â–¼                                   â–¼
      â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â•‘  ğŸŒªï¸  WILLY NILLY   â•‘            â”‚  Step 1: Analyze    â”‚
      â•‘                    â•‘     VS     â”‚  Step 2: Process    â”‚
      â•‘   Unpredictable    â•‘            â”‚  Step 3: Report     â”‚
      â•‘      Results       â•‘            â”‚  Step 4: Export     â”‚
      â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚                                   â”‚
               â–¼                                   â–¼
    â˜ï¸ Trains Frontier Models       ğŸ  Keeps Domain Expertise Local
```

1. ğŸ–¥ï¸ **Runs locally** like a desktop app using modern web technologies
2. ğŸ **Simple linear workflow** approach powered by HTMX for seamless interactivity  
3. ğŸ““ **Transforms Jupyter Notebooks** into production-ready, step-by-step workflows
4. ğŸ¤– **Integrated AI assistance** using your own local models with complete privacy
5. ğŸ”§ **Reproducible environments** with Nix that work identically across all platforms
6. ğŸ¯ **Perfect for SEO practitioners** who want to turn technical expertise into guided, reusable workflows

## Target Audience

Pipulate serves two distinct but complementary audiences, much like a restaurant serves both chefs and customers:

```
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                      The Restaurant                      â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
    â”‚  â”‚   Kitchen (Dev)  â”‚              â”‚  Dining Room     â”‚  â”‚
    â”‚  â”‚                  â”‚              â”‚  (End Users)     â”‚  â”‚
    â”‚  â”‚                  â”‚              â”‚                  â”‚  â”‚
    â”‚  â”‚  ğŸ‘¨â€ğŸ³ Sous Chef    â”‚â”€â”€â”€recipesâ”€â”€â”€â–ºâ”‚  ğŸ½ï¸ Customers    â”‚  â”‚
    â”‚  â”‚  ğŸ‘©â€ğŸ³ Head Chef    â”‚              â”‚  ğŸ¢ Restaurateur â”‚  â”‚
    â”‚  â”‚                  â”‚              â”‚                  â”‚  â”‚
    â”‚  â”‚ "How do we make  â”‚              â”‚ "I want the best â”‚  â”‚
    â”‚  â”‚  pasta you've    â”‚              â”‚  pasta I've ever â”‚  â”‚
    â”‚  â”‚  never had?"     â”‚              â”‚  had in my life" â”‚  â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ‘¨â€ğŸ³ The Chef (Developer/Technical User)
* **ğŸ”§ Workflow Creators:** Build and customize AI-assisted workflows
* **ğŸ““ Jupyter Porters:** Convert notebook experiments into guided applications
* **ğŸ” Technical SEOs:** Create sophisticated, reusable SEO processes
* **âš™ï¸ System Administrators:** Deploy consistent environments across teams

**What Chefs Get:**
- ğŸ›ï¸ Complete control over the "recipe" (workflow logic)
- ğŸ”„ Reproducible development environment via Nix
- ğŸ—ï¸ Simple architecture that's easy to understand and modify
- ğŸ§° Integrated tooling (Jupyter, local LLM, SQLite)

### ğŸ½ï¸ The Customer (End User/Non-Technical)
* **ğŸ“ˆ SEO Practitioners:** Run powerful workflows without coding
* **âœï¸ Content Creators:** Use AI-assisted processes for optimization
* **ğŸ“Š Marketing Teams:** Execute consistent SEO strategies
* **ğŸ¢ Business Owners:** Access enterprise-level SEO capabilities

**What Customers Get:**
- ğŸš¶â€â™‚ï¸ Guided, step-by-step workflow experiences
- ğŸ¤– AI assistance at every step
- ğŸ™ˆ No need to see or understand the underlying code
- ğŸ¯ Consistent, repeatable results

### ğŸ The Restaurant Analogy
Just as a chef talks about knife techniques while a diner just wants amazing pasta, Pipulate separates the complexity of creation from the simplicity of consumption. Developers craft the workflows, end-users enjoy the results.

--------------------------------------------------------------------------------

## The WET Revolution: Why Explicit Code Wins in the AI Era

Pipulate is built on a radical philosophy that challenges programming orthodoxy: **WET (Write Everything Twice) is better than DRY (Don't Repeat Yourself)** when you have AI to help manage it.

### Why WET Works Now

Traditional development follows DRY principles, creating abstract, complex systems that are hard to understand and modify. But the world has changed:

1. **ğŸ”¬ Jupyter Notebooks** promote explicit, literate programming
2. **ğŸ¤– AI assistants** excel at managing repetitive code  
3. **ğŸ  Local-first architectures** prioritize clarity over enterprise complexity

```
                               ________________________________
   - Like Notebooks           /                                \
   - Linear Workflows        |  It runs proprietary private AI  |
   - Local & Cloud-free      |  Workflows from your Local PC?!  |
   - Chip O'Theseus included  \________________________________/
                                                               ()
        HARDWARE PLATFORM                BROWSER                 O    ,
     _______________________       __________ _______              o  \\  . 
    |                       |     / Pipulate \Jupyter\__              |\\/|
    | Windows, Mac or Linux |    |  __________________  |             / " '\
    |     _____ ___         |    | | App        Menu  | |    See!    . .   .
    |   _/ Nix \____\_____  |    | |------------------| |<- - - - - /    ) |
    |  |                  | |    | | Workflow | Local | |          '  _.'  |
    |  |     Pipulate    <----------> -Step 1 | Chat  | |          '-'/    \
    |__|  localhost:5001  |_|    | |  -Step 2 | Help  | |       What, no Docker?
       |  (AI on Rails!)  |      | |__________|_______| |       What, no React?
       |__________________|      |______________________|       What, no Cloud?

```

**WET workflows are:**
- **ğŸ” Observable**: See exactly what's happening at every step
- **ğŸ”§ Customizable**: Modify workflows without breaking abstractions
- **ğŸ¤– AI-Friendly**: Clear code that AI assistants can easily understand and maintain
- **ğŸš€ Future-Proof**: Built on durable web standards that won't become obsolete

--------------------------------------------------------------------------------

## What is Pipulate?

Pipulate is a **local-first, single-tenant desktop app framework** featuring AI-assisted, step-by-step workflows. Designed to feel like an Electron app, it uniquely runs a full, reproducible Linux environment within a project folder using Nix, ensuring consistency across macOS, Linux, and Windows (via WSL).

### Core Philosophy: Local-First, WET, and AI-Augmented

- **Local-First & Single-Tenant:** Your data, code, and AI run on your hardware. This guarantees privacy, eliminates cloud costs, and gives you full control.
- **WET Workflows, DRY Framework:** Workflows are intentionally "WET" (explicit & step-by-step) for maximum clarity and customizabilityâ€”perfectly mirroring Jupyter Notebooks. The underlying framework is "DRY" for efficiency.
- **The AI Advantage:** AI makes WET practical. Tedious code maintenance and refactoring, once a weakness of WET, is now an area where AI excels, turning repetition into a strength for rapid, context-aware development.
- **Simplicity & Observability ("Know EVERYTHING!"):** We reject opaque enterprise patterns. State is managed in transparent SQLite tables and JSON blobs, making the entire system intuitive and debuggable.
- **Reproducibility with Nix:** Nix Flakes provide a perfect, reproducible Linux environment on macOS, Linux, and Windows (WSL), solving the "works on my machine" problem.
- **Future-Proof Stack:** We rely on durable standards: Python, SQLite, HTML, and HTMX. This is a framework built to last.

### Primary Goals

1. **Empower End-Users (e.g., SEO Practitioners):** Enable non-programmers to run powerful, AI-guided workflows (often ported from Jupyter Notebooks) without needing to interact with Python code directly.
2. **Serve Developers:** Provide a simple, reproducible environment for building these workflows, leveraging integrated tooling like Jupyter, local LLMs, and a streamlined web framework.

## The Technical Stack: Simple Yet Powerful

Pipulate's WET philosophy extends to its technology choices, favoring simple, durable tools over complex abstractions:

## *Not On My Machine* Problem Fixed

> The Cloud's popularity has been driven in part by developers not wanting to maintain multiple codebases or installers per OS. Thanks to Nix, that's all fixed.

* **Nix Flakes:** Manages dependencies and creates reproducible environments, ensuring consistency across developers and operating systems, with optional CUDA support. E.g. Is this a Linux-thing you're reading about here? A Windows thing? A Mac thing? The answer is: YES!!! All of the above â€” and if you've got cool acceleration hardware, it will even take advantage and utilize that too. Best of all worlds.

```
     ____                      _       _                        .--.      ___________
    |  _ \  __ _ _ ____      _(_)_ __ (_)_  __    ,--./,-.     |o_o |    |     |     |
    | | | |/ _` | '__\ \ /\ / / | '_ \| \ \/ /   / #      \    |:_/ |    |     |     |
    | |_| | (_| | |   \ V  V /| | | | | |>  <   |          |  //   \ \   |_____|_____|
    |____/ \__,_|_|    \_/\_/ |_|_| |_|_/_/\_\   \        /  (|     | )  |     |     |
                                                  `._,._,'  /'\_   _/`\  |     |     |
    Solving the "Not on my machine" problem well.           \___)=(___/  |_____|_____|
```

## Other Key Technologies Used

Pipulate integrates a carefully selected set of tools aligned with its philosophy:

* **FastHTML:** A Python web framework prioritizing simplicity. It generates HTML directly from Python objects (no template language like Jinja2) and minimizes JavaScript by design, working closely with HTMX. It's distinct from API-focused frameworks like FastAPI. The Python function-naming *is the HTML-template languge.*

* **HTMX:** Enables dynamic, interactive UIs directly in HTML via attributes, minimizing the need for custom JavaScript. Pipulate uses it for server-rendered HTML updates â€” *over the wire HTML*-fragments targeting elements of the DOM directly instead of fragile, performance-reducing, framework-dependent JSON. *THIS* is where you *jump off the tech-churn hamsterwheel* and future-proof yourself.

* **MiniDataAPI:** A lightweight layer for interacting with SQLite and other databases. Uses Python dictionaries for schema definition, promoting type safety without the complexity of traditional ORMs â€” effectively future-proofing your SQL. You lose fancy *join* capabilities but in exchange get the *Python dict interface* as your main persistent database API forever-forward, enabiling instant swapability between SQLite and PostgreSQL (for example).

* **Ollama:** Facilitates running LLMs locally, enabling in-app chat, workflow guidance, and future automation capabilities while ensuring privacy and avoiding API costs. Your local AI (Chip O'Theseus) learns & grows with you, hopping from hardware to hardware as you upgrade â€” like a genie in a hermitcrab shell. And if that weren't kooky enough â€” it knows how to make MCP-calls!!! That's right, your friendly localhost AI Chip O'Theseus is also an *MCP client!* Your linear workflows ain't so linear anymore when a single-step can be: "Go out and do whatever."

* **SQLite & Jupyter Notebooks:** Foundational tools for data persistence and the workflow development process (porting from notebooks to Pipulate workflows). SQLite is built into Python and really all things â€” the *get-out-of-tech-liability free card* you didn't know you had. And a full JupyterLab instance is installed side-by-side with Pipulate sharing the same Python `.venv` virtual environment (on Nix!!!), so... well... uhm, there are no words. If you know you know.

--------------------------------------------------------------------------------

## How to Install Pipulate

### Quick Start: Be Running in 5 Minutes

This guide shows you how to install Pipulate using two main commands in your terminal. This works on macOS or on Windows using WSL (Windows Subsystem for Linux) with an Ubuntu (or similar Linux) terminal.

## Quick Start: Be Running in 5 Minutes

### 1. Install Nix (One-Time Setup)

```bash
curl --proto '=https' --tlsv1.2 -sSf -L https://install.determinate.systems/nix | sh -s -- install
```

**Close your terminal and open a new one after installation.**

### 2. Install Pipulate

With a custom name
```bash
curl -L https://pipulate.com/install.sh | sh -s Botifython
```

Or default installation
```bash
curl -L https://pipulate.com/install.sh | sh
```

### 3. Run It

```bash
cd ~/Botifython
nix develop
```

These few commands:
- âœ… Updates to the latest version automatically
- âœ… Starts JupyterLab and the Pipulate server  
- âœ… Opens web interfaces in your browser
- âœ… Provides a complete, reproducible development environment

**That's it!** You now have a local-first development environment with AI integration.

### 4. Run It Again!

1. You can just forcibly exit out of that Terminal it's running from.
2. Open a new Terminal, and once again:

```bash
cd ~/Botifython
nix develop
```

### 5. The Big Reset (If Necessary)

Things sometimes go wrong. This is how you do a full Pipulate reset. This will also delete anything you downloaded with Pipulate. Adjust custom install name to what you used.

```bash
rm -rf ~/Botifython
curl -L https://pipulate.com/install.sh | sh -s Botifython
cd ~/Botifython
nix develop
```

Wait for ***BOTH TABS*** to auto-open in your browser.

--------------------------------------------------------------------------------

## Developer Setup & Environment Notes

* **Nix Environment Activation:** Always run `nix develop` from the `~/pipulate` directory *before* running any project commands (`python server.py`, `pip install`, etc.) in a new terminal. This ensures you are using the correct dependencies defined in `flake.nix`.
* **Interactive vs. Quiet Shell:**
    * `nix develop` (or `nix develop .#default`): Standard interactive shell, runs the startup script (`run-script` defined in `flake.nix`) with welcome messages and service startup. Ideal for general use.
    * `nix develop .#quiet`: Activates the Nix environment *without* running the full startup script or launching services automatically. It only sets up paths and installs pip requirements. Use this for:
        * Running specific commands without starting the servers (e.g., `nix develop .#quiet --command python -c "import pandas"`).
        * Debugging or interacting with AI assistants where verbose startup output is undesirable.
        * Manually running `run-server` or `run-jupyter` (scripts placed in `.venv/bin` by the `shellHook`).
* **Dependencies:** System-level dependencies (Python version, libraries like `gcc`, `zlib`) are managed by `flake.nix`. Python package dependencies are managed by `pip` using `requirements.txt` within the Nix-provided environment.
* **Source of Truth:** The `flake.nix` file is the definitive source for the development environment setup.

--------------------------------------------------------------------------------

## Architecture & Key Concepts

Pipulate features a distinct architecture designed for its local-first, simple, and observable nature.

### Architecture Overview Diagram

This diagram illustrates the high-level components and their interactions:

```
                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” Like Electron, but full Linux subsystem 
                 â”‚   Browser   â”‚ in a folder for macOS and Windows (WSL)
                 â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚ HTTP/WS
                       â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚           Nix Flake Shell             â”‚ - In-app LLM (where it belongs)
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚ - 100% reproducible
    â”‚  â”‚   FastHTML    â”‚  â”‚    Ollama    â”‚  â”‚ - 100% local
    â”‚  â”‚   HTMX App    â”‚  â”‚  Local LLM   â”‚  â”‚ - 100% multi-OS    
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
    â”‚          â”‚                            â”‚
    â”‚    â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
    â”‚    â”‚MiniDataAPIâ”‚â—„â”€â”€â”€â–ºâ”‚ SQLite DB  â”‚   â”‚
    â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

This complete, self-contained environment runs identically on any operating system, providing the foundation for all Pipulate workflows and AI interactions.

---

### Integrated Data Science Environment

Jupyter Notebooks run alongside the FastHTML server, allowing developers to prototype workflows in a familiar environment before porting them to Pipulate's step-based interface for end-users. The same Python virtual environment (`.venv`) is shared, and ad-hoc package installation is supported.

```
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚   Jupyter Lab    â”‚    â”‚    FastHTML      â”‚
      â”‚   Notebooks      â”‚    â”‚     Server       â”‚
      â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
      â”‚ â”‚ Cell 1   â”‚     â”‚    â”‚  â”‚ Step 1   â”‚    â”‚
      â”‚ â”‚          â”‚     â”‚--->â”‚  â”‚          â”‚    â”‚
      â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
      â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
      â”‚ â”‚ Cell 2   â”‚     â”‚    â”‚  â”‚ Step 2   â”‚    â”‚
      â”‚ â”‚          â”‚     â”‚--->â”‚  â”‚          â”‚    â”‚
      â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
      â”‚  localhost:8888  â”‚    â”‚  localhost:5001  â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Local-First & Single-Tenant Details

Pipulate manages all state server-side within the local environment (think *local-server cookies*), avoiding cloud dependencies. This approach offers:
* **Privacy & Control:** Data never leaves the user's machine.
* **Full Resource Access:** Utilize local CPU/GPU freely for intensive tasks (scraping, 24/7 AI processing) at minimal cost.
* **Simplicity:** Eliminates complexities associated with multi-tenancy, cloud deployment, and distributed state.
* **Observability:** State changes (via DictLikeDB/JSON) are transparent and easily logged.

```
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” # Benefits of Local-First Simplicity
      â”‚          Web Browser          â”‚
      â”‚                               â”‚ - No mysterious client-side state
      â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚ - No full-stack framework churn
      â”‚    â”‚   Server Console   â”‚     â”‚ - No complex ORM or SQL layers
      â”‚    â”‚     & Web Logs     â”‚     â”‚ - No external message queues
      â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚ - No build step required
      â”‚              â–¼                â”‚ - Direct, observable state changes
      â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
      â”‚    â”‚  Server-Side State  â”‚    â”‚ 
      â”‚    â”‚  DictLikeDB + JSON  â”‚ â—„â”€â”€â”€â”€â”€ Conceptually like local-server-side cookies
      â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚ - Enables the "Know EVERYTHING!" philosophy
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Server-Rendered UI (HTMX)

The UI is constructed primarily with server-rendered HTML fragments delivered via HTMX. This minimizes client-side JavaScript complexity.
* FastHTML generates HTML components directly from Python.
* HTMX handles partial page updates based on user interactions, requesting new HTML snippets from the server.
* WebSockets and Server-Sent Events (SSE) provide real-time updates (e.g., for chat, live development reloading).

```
                        HTMX+Python enables a world-class
                  Python front-end Web Development environment.
                             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                             â”‚    Navigation Bar   â”‚  - No template language (like Jinja2)
                             â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  - HTML elements are Python functions
  Simple Python back-end     â”‚  Main   â”‚   Chat    â”‚  - Minimal custom JavaScript / CSS
  HTMX "paints" HTML into    â”‚  Area   â”‚ Interface â”‚  - No React/Vue/Angular overhead
  the DOM on demand â”€â”€â”€â”€â”€â”€â”€â–º â”‚         â”‚           â”‚  - No "build" process like Svelte
                             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  - No virtual DOM, JSX, Redux, etc.
```

### Pipeline Workflows

Designed for porting notebook-style processes, workflows are sequences of steps where the state is managed explicitly at each stage and stored persistently (typically as a JSON blob in the `pipeline` table).
* **Resumable & Interrupt-Safe:** Because each step's completion is recorded, workflows can be stopped and resumed.
* **Explicit State Flow:** Data typically passes from one step's output (`done` field) to the next via the `transform` function, simplifying debugging. Patterned on Unix pipes.
* **Good Training Data:** The structured input/output of each step creates valuable data for potentially fine-tuning models.
* **Proprietary Friendly:** Excellent for proprietary domain-experts and fields (competing academic, finances) who *resist* letting their data flow onto the Web for general AI training.

```
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   - Fully customizable steps
  â”‚ Step 01 â”‚â”€pipedâ”€â–ºâ”‚ Step 02 â”‚â”€pipedâ”€â–ºâ”‚ Step 03 â”‚   - Interruption-safe & resumable
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   - Easily ported from Notebooks
       â”‚                  â”‚                  â”‚        - One DB record per workflow run
       â–¼                  â–¼                  â–¼        - Everything stays on your machine
  State Saved        State Saved         Finalized?   - Magnitudes simpler than celery
```

#### Run All Cells Pattern

The `run_all_cells()` method creates the perfect mental model - workflows execute sequentially like Jupyter notebook cells:

```
    ğŸ““ JUPYTER NOTEBOOK               ğŸŒ PIPULATE WORKFLOW
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•               â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    [ ] Cell 1: Import data          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                            â”‚  Step 1: Data Input â”‚ 
        â–¼                            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    [â–¶] Cell 2: Process data                    â”‚ hx_trigger="load"
        â”‚                                       â–¼
        â–¼                            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    [ ] Cell 3: Generate report      â”‚ Step 2: Processing  â”‚
        â”‚                            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â–¼                                       â”‚ hx_trigger="load"  
    [ ] Cell 4: Export results                  â–¼
                                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    ğŸ¯ "Run All Cells" Button   â•â•â•â–º â”‚ Step 3: Export      â”‚
       Executes top-to-bottom        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       
       Same mental model, same execution flow!
       But with persistent state and web UI.
```

### LLM Integration (Ollama)

Integration with a local Ollama instance provides AI capabilities without external API calls:
* **Privacy:** Prompts and responses stay local.
* **Cost-Effective:** No per-token charges; run continuously using local resources.
* **Streaming Support:** Real-time interaction via WebSockets.
* **Bounded Context:** Manages conversation history effectively.
* **Tool Calling:** Can interpret structured JSON from the LLM to execute functions.

```
                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                   â”‚   Local Ollama   â”‚ - No API keys needed
                   â”‚      Server      â”‚ - Completely private processing
                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â”‚ Streaming via WebSocket
                            â–¼
                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                   â”‚   Pipulate App   â”‚ - Monitors WS for MCP tool-call commands
                   â”‚(WebSocket Client)â”‚ - Parses responses in real-time
                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â”‚ In-memory or DB backed
                            â–¼
                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                   â”‚     Bounded      â”‚ - Manages context window (~128k)
                   â”‚   Chat History   â”‚ - Enables RAG / tool integration
                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Multi-OS & CUDA Support (Nix)

Nix Flakes ensure a consistent environment across Linux, macOS, and Windows (via WSL), optionally leveraging CUDA GPUs if detected.

```
               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â”‚  Linux / macOS   â”‚ - Write code once, run anywhere
               â”‚  Windows (WSL)   â”‚ - Consistent dev environment via Nix
               â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   - Like cross-OS Homebrew brew install
                        â”‚
                        â”‚ Nix manages dependencies
                        â–¼
               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â”‚   CUDA Support   â”‚ - Auto-detects NVIDIA GPU w/ CUDA
               â”‚   (if present)   â”‚ - Uses GPU for LLM acceleration
               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   - Falls back to CPU if no CUDA
```

### UI Layout

The application interface is organized into distinct areas:

```
               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â”‚         Navigation         â—„â”€â”€ Search, Profiles,
               â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    Apps, Settings
               â”‚               â”‚             â”‚
    Workflow, â”€â”€â–º   Main Area  â”‚    Chat     â”‚
    App UI     â”‚   (Pipeline)  â”‚  Interface â—„â”€â”€ LLM Interaction 
               â”‚               â”‚             â”‚
               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

UI Component Hierarchy (Click to Expand)

```
home (Root Component)
    |
    +-- create_outer_container
        |
        +-- create_nav_group
        |   |
        |   +-- create_nav_menu
        |       |
        |       +-- create_profile_menu
        |       +-- create_app_menu
        |
        +-- create_grid_left
            |
        +-- create_notebook_interface (Displays steps/cells)
```

### File Structure

```plaintext
    .
    â”œâ”€â”€ .cursor                   # Guidelines for AI code editing (if using Cursor)
    â”œâ”€â”€ .venv/                    # Virtual environment (shared by server & Jupyter)
    â”œâ”€â”€ data/
    â”‚   â””â”€â”€ data.db               # SQLite database
    â”œâ”€â”€ downloads/                # Default location for workflow outputs (e.g., CSVs)
    â”œâ”€â”€ helpers/
 Â Â  â”‚Â Â  â”œâ”€â”€ botify  
 Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ botify_api.ipynb  # Git managed massive example notebook, produces docs
 Â Â  â”‚Â Â  â”œâ”€â”€ cleanup               # Temporary scripts to help clean up the system
 Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ organize_css.py   # Example of what might be found there
    â”‚   â””â”€â”€ create_workflow.py    # Useful workflow production helpers
    â”œâ”€â”€ logs/
 Â Â  â”‚Â Â  â”œâ”€â”€ api.log               # Specific API-calls, rotating last-N server runs
    â”‚   â””â”€â”€ Botifython.log        # Server logs (useful for debugging / AI context)
    â”œâ”€â”€ static/                   # JS, CSS, images
    â”œâ”€â”€ plugins/                  # Workflow plugins
    â”œâ”€â”€ training/                 # Markdown files for AI context/prompts
    â”œâ”€â”€ flake.nix                 # Nix flake definition for reproducibility
    â”œâ”€â”€ LICENSE
    â”œâ”€â”€ notebook_introduction_local.ipynb  # Editable (non-auto-updating) copy of botify_api.ipynb
    â”œâ”€â”€ README.md                 # This file
    â”œâ”€â”€ requirements.txt          # Python dependencies (managed by Nix)
    â””â”€â”€ server.py                 # Main application entry point
```

## Critical Implementation Patterns for LLMs

**These patterns are essential for LLMs working with Pipulate and are frequently missed:**

### 1. The Auto-Key Generation Pattern (MOST CRITICAL)

When a user hits Enter on an empty key field, this specific sequence occurs:

1. **Form Submission**: POSTs to `/{APP_NAME}/init` with empty `pipeline_id`
2. **Server Response**: The `init` method MUST return an `HX-Refresh` response:
   ```python
   if not user_input:
       from starlette.responses import Response
       response = Response('')
       response.headers['HX-Refresh'] = 'true'
       return response
   ```
3. **Page Reload**: HTMX triggers a full page reload
4. **Auto-Key Population**: The `landing()` method calls `pip.generate_pipeline_key(self)` to populate the input field
5. **User Interaction**: User hits Enter again to start the workflow

### 2. The Chain Reaction Pattern: The `run_all_cells()` Breakthrough

Pipulate uses HTMX-driven step progression powered by the brilliantly named `run_all_cells()` method:

1. **Initial Trigger**: After `init`, the `run_all_cells()` method initializes the workflow just like Jupyter's "Run All Cells"
2. **Perfect Mental Model**: The method name creates immediate understanding - workflows execute top-to-bottom like notebook cells
3. **Step Handlers**: Each step has GET (display) and POST (submit) handlers
4. **Automatic Progression**: Completed steps trigger next step with `hx_trigger="load"`
5. **State Persistence**: Each step stores data in pipeline state
6. **Pedagogical Brilliance**: The naming makes the system instantly intuitive for developers and AI assistants

**Example: The `run_all_cells()` Pattern in Action**

```python
# âœ… CORRECT: Use the run_all_cells() method for workflow initialization
async def init(self, request):
    """Initialize workflow using the run_all_cells pattern"""
    return pip.run_all_cells(app_name, steps)

# âŒ ANTI-PATTERN: Manual placeholder creation
async def init(self, request):
    """Manual approach - harder to understand and maintain"""
    first_step_id = steps[0].id
    return Div(
        Div(id=first_step_id, hx_get=f'/{app_name}/{first_step_id}', hx_trigger='load'),
        id=f"{app_name}-container"
    )
```

The `run_all_cells()` method encapsulates the workflow initialization pattern and creates an immediate mental connection to Jupyter notebooks.

### 3. APP_NAME vs. Filename Distinction

**Critical for data integrity:**

* **Filename** (e.g., `200_workflow_genesis.py`): Determines public URL endpoint and menu ordering
* **APP_NAME Constant** (e.g., `APP_NAME = "workflow_genesis_internal"`): Internal identifier that MUST REMAIN STABLE

### 4. State Management via DictLikeDB

* State stored as JSON blobs in pipeline table
* Accessed via `pip.get_step_data()` and `pip.set_step_data()`
* All state changes are transparent and observable

### 5. Plugin Discovery System

* Files in `plugins/` directory are auto-discovered
* Numeric prefixes control menu ordering
* Classes must have `landing` method and name attributes
* Automatic dependency injection based on `__init__` signature

## Workflow Development Helper Scripts

Pipulate includes sophisticated helper scripts for workflow development:

### `create_workflow.py`
Creates new workflows from templates:
```bash
python create_workflow.py workflow.py MyWorkflow my_workflow \
  "My Workflow" "Welcome message" "Training prompt" \
  --template trifecta --force
```

### `splice_workflow_step.py`
Adds steps to existing workflows:
```bash
python splice_workflow_step.py workflow.py --position top
python splice_workflow_step.py workflow.py --position bottom
```

### Template System
* `blank`: Minimal workflow with one step
* `trifecta`: Three-step workflow pattern
* Automatic method generation and insertion

## Common LLM Implementation Mistakes

**LLMs frequently make these errors:**

1. **Missing HX-Refresh Response**: Forgetting to return the refresh response for empty keys
2. **Incorrect Key Generation**: Not using `pip.generate_pipeline_key(self)` properly
3. **Missing Cursor Positioning**: Forgetting the `_onfocus` attribute for user experience
4. **Wrong Route Handling**: Not understanding the difference between landing page and init routes
5. **State Inconsistency**: Not properly handling the key generation and storage flow
6. **APP_NAME Changes**: Modifying APP_NAME after deployment, orphaning existing data
7. **Chain Reaction Breaks**: Not properly implementing the HTMX step progression pattern

## Key Design Guidelines & Patterns

These "speedbumps" reinforce Pipulate's core philosophy:

  * **Local vs. Enterprise Mindset:** Embrace local-first simplicity. Avoid patterns designed for distributed, multi-tenant systems.
  * **JSON State Management (Workflows):** Keep workflow state in self-contained steps within a single JSON blob per run. Avoid complex state machines or external step tracking.
  * **Database (MiniDataAPI):** Use the simple schema definition and access patterns provided. Avoid heavy ORMs.
  * **Workflow Pattern:** Ensure workflows are linear and state is explicitly passed or saved at each step. Avoid complex async task chaining that obscures state.
  * **UI Rendering Pattern:** Generate HTML directly from Python components via FastHTML. Avoid template engines.
  * **WebSocket Pattern:** Use the dedicated `Chat` class for managing LLM interactions. Avoid raw WebSocket handling elsewhere.
  * **Workflow Progression Pattern:** Workflows use an explicit chain reaction pattern with `hx_trigger="load"` to manage step progression. This pattern must be preserved exactly as implemented. See the workflow documentation for details.

## Core Concepts & Internal Components

  * **Monitoring:** A file system watchdog monitors code changes. Valid changes trigger an automatic, monitored server restart via Uvicorn, facilitating live development.

```
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ File System â”‚ Changes â”‚  AST Syntax  â”‚ Checks Code
        â”‚  Watchdog   â”‚ Detects â”‚   Checker    â”‚ Validity
        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
               â”‚ Valid Change           â”‚
               â–¼                        â–¼
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚    Uvicorn Server         â”‚â—„â”€â”€â”€ â”‚  Reload  â”‚ Triggers Restart
 â”‚ (Handles HTTP, WS, SSE)   â”‚     â”‚ Process  â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

-----

## Final Thoughts

Pipulate offers a unique approach to building local, AI-assisted applications, prioritizing simplicity, user control, and reproducibility over conventional scaling patterns. By understanding its core concepts and embracing its philosophy, developers can create powerful workflows, and end-users can benefit from AI guidance without cloud dependencies.

Remember the guiding principles:

1.  **Keep it simple.**
2.  **Stay local and single-user.**
3.  **Embrace the unconventional.**

-----

## Developer's Notes

### The Pipulate Workshop

The repository includes not only polished plugins but also experimental scripts and notebooks under development (e.g., in the root directory or marked with `xx_` prefix in plugin directories). These represent ongoing work and exploration.

### Plugin Development Conventions

#### Auto-Registration Behavior

  * **Numeric Prefixes:** Files like `workflows/10_hello_flow.py` are registered as `hello_flow` (number stripped for internal name, used for menu order).
  * **Parentheses Skip:** Files with `()` in the name (e.g., `hello_flow (Copy).py`) are skipped â€“ useful for temporary copies during development.
  * **`xx_` Prefix Skip:** Files prefixed with `xx_` (e.g., `xx_experimental_flow.py`) are skipped â€“ useful for keeping unfinished work in the plugin directories without activating it.

#### Workflow for Creating New Plugins

1.  **Copy:** Copy a template to `my_flow (Copy).py`.
2.  **Modify:** Develop your workflow. It won't auto-register yet.
3.  **Test:** Rename to `xx_my_flow.py`. The server should auto-reload. Test thoroughly.
4.  **Deploy:** Rename to `##_my_flow.py` to assign menu order and activate.

#### Git History Considerations

Use `git mv` for simple renames (like `xx_` to numbered prefix) to preserve history. Document more complex renames in commit messages.

```bash
git mv workflows/xx_my_flow.py workflows/##_my_flow.py
git commit -m "Feat: Promote workflow xx_my_flow.py to ##_my_flow.py"
```

-----

## Roadmap

**Core & Workflow Enhancements:**

  * Dev, Test, and Prod database switching
  * Saving source HTML and rendered DOM of any URL
  * Botify data export CSV save (incorporating robust polling)
  * Full web form field support (textarea, dropdown, checkboxes, radio buttons)
  * Generic support for Anywidgets
  * Utility for deleting garbage tables from plugin experimentation

**AI / LLM Integration:**

  * LLM inspection of any local data object (RAG-style functionality)
  * Various memory types for LLM context (vector embedding, graph, key/val-store)
  * Enabling the local LLM to be an MCP Client

**Automation & External Interaction:**

  * MCP Server for automated web browsing and similar tasks

-----

## Included PrismJS Highlighting

THEMES
- Okaidia ocodia 1.77KB

LANGUAGES
- CSS1.71KB
- Markup + HTML + XML + SVG + MathML + SSML + Atom + RSS4.64KB
- C-like0.83KB
- JavaScript6.18KB
- Bash + Shell + Shell zeitgeist87 8.96KB
- Diff uranusjr 1.33KB
- JSON + Web App Manifest CupOfTea696 0.58KB
- JSON5 RunDevelopment 0.52KB
- JSONP RunDevelopment 0.23KB
- Liquid cinhtau 2.56KB
- Lua Golmote 0.74KB
- Markdown Golmote 10.43KB
- Markup templating
- Mermaid RunDevelopment 3.03KB
- Nix Golmote 1.47KB
- Python multipetros 2.45KB
- Regex RunDevelopment 2.33KB
- YAML hason 3.11KB

PLUGINS
- Line Highlight11.66KB
- Line Numbers kuba-kubula 7.23KB
- Toolbar mAAdhaTTah 5.63KB

## Contributing

Contributions are welcome\! Please adhere to the project's core philosophy:

  * Maintain Local-First Simplicity (No multi-tenant patterns, complex ORMs, heavy client-side state).
  * Respect Server-Side State (Use DictLikeDB/JSON for workflows, MiniDataAPI for CRUD).
  * Preserve the Workflow Pipeline Pattern (Keep steps linear, state explicit).
  * Honor Integrated Features (Don't disrupt core LLM/Jupyter integration unless enhancing local goals).

-----

## License

This project is licensed under the MIT License. See the [LICENSE](LICENSE) file for details.

