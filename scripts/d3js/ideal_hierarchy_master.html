<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Ideal Hierarchy Master View (Diagnostic HUD)</title>
    <style>
        :root {
            --bg-color: #050505;
            --text-color: #ccc;
            --panel-bg: rgba(10, 10, 15, 0.95);
            --panel-border: #333;
        }
        body.light-mode {
            --bg-color: #ffffff;
            --text-color: #111;
            --panel-bg: rgba(245, 245, 250, 0.95);
            --panel-border: #ccc;
        }
        body { 
            margin: 0; 
            background-color: var(--bg-color); 
            color: var(--text-color);
            font-family: 'Courier New', monospace;
            overflow: hidden;
            transition: background-color 0.5s, color 0.5s;
        }
        #graph { width: 100vw; height: 100vh; }
        #controls {
            position: absolute;
            top: 20px; 
            left: 20px;
            background: var(--panel-bg);
            padding: 20px;
            border: 1px solid var(--panel-border);
            border-radius: 8px;
            pointer-events: auto;
            z-index: 100;
            width: 260px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
        }
        h3 { margin: 0 0 12px 0; font-size: 13px; text-transform: uppercase; letter-spacing: 1px; border-bottom: 1px solid var(--panel-border); padding-bottom: 8px;}
        .control-group { margin-bottom: 12px; }
        label { display: flex; justify-content: space-between; font-size: 11px; margin-bottom: 4px; opacity: 0.8; }
        input[type=range] { width: 100%; cursor: pointer; }
        #status { font-size: 10px; opacity: 0.6; margin-top: 10px; text-align: center; }
        
        button {
            width: 100%;
            padding: 8px;
            margin-top: 10px;
            background: transparent;
            border: 1px solid var(--panel-border);
            color: var(--text-color);
            cursor: pointer;
            border-radius: 4px;
            font-family: inherit;
            text-transform: uppercase;
            font-size: 11px;
        }
        button:hover { background: rgba(128,128,128,0.1); }

        .legend { margin-top: 15px; border-top: 1px solid var(--panel-border); padding-top: 10px; }
        .legend-item { display: flex; align-items: center; font-size: 10px; margin-bottom: 4px; }
        .dot { width: 8px; height: 8px; border-radius: 50%; margin-right: 8px; display: inline-block; }
    </style>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body class="dark-mode">
    <div id="controls">
        <h3>Graph Controls</h3>
        <div class="control-group">
            <label><span>Territory (Cluster)</span> <span id="val-collide">0.0</span></label>
            <input type="range" id="slider-collide" min="0.0" max="8.0" step="0.5" value="0.0">
        </div>
        <div class="control-group">
            <label><span>Orbit (Expansion)</span> <span id="val-radial">2.0</span></label>
            <input type="range" id="slider-radial" min="0.1" max="4.0" step="0.1" value="2.0">
        </div>
        <div class="control-group">
            <label><span>Edge Visibility</span> <span id="val-edge">1.0</span></label>
            <input type="range" id="slider-edge" min="0.0" max="1.0" step="0.05" value="1.0">
        </div>
        <button id="btn-theme">Toggle Day/Night</button>
        
        <div class="legend">
            <div class="legend-item"><span class="dot" style="background:#00ff00;"></span>Thriving</div>
            <div class="legend-item"><span class="dot" style="background:#ccff00;"></span>Recovering</div>
            <div class="legend-item"><span class="dot" style="background:#888888;"></span>Stable</div>
            <div class="legend-item"><span class="dot" style="background:#ff9900;"></span>Ailing</div>
            <div class="legend-item"><span class="dot" style="background:#ff0000;"></span>Critical</div>
            <div class="legend-item"><span class="dot" style="background:#00ffff;"></span>Newborn</div>
            <div class="legend-item"><span class="dot" style="background:#bd00ff;"></span>Hub/Topic</div>
        </div>

        <div id="status">Initializing...</div>
    </div>
    
    <div id="graph"></div>

    <script>
        // Placeholder data - will be replaced by Python script
        const rawGraph = {nodes:[], links:[]}; 

        const width = window.innerWidth;
        const height = window.innerHeight;

        // --- TOPOLOGICAL SEEDING ---
        // Ensure Root doesn't have a parent
        rawGraph.nodes.forEach(n => {
            if (n.id === "hub_0") n.parentId = null; 
        });

        // Stratify if possible to seed initial positions
        try {
            const stratify = d3.stratify().id(d => d.id).parentId(d => d.parentId);
            const root = stratify(rawGraph.nodes);
            const treeLayout = d3.cluster().size([2 * Math.PI, 2000]); 
            treeLayout(root);

            const nodeMap = new Map(root.descendants().map(d => [d.id, d]));

            rawGraph.nodes.forEach(node => {
                const treeNode = nodeMap.get(node.id);
                if (treeNode) {
                    const theta = treeNode.x - Math.PI / 2; 
                    const r = treeNode.y; 
                    node.x = width/2 + r * Math.cos(theta) * 0.1; 
                    node.y = height/2 + r * Math.sin(theta) * 0.1;
                }
            });
            console.log("Topological Seeding Complete.");
        } catch (e) {
            console.warn("Seeding failed (graph might vary):", e);
        }

        // --- SETUP ---
        const svg = d3.select("#graph").append("svg")
            .attr("width", width)
            .attr("height", height);

        const g = svg.append("g");

        const zoom = d3.zoom().scaleExtent([0.01, 10]).on("zoom", (event) => {
            g.attr("transform", event.transform);
        });

        const initialScale = 0.2;
        const initialTx = (width * (1 - initialScale)) / 2;
        const initialTy = (height * (1 - initialScale)) / 2;

        svg.call(zoom)
           .call(zoom.transform, d3.zoomIdentity.translate(initialTx, initialTy).scale(initialScale));

        // --- PHYSICS ---
        const BASE_RING_SPACING = 300;
        const ARTICLE_ORBIT_OFFSET = 80; 
        
        let collideMultiplier = 0.0; 
        let radialMultiplier = 2.0;

        const simulation = d3.forceSimulation(rawGraph.nodes)
            .force("link", d3.forceLink(rawGraph.links).id(d => d.id)
                .distance(d => d.type === 'hub_link' ? 150 : 30)
                .strength(d => d.type === 'hub_link' ? 0.2 : 1.5))
            .force("charge", d3.forceManyBody().strength(-200))
            .force("r", d3.forceRadial(d => {
                const baseRing = d.depth * BASE_RING_SPACING * radialMultiplier;
                if (d.group === 'article') return baseRing + ARTICLE_ORBIT_OFFSET;
                return baseRing; 
            }, width / 2, height / 2).strength(0.8)) 
            .force("collide", d3.forceCollide().radius(d => {
                if (d.group === 'hub' || d.group === 'root') return d.val * collideMultiplier;
                return d.val + 2; 
            }).iterations(2));

        // --- RENDER ---
        const link = g.append("g")
            .attr("class", "links")
            .selectAll("line")
            .data(rawGraph.links)
            .join("line")
            .attr("stroke-width", d => d.type === 'hub_link' ? 1.5 : 0.5)
            .attr("stroke-opacity", 1.0); 

        const node = g.append("g")
            .selectAll("circle")
            .data(rawGraph.nodes)
            .join("circle")
            .attr("r", d => d.val)
            .call(drag(simulation));
        
        // Tooltip
        node.append("title").text(d => {
            let txt = d.label;
            if (d.status && d.status !== 'unknown' && d.group === 'article') {
                txt += `\nStatus: ${d.status.toUpperCase()}`;
                txt += `\nVelocity: ${d.velocity}`;
                txt += `\nTotal Clicks: ${d.clicks}`;
            }
            return txt;
        });

        // --- COLOR LOGIC ---
        function getNodeColor(d, isLight) {
            if (d.group === 'root') return "#ff00ff";
            if (d.group === 'hub') return isLight ? "#7b00cc" : "#bd00ff";
            
            // Health Status Colors
            switch (d.status) {
                case 'critical': return "#ff0000"; // Red
                case 'ailing': return "#ff9900";   // Orange
                case 'stable': return "#888888";   // Gray
                case 'recovering': return "#ccff00"; // Yellow-Green
                case 'thriving': return "#00ff00";   // Green
                case 'newborn': return "#00ffff";    // Cyan
                default: 
                    // Fallback to original blue theme if no status
                    if (isLight) return d3.interpolateBlues(0.5);
                    return d3.interpolateGnBu(0.5);
            }
        }

        function updateColors() {
            const isLight = document.body.classList.contains('light-mode');
            const sliderVal = parseFloat(document.getElementById("slider-edge").value);
            
            let strokeColor;
            if (isLight) {
                const val = Math.floor(255 - (sliderVal * 205)); 
                strokeColor = `rgb(${val},${val},${val})`;
            } else {
                const val = Math.floor(sliderVal * 170 + 10); 
                strokeColor = `rgb(${val},${val},${val})`;
            }

            d3.selectAll(".links line").attr("stroke", strokeColor);
            const nodeStroke = isLight ? "#fff" : "#111";
            
            node.attr("stroke", nodeStroke)
                .attr("stroke-width", 1.0)
                .attr("fill", d => getNodeColor(d, isLight));
        }

        simulation.on("tick", () => {
            link
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);
            node
                .attr("cx", d => d.x)
                .attr("cy", d => d.y);
        });

        // Event Listeners
        document.getElementById("slider-collide").addEventListener("input", (e) => {
            collideMultiplier = parseFloat(e.target.value);
            simulation.force("collide").radius(d => {
                if (d.group === 'hub' || d.group === 'root') return d.val * collideMultiplier;
                return d.val + 2; 
            });
            simulation.alpha(0.3).restart();
        });

        document.getElementById("slider-radial").addEventListener("input", (e) => {
            radialMultiplier = parseFloat(e.target.value);
            simulation.force("r").radius(d => {
                const baseRing = d.depth * BASE_RING_SPACING * radialMultiplier;
                if (d.group === 'article') return baseRing + ARTICLE_ORBIT_OFFSET;
                return baseRing; 
            });
            simulation.alpha(0.3).restart();
        });
        
        document.getElementById("slider-edge").addEventListener("input", updateColors);
        document.getElementById("btn-theme").addEventListener("click", () => {
            document.body.classList.toggle('light-mode');
            updateColors();
        });

        updateColors();

        function drag(simulation) {
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x; d.fy = d.y;
            }
            function dragged(event, d) { d.fx = event.x; d.fy = event.y; }
            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null; d.fy = null;
            }
            return d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended);
        }
        
        document.getElementById("status").innerText = "Topology Stabilized.";

    </script>
</body>
</html>