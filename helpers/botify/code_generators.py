# Botify Code Generation Utilities
# Externalized from server.py to reduce token count while preserving functionality

import json
import urllib.parse
from pathlib import Path
from typing import Dict, Any, Optional
from fasthtml.common import A

class BotifyCodeGenerators:
    """üöÄ REUSABLE BOTIFY CODE GENERATION UTILITIES"""
    
    def __init__(self, ui_constants=None):
        """Initialize with optional UI constants for consistent formatting"""
        self.ui_constants = ui_constants or self._get_default_ui_constants()
    
    def _get_default_ui_constants(self):
        """Default UI constants if none provided"""
        return {
            'CODE_FORMATTING': {
                'COMMENT_DIVIDER': '#' + '=' * 100
            }
        }
    
    def get_ui_constants(self):
        """Get UI constants for formatting"""
        return self.ui_constants

    def generate_botify_code_header(self, display_name: str, step_name: str, username: str, project_name: str, 
                                  template_info: dict = None, qualifier_config: dict = None) -> list:
        """Generate standardized header for Botify Python debugging code."""
        ui_constants = self.get_ui_constants()
        comment_divider = ui_constants['CODE_FORMATTING']['COMMENT_DIVIDER']
        
        header_lines = [
            comment_divider,
            f"# Botify API Call Example",
            f"# Generated by: {display_name}",
            f"# Step: {step_name}",
            f"# Organization: {username}",
            f"# Project: {project_name}"
        ]
        
        # Add template information if provided
        if template_info:
            header_lines.append("#")
            header_lines.append(f"# Query Template: {template_info.get('name', 'Unknown')}")
            header_lines.append(f"# Description: {template_info.get('description', 'No description available')}")
            header_lines.append(f"# Export Type: {template_info.get('export_type', 'Unknown')}")
            
            # Add qualifier information if present
            if qualifier_config and qualifier_config.get('enabled', False):
                header_lines.append("#")
                header_lines.append("# üéØ SMART QUALIFIER SYSTEM:")
                header_lines.append(f"# This template uses automatic parameter optimization to stay under API limits.")
                param_name = qualifier_config.get('iterative_parameter_name', 'parameter')
                max_threshold = qualifier_config.get('max_value_threshold', 1000000)
                header_lines.append(f"# The system automatically finds the optimal {param_name} for ~{max_threshold:,} results.")
                if 'user_message_found' in qualifier_config:
                    msg_template = qualifier_config['user_message_found']
                    if '{param_value}' in msg_template and '{metric_value}' in msg_template:
                        header_lines.append(f"# Example: 'Optimal {param_name}: 2 (for 235,623 results)'")
        
        header_lines.extend([
            "#",
            "# üß™ For live JupyterLab environment to experiment with queries:",
            "# http://localhost:8888/lab/tree/helpers/botify/botify_api.ipynb",
            "#",
            "# üìã For copy/paste-able examples to use in JupyterLab:",
            "# http://localhost:5001/documentation",
            comment_divider
        ])
        
        return header_lines

    def generate_botify_token_loader(self):
        """Generate the standard Botify token loading function."""
        return '''def load_api_token() -> str:
    """Load the Botify API token from the token file."""
    try:
        if not os.path.exists(TOKEN_FILE):
            raise ValueError(f"Token file '{TOKEN_FILE}' not found.")
        with open(TOKEN_FILE) as f:
            content = f.read().strip()
            api_key = content.split('\\n')[0].strip()
            if not api_key:
                raise ValueError(f"Token file '{TOKEN_FILE}' is empty.")
            return api_key
    except Exception as e:
        raise ValueError(f"Error loading API token: {str(e)}")'''

    def generate_botify_http_client(self, client_name: str, description: str):
        """Generate the standard HTTP client function for Botify APIs."""
        return f'''async def {client_name}(
    url: str,
    headers: Dict[str, str],
    payload: Dict[str, Any],
    timeout: float = 60.0
) -> Dict[str, Any]:
    """
    {description}
    """
    async with httpx.AsyncClient() as client:
        try:
            response = await client.post(
                url=url,
                headers=headers,
                json=payload,
                timeout=timeout
            )

            print(f"Status Code: {{response.status_code}}")
            response.raise_for_status()

            result = response.json()
            print(f"\\nResults returned: {{len(result.get('results', []))}}")
            print(f"Total count: {{result.get('count', 'N/A')}}")

            # Show first few results for inspection
            results = result.get('results', [])
            if results:
                print("\\nFirst result structure:")
                print(json.dumps(results[0], indent=2))

            return result

        except httpx.HTTPStatusError as e:
            error_msg = f"HTTP error {{e.response.status_code}}: {{e.response.text}}"
            print(f"\\n‚ùå Error: {{error_msg}}")
            raise ValueError(error_msg)
        except Exception as e:
            error_msg = f"Unexpected error: {{str(e)}}"
            print(f"\\n‚ùå Error: {{error_msg}}")
            raise ValueError(error_msg)'''

    def generate_botify_main_executor(self, client_function_name: str, api_description: str):
        """Generate the main execution function for Botify APIs."""
        return f'''async def main():
    """Main execution function for {api_description}"""
    try:
        result = await {client_function_name}(
            url=URL,
            headers=get_headers(),
            payload=PAYLOAD
        )
        return result

    except Exception as e:
        print(f"\\n‚ùå {api_description} failed: {{str(e)}}")
        raise

# Execute in Jupyter Notebook:
await main()

# For standalone script execution:
# if __name__ == "__main__":
#     import asyncio
#     asyncio.run(main())'''

    def create_folder_button(self, folder_path: str, icon: str = "üìÅ", text: str = "Open Folder", 
                           title_prefix: str = "Open folder"):
        """Generate a standardized folder opening button."""
        quoted_path = urllib.parse.quote(str(folder_path))
        title = f"{title_prefix}: {folder_path}"
        
        return A(
            f"{icon} {text}",
            hx_get=f"/open-folder?path={quoted_path}",
            hx_swap="none",
            title=title,
            cls="button-link"
        )

    def get_botify_analysis_path(self, app_name, username, project_name, analysis_slug, filename=None):
        """üöÄ REUSABLE UTILITY: Construct standardized Botify analysis file paths"""
        base_path = Path.cwd() / 'downloads' / app_name / username / project_name / analysis_slug
        
        if filename:
            return base_path / filename
        return base_path

# Convenience instance for backward compatibility with existing plugins
botify_code_generators = BotifyCodeGenerators()

# Export individual functions for easy importing
generate_botify_code_header = botify_code_generators.generate_botify_code_header
generate_botify_token_loader = botify_code_generators.generate_botify_token_loader
generate_botify_http_client = botify_code_generators.generate_botify_http_client
generate_botify_main_executor = botify_code_generators.generate_botify_main_executor
create_folder_button = botify_code_generators.create_folder_button
get_botify_analysis_path = botify_code_generators.get_botify_analysis_path
