# .cursorrules – Local-First Minimalist FastHTML/MiniDataAPI Guidelines

## Core Philosophy
1. **Local-First, Single-Tenant Only:**  
   This code is a stripped-down, single-user, local app—more like an Electron app than an enterprise system. All state is observable server-side through DictLikeDB and JSON blobs.

2. **Server-Side State Only:**  
   No client-side state management (React, Redux) or ORM complexity. Everything lives server-side in a simple, observable data store.

3. **Everything is a DIV:**  
   UI is built entirely from DIVs with HTMX for dynamic updates. No templating engines, component libraries, or client-heavy frameworks.

4. **Pipeline Workflow Pattern:**  
   Workflows are linear JSON blobs with self-contained steps. State flows forward only, with each step's output feeding the next. Perfect for porting WET code from Jupyter Notebooks.

5. **CRUD App Pattern:**  
   Apps are CRUD apps that follow the FastHTML/MiniDataAPI pattern with a single table that inherit from BaseApp. The CRUD is DRY and the Workflows are WET!

6. **Local LLM Integration:**  
   Integrated with Ollama for local, streaming LLM support. Bounded conversation history (128k tokens) with real-time response parsing and tool calling.

## What to Avoid
- **Enterprise/Multi-Tenant Architectures:**  
  No multi-tenancy, ORMs, or heavy abstractions that break the local-first simplicity.
  
- **Over-Engineering:**  
  Avoid unnecessary abstractions that undermine intentional minimalism.
  
- **Client-Side Frameworks:**  
  No React, Angular, or similar. UI remains server-generated with HTMX updates.

## Specific Patterns
1. **State Management:**  
   - *Do:* Use DictLikeDB + JSON for transparent, observable state
   - *Don't:* Add session management or distributed state

2. **UI Construction:**  
   - *Do:* Server-side HTML generation with HTMX updates
   - *Don't:* Add build steps or client-side frameworks

3. **Workflow Pipelines:**  
   - *Do:* Linear, forward-only state flow in JSON blobs
   - *Don't:* Add virtual state or backtracking

4. **LLM Integration:**  
   - *Do:* Local Ollama with bounded history and streaming
   - *Don't:* Add distributed chat or complex memory systems

5. **Development Environment:**  
   - *Do:* Use Nix Flakes for reproducible builds
   - *Don't:* Add environment-specific dependencies

## AI Assistant Integration
- Ollama provides local, streaming LLM support
- JSON command structures for AI operations
- Bounded conversation history (128k tokens)
- Real-time response parsing and tool calling
- Training data generated from workflow pipelines

## SSE & WebSocket Patterns
- Server-Sent Events for real-time updates
- WebSockets for bi-directional communication
- No build step development workflow
- HTMX handles all DOM updates

## Final Reminder
Every design choice prioritizes local control, observability, and radical simplicity. The power comes from combining local LLMs, server-side state, and modern UI patterns into a cohesive, reproducible development environment.

## Important Note on Workflow Identity

Pipulate workflows have two separate identities:
- The **filename** (`110_parameter_buster_workflow.py`) determines the URL/endpoint users access
- The **APP_NAME** (`"parameter_buster"`) identifies the workflow in the database

Keeping these different (as in the example above) allows you to improve user-facing URLs without breaking existing workflow data. Always maintain a consistent APP_NAME when you want to preserve existing workflow state data.

## Workflow Filename vs APP_NAME Pattern
- **Filename** determines user-facing URL/endpoint (`110_parameter_buster_workflow.py` → `/parameter_buster_workflow`)
- **APP_NAME** determines database storage keys (`APP_NAME = "parameter_buster"` for DB records)
- Keep them different to enable URL improvements without breaking stored data
- When changing a workflow's URL (filename), maintain its APP_NAME to preserve existing data
- Create new file versions while keeping same APP_NAME for data continuity during upgrades

## Critical Implementation Patterns

1. **HTMX Chain Reaction:**  
   - The pattern `Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load")` must be preserved exactly
   - Never remove the `hx_trigger="load"` attribute even if it seems redundant
   - This explicit approach is the reliable standard for the application and alternative implicit approaches are not supported

2. **Step Progression Pattern**:
   - **GET Handler** displays UI for user input and must follow this structure:
     ```python
     return Div(
         Card(...),  # Current step content
         Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),  # Next step loader
         id=step_id
     )
     ```
   - **POST Handler** processes submitted data and must include chain reaction:
     ```python
     # Process form data, validate, and store
     await pip.update_step_state(pipeline_id, step_id, value, steps)
     
     return Div(
         pip.revert_control(...),  # Shows completed step with revert option
         Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),  # CRITICAL! Triggers next step
         id=step_id  # CRITICAL! Maintains current step ID
     )
     ```

3. **Breaking the Chain (Only Two Special Cases)**:
   - **Terminal Responses** (for explicit user action):
     ```python
     return Div(
         result_card,
         download_button,
         cls="terminal-response no-chain-reaction",
         id=step_id
     )
     ```
   - **Polling States** (for checking status without progression):
     ```python
     return Div(
         result_card,
         progress_indicator,
         cls="polling-status no-chain-reaction",
         hx_get=f"/{app_name}/check_status",
         hx_trigger="load, every 2s",
         hx_target=f"#{step_id}",
         id=step_id
     )
     ```

4. **Placeholder Step Pattern**:
   - Used for scaffolding workflow steps before implementing full functionality
   - Follows the standard progression pattern but with minimal UI components
   - Implementation example:
     ```python
     # In __init__ steps list
     Step(
         id='step_XX',            # Use proper sequential numbering
         done='placeholder',      # Simple state field name
         show='Placeholder Step', # Descriptive UI text
         refill=True,             # Usually True for consistency
     )
     
     # GET handler 
     async def step_XX(self, request):
         pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
         step_id = "step_XX"
         step_index = self.steps_indices[step_id]
         next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'
         
         # Simple UI with just a proceed button
         return Div(
             Card(
                 H4(f"{pip.fmt(step_id)}: {step.show}"),
                 Form(
                     Button("Proceed", type="submit"),
                     hx_post=f"/{app_name}/{step_id}_submit",
                     hx_target=f"#{step_id}"
                 )
             ),
             Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
             id=step_id
         )
     ```

---
