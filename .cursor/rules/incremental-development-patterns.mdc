---
description: 
globs: 
alwaysApply: false
---
# Incremental Development Patterns

## Overview
Pipulate follows a story-driven approach to incremental improvements, where each enhancement builds upon previous work and is thoroughly documented through git commits and changelog entries.

## Development Philosophy

### Story Arc Approach
Every improvement follows a narrative structure:
1. **Problem Identification** - Clear user pain point or system limitation
2. **Root Cause Analysis** - Technical investigation of underlying issues  
3. **Solution Design** - Architectural approach and implementation strategy
4. **Iterative Implementation** - Clean, incremental changes
5. **Validation & Documentation** - Verification and knowledge capture

### 80/20 Rule Application
Focus on lightweight solutions that handle the majority of cases:
- **Generic systems** over special case code
- **Metadata-driven** approaches for extensibility
- **Pattern consolidation** to reduce maintenance overhead
- **Reusable components** that solve multiple problems

## Implementation Patterns

### Clean Iterative Passes
Each improvement should be:
- **Self-contained** - Complete functionality in single commit
- **Non-breaking** - Preserve existing functionality
- **Well-tested** - Verify all affected components work
- **Documented** - Clear commit message and changelog entry

### Example: Documentation System Evolution
```
1. Problem: Multiple special cases for paginated documents
2. Analysis: Code duplication across 3 different handlers  
3. Solution: Generic pagination system with metadata detection
4. Implementation: Single method handles all paginated documents
5. Validation: All three documents work with new system
```

### Architectural Improvements
- **Keyless utility patterns** - Bypass pipeline overhead for simple tools
- **Chain reaction workflows** - Smooth step-by-step user experiences
- **Generic handlers** - Eliminate special case code duplication
- **Metadata-driven discovery** - Automatic feature detection

## Documentation Integration

### Changelog as Development History
The [training/change_log.md](mdc:training/change_log.md) serves multiple purposes:
- **Development narrative** - Story of how system evolved
- **Technical reference** - Solutions to common problems
- **LLM training data** - Context for future AI assistance
- **Debugging guide** - Historical context for current issues

### Git Commit Strategy
Each commit tells part of the story:
- **Descriptive titles** - What was accomplished
- **Technical details** - How it was implemented  
- **Impact assessment** - Why it matters
- **Verification steps** - Proof it works

## Problem-Solution Patterns

### Crisis Resolution Pattern
```
1. Critical Issue Identified (server won't start)
2. Root Cause Analysis (syntax error, structural problems)
3. Comprehensive Fix (address all related issues)
4. Validation (server starts, functionality restored)
5. Documentation (detailed changelog entry)
```

### UX Enhancement Pattern  
```
1. User Experience Gap (extra clicks, confusing flow)
2. Behavioral Analysis (how users actually interact)
3. Workflow Optimization (reduce friction points)
4. Implementation (autofocus, button behavior changes)
5. Flow Verification (test complete user journey)
```

### System Architecture Pattern
```
1. Code Duplication Identified (multiple special cases)
2. Pattern Recognition (common functionality across cases)
3. Generic Solution Design (metadata-driven approach)
4. Incremental Migration (preserve existing while adding new)
5. Cleanup (remove old special cases)
```

## Quality Assurance

### Validation Requirements
Every change must include:
- **Functional testing** - Core functionality works
- **Regression testing** - Existing features unaffected
- **User experience testing** - Complete workflows function
- **Documentation verification** - Changes properly documented

### Testing Patterns
- **Curl testing** - Verify HTTP responses
- **Browser testing** - Confirm UI functionality  
- **Cross-plugin testing** - Ensure coordination works
- **Edge case testing** - Handle boundary conditions

## Knowledge Capture

### Commit Message Templates
```
Brief descriptive title (50 chars max)

PROBLEM RESOLVED:
- Clear statement of what was broken/missing

TECHNICAL SOLUTION:  
- How the problem was solved
- Key implementation details
- Architectural decisions made

VERIFICATION:
- ✅ What was tested and confirmed working
- ✅ Regression testing performed
- ✅ User experience validated

IMPACT:
- How this improves the system
- What new capabilities are enabled
```

### Changelog Entry Structure
```markdown
### Fixed/Added/Changed
#### Brief descriptive title

**PROBLEM ADDRESSED:**
Clear problem statement with user impact

**SOLUTION IMPLEMENTED:**
- Technical approach taken
- Key implementation details
- Architectural improvements

**VALIDATION PERFORMED:**
- Testing steps completed
- Verification of functionality

**IMPACT:**
- System improvements achieved
- User experience enhancements
```

## Best Practices

### Development Workflow
1. **Identify clear problem** with user impact
2. **Analyze root causes** thoroughly
3. **Design minimal viable solution** (80/20 approach)
4. **Implement incrementally** with testing
5. **Document comprehensively** for future reference

### Code Evolution
- **Preserve working patterns** while improving
- **Consolidate similar functionality** into generic systems
- **Maintain backward compatibility** during transitions
- **Clean up deprecated code** after migration

### Story Continuity
- **Reference previous work** in commit messages
- **Build upon established patterns** rather than reinventing
- **Maintain narrative thread** through changelog entries
- **Connect improvements** to overall system evolution
