---
description: 
globs: 
alwaysApply: false
---
## description: Core concepts for Pipulate workflow development, including plugin structure, APP_NAME vs. filename, and **init** method. globs: ["pipulate/plugins/*.py", "server.py"] alwaysApply: true

# Pipulate Workflow Core Concepts

## 1. Plugin System & Types

Pipulate features an automatic plugin system. Files in the `plugins/` directory are auto-discovered.

  * **CRUD Apps (`BaseCrud`)**: For standard data management (Create, Read, Update, Delete). Inherit from `BaseCrud` in `server.py`. Examples: `profiles_app.py`, `010_tasks.py`. Follow DRY principles.
  * **Workflows (Plain Classes)**: For linear, step-by-step processes, often ported from Jupyter Notebooks. These are plain Python classes adhering to specific conventions. Follow WET (Write Everything Twice/Explicit) principles for clarity and customizability. Example: `020_hello_workflow.py`.

## 2. Workflow Identity: `APP_NAME` vs. Filename

A critical distinction for workflows:

  * **Filename**: e.g., `020_hello_workflow.py`.
      * Determines the **public-facing URL endpoint** for the workflow's landing page (e.g., `/hello_workflow`).
      * The numeric prefix (e.g., `020_`) dictates the **menu order** in the UI.
      * Can be changed (e.g., for reordering or clearer URLs) without breaking existing data IF `APP_NAME` remains consistent.
  * **`APP_NAME` (Class Constant)**: e.g., `APP_NAME = "hello_workflow_internal"`.
      * The **internal identifier** for the workflow.
      * Used for constructing **step-specific routes** (e.g., `/{APP_NAME}/step_01`).
      * Used as the `app_name` value in the `pipeline` database table to **associate stored workflow state** with this workflow type.
      * **CRITICAL**: `APP_NAME` should be unique across all workflows and **must remain stable** once workflows using it have stored data, otherwise existing data for that workflow type will be orphaned.
      * It's good practice for `APP_NAME` to be different from the filename (minus prefix) if you anticipate renaming files for UI/URL purposes but want to keep the underlying data association.

## 3. Workflow Class Structure (`__init__`)

A typical workflow class:

```python
from collections import namedtuple
# ... other imports ...

Step = namedtuple('Step', ['id', 'done', 'show', 'refill', 'transform'], defaults=(None,))

class MyWorkflow:
    APP_NAME = "my_workflow_internal_id" # Stable internal ID
    DISPLAY_NAME = "My User-Friendly Workflow" # For UI menus
    ENDPOINT_MESSAGE = "Welcome! This workflow does X, Y, Z." # For LLM context on landing
    TRAINING_PROMPT = "my_workflow_training.md" # File in training/ for LLM

    def __init__(self, app, pipulate_instance, pipeline_table, db_key_value_store):
        self.app = app # FastHTML app instance
        self.pipulate = pipulate_instance # Core Pipulate helpers from server.py
        self.pipeline_table = pipeline_table # MiniDataAPI object for 'pipeline' table
        self.db = db_key_value_store # DictLikeDB object for 'store' table (global K/V)
        self.app_name = self.APP_NAME # Convenient access

        self.message_queue = self.pipulate.get_message_queue()

        # Define steps
        self.steps = [
            Step(id='step_01', done='input_data', show='Provide Input', refill=True),
            Step(id='step_02', done='processed_data', show='Process Data', refill=False, transform=self._transform_step1_output),
            # ... more steps ...
            Step(id='finalize', done='finalized', show='Finalize', refill=False) # Standard final step
        ]
        self.steps_indices = {step.id: i for i, step in enumerate(self.steps)}

        # Register routes
        self.register_routes(self.app.route)

    def register_routes(self, rt_decorator):
        # Standard workflow routes
        rt_decorator(f'/{self.app_name_from_filename()}', methods=['GET'])(self.landing) # Filename-based landing
        rt_decorator(f'/{self.APP_NAME}/init', methods=['POST'])(self.init)
        rt_decorator(f'/{self.APP_NAME}/revert', methods=['POST'])(self.handle_revert)
        rt_decorator(f'/{self.APP_NAME}/finalize', methods=['GET', 'POST'])(self.finalize_workflow_step) # Renamed for clarity
        rt_decorator(f'/{self.APP_NAME}/unfinalize', methods=['POST'])(self.unfinalize_workflow_step) # Renamed

        # Step-specific routes
        for step in self.steps:
            if step.id != 'finalize': # Finalize uses its specific handler
                rt_decorator(f'/{self.APP_NAME}/{step.id}', methods=['GET'])(getattr(self, step.id))
                rt_decorator(f'/{self.APP_NAME}/{step.id}_submit', methods=['POST'])(getattr(self, f"{step.id}_submit"))

    def app_name_from_filename(self):
        # Helper to derive public URL from filename (convention)
        # Assuming filename is like "NNN_actual_app_name.py"
        # This logic would typically be handled by server.py during plugin discovery
        # For this example, assume it's correctly passed or derived.
        # Example: if filename 020_hello_workflow.py -> "hello_workflow"
        module_file = inspect.getfile(self.__class__)
        base_name = Path(module_file).stem
        return re.sub(r'^\d+_', '', base_name)

    def landing(self, request):  # Note: request parameter is required
        # Landing page logic here
        pass

    def init(self, request):  # Note: request parameter is required
        # Initialization logic here
        pass

    def step_01(self, request):  # Note: request parameter is required
        # Step 1 logic here
        pass

    def step_01_submit(self, request):  # Note: request parameter is required
        # Step 1 submission logic here
        pass

    # ... other methods ...
```

  * **`Step` NamedTuple**:
      * `id` (str): Unique ID (e.g., `step_01`), used in routes and DOM IDs.
      * `done` (str): Key for this step's primary data in the workflow state JSON.
      * `show` (str): User-friendly name for UI.
      * `refill` (bool): If `True`, pre-fill form from existing state on revisit.
      * `transform` (function, optional): Processes data from a *previous* step for current step's input suggestion.
  * **Dependencies**: `app`, `pipulate`, `pipeline_table`, `db` are injected by `server.py` during plugin instantiation.
  * **Routes**:
      * The public landing page URL is derived from the filename (e.g., `plugins/020_hello_workflow.py` -\> `/hello_workflow`).
      * All internal workflow operations (init, steps, finalize) use routes prefixed with `self.APP_NAME`.

## 4. Request Handling

All plugin methods that handle HTTP requests must accept a `request` parameter. This is a fundamental requirement of the Pipulate framework:

1. **Required Parameter**: Every method that handles an HTTP request (GET or POST) must accept a `request` parameter as its first argument after `self`:
   ```python
   def landing(self, request):  # Required
       # Landing page logic here
       pass

   def step_01_submit(self, request):  # Required
       form_data = request.form
       # Process form data...
       pass
   ```

2. **Framework Integration**: The `request` object is essential for:
   - Accessing form data via `request.form`
   - Reading query parameters via `request.query_params`
   - Accessing headers and other HTTP context

3. **Consistent Interface**: This requirement applies to:
   - `landing` method (GET)
   - `init` method (POST)
   - Step handlers (GET)
   - Step submission handlers (POST)
   - `finalize_workflow_step` (GET/POST)
   - `unfinalize_workflow_step` (POST)
   - `handle_revert` (POST)

4. **Error Handling**: Always handle missing or invalid request data gracefully:
   ```python
   def step_01_submit(self, request):
       try:
           user_input = request.form.get('user_input')
           if not user_input:
               return self.pipulate.error_message("Input is required")
           # Process valid input...
       except Exception as e:
           return self.pipulate.error_message(f"Error processing input: {str(e)}")
   ```