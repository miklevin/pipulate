---
description: 
globs: 
alwaysApply: false
---
---
description: Core patterns for implementing widgets in Pipulate workflows, including UI components and interaction handling
globs: ["pipulate/plugins/*.py"]
alwaysApply: false
---

# Widget Implementation Patterns

## Core Pattern
All widgets must follow these core implementation patterns:

1. Chain Reaction Preservation
2. State Management
3. Error Handling
4. Finalization Support

## Widget Categories and Recipes

### Input Widgets
- Text Input: See `training/widget_recipes/input/text_input.md`
- URL Input: See `training/widget_recipes/input/url_input.md`
- Dropdown: See `training/widget_recipes/input/dropdown.md`

### Display Widgets
- Table Display: See `training/widget_recipes/display/table.md`
- Markdown: See `training/widget_recipes/display/markdown.md`
- Mermaid: See `training/widget_recipes/display/mermaid.md`

### Operation Widgets
- API Request: See `training/widget_recipes/operation/api_request.md`
- File Download: See `training/widget_recipes/operation/file_download.md`
- File Upload: See `training/widget_recipes/operation/file_upload.md`

### Integration Widgets
- Browser: See `training/widget_recipes/integration/browser.md`
- Search: See `training/widget_recipes/integration/search.md`

## Implementation Steps
1. Choose appropriate widget category
2. Reference corresponding recipe
3. Follow recipe implementation guide
4. Preserve core patterns

## Recipe Usage
Widget recipes provide:
- Complete implementation examples
- State management patterns
- Error handling approaches
- UI/UX considerations

Always check recipes when implementing new widgets or modifying existing ones.

## Pattern Enforcement
The widget implementation pattern ensures:
1. Consistent user experience
2. Reliable state management
3. Proper error handling
4. Maintainable code structure

## Overview
This guide covers the standard pattern for implementing interactive widgets in Pipulate workflows, as exemplified in [035_url_opener.py](mdc:pipulate/plugins/035_url_opener.py).

## Core Components

### Step Definition
```python
Step(
    id='step_01',
    done='result_key',
    show='User-Friendly Name',
    refill=True,  # Allow value reuse
)
```

### Widget Structure
1. Input Collection
   - Use `Card` for consistent styling
   - Include descriptive `H3` header
   - Place input fields in a `Form`
   - Use clear button labels (e.g., "Search ▸", "Open URL ▸")

2. Result Display
   - Show completed action in `widget_container`
   - Include "Again" button for repeatable actions
   - Display configured values with `B()` tags

## State Management
- Store values using `pip.set_step_data()`
- Check finalized state before rendering
- Use `refill=True` for reusable inputs
- Preserve values when reverting with `_revert_target`

## Button Placement
- Primary action buttons go in forms
- "Again" buttons go in widget containers
- Use consistent arrow symbol (▸) in button labels

## Example Implementation
```python
# Input Collection
Card(
    H3(f"{step.show}"),
    Form(
        Input(
            type="text",
            name="field_name",
            placeholder="Helpful placeholder",
            required=True,
            value=display_value,
            cls="contrast"
        ),
        Button("Action ▸", type="submit", cls="primary"),
        hx_post=f"/{app_name}/{step_id}_submit", 
        hx_target=f"#{step_id}"
    )
)

# Result Display
content_container = pip.widget_container(
    step_id=step_id,
    app_name=app_name,
    message=f"{step.show}: {value}",
    widget=Div(
        P(f"Label: ", B(value)),
        Button(
            "Action Again ▸",
            type="button",
            _onclick="action()",
            cls="secondary"
        )
    ),
    steps=steps
)
```

## Chain Reaction Pattern
Always include next step trigger:
```python
Div(
    content_container,
    Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
    id=step_id
)
```
