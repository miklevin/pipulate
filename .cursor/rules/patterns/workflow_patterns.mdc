---
description: 
globs: 
alwaysApply: false
---
# Workflow Patterns

## Overview
This guide serves as the primary reference for building and modifying workflows within the Pipulate framework. It focuses on core patterns, step management, and maintaining the crucial HTMX chain reaction mechanism.

## Core Concepts
- **Workflow**: A sequence of steps that accomplish a task
- **Step**: A single unit of work in a workflow
- **State**: The current state of a workflow
- **Chain Reaction**: The propagation of state changes
- **Error Handling**: Handling workflow errors

## Core Principles

### 1. State Management
- Widgets should never manage workflow state directly
- Use core workflow methods for state transitions
- Maintain widget state within workflow state
- Never manipulate state directly
- Use `pip.finalize_workflow()` for locking
- Use `pip.unfinalize_workflow()` for unlocking
- Use `pip.rebuild()` for UI updates

### 2. UI Construction
- Follow template patterns for widget UI
- Use standard components
- Maintain consistent structure
- Keep container hierarchy consistent
- Use proper HTMX triggers
- Follow template layout

### 3. Error Handling
- Use standard error patterns
- Provide clear error messages
- Handle edge cases gracefully
- Validate all inputs
- Use consistent error presentation

## Critical Patterns

### 1. Chain Reaction Pattern
```python
# CRITICAL: This pattern is IMMUTABLE
return Div(
    Card(...), # Current step's content
    # CRITICAL: This inner Div triggers loading of the next step
    Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
    id=step_id
)
```

### 2. Widget Container Pattern
```python
# Standard widget container structure
return Div(
    Card(
        H3(f"{step.show}"),
        Form(
            Input(...),
            Button(...),
            hx_post=f"/{app_name}/{step_id}_submit"
        )
    ),
    Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
    id=step_id
)
```

### 3. State Management Pattern
```python
# Reading state
state = pip.read_state(pipeline_id)
step_data = pip.get_step_data(pipeline_id, step_id, {})

# Updating state
await pip.update_step_state(pipeline_id, step_id, value, steps)

# Finalizing state
await pip.finalize_workflow(pipeline_id)
return pip.rebuild(app_name, steps)
```

## Common Widget Patterns

### 1. Dropdown Widget
```python
async def step_01(self, request):
    pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
    step_id = "step_01"
    pipeline_id = db.get("pipeline_id", "unknown")
    
    # Get options using core methods
    options = await self.get_options(pipeline_id)
    
    # Format options using standard patterns
    formatted_options = [await self.format_option(opt) for opt in options]
    
    # Return using standard container structure
    return Div(
        Card(
            H3(f"{step.show}"),
            Form(
                Select(*formatted_options),
                Button("Submit", type="submit")
            )
        ),
        id=step_id
    )
```

### 2. Text Input Widget
```python
async def step_01(self, request):
    pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
    step_id = "step_01"
    pipeline_id = db.get("pipeline_id", "unknown")
    
    # Get current value using core methods
    current_value = pip.get_step_data(pipeline_id, step_id, {}).get(step.done, "")
    
    # Return using standard container structure
    return Div(
        Card(
            H3(f"{step.show}"),
            Form(
                Input(value=current_value),
                Button("Submit", type="submit")
            )
        ),
        id=step_id
    )
```

## Advanced Widget Patterns

### 1. File Upload Pattern
```python
# Form structure
Form(
    Input(
        type="file",
        name="uploaded_files",
        multiple="true",
        required="true",
        cls="contrast"
    ),
    Button("Upload Files ▸", type="submit", cls="primary"),
    hx_post=f"/{app_name}/{step_id}_submit",
    hx_target=f"#{step_id}",
    enctype="multipart/form-data"
)

# File processing
form_data = await request.form()
uploaded_files = form_data.getlist("uploaded_files")
```

### 2. Polling Pattern
```python
# Polling pattern
return Div(
    result_card,
    progress_indicator,
    cls="polling-status no-chain-reaction",
    hx_get=f"/{app_name}/check_status",
    hx_trigger="load, every 2s",
    hx_target=f"#{step_id}",
    id=step_id
)
```

### 3. Terminal Pattern
```python
# Terminal pattern
return Div(
    result_card,
    download_button,
    cls="terminal-response no-chain-reaction",
    id=step_id
)
```

## Widget Testing Checklist

### 1. State Management
- [ ] State transitions work correctly
- [ ] Values persist between steps
- [ ] Revert functionality works
- [ ] Finalization locks state properly
- [ ] State updates trigger UI updates

### 2. UI Construction
- [ ] Using standard components
- [ ] Following template patterns
- [ ] Proper container structure
- [ ] Correct chain reactions
- [ ] Proper HTMX triggers

### 3. Error Handling
- [ ] Using standard error patterns
- [ ] Clear error messages
- [ ] Edge case handling
- [ ] Input validation
- [ ] Error recovery

### 4. Container Structure
- [ ] Correct hierarchy
- [ ] Proper HTMX triggers
- [ ] Consistent layout
- [ ] Chain reaction intact
- [ ] Proper widget containers

## Common Pitfalls

### 1. Direct State Manipulation
```python
# ❌ Broken Pattern
state = pip.read_state(pipeline_id)
state["widget_value"] = value
pip.write_state(pipeline_id, state)

# ✅ Correct Pattern
await pip.update_step_state(pipeline_id, step_id, value, steps)
```

### 2. Manual UI Construction
```python
# ❌ Broken Pattern
return Card(
    H3("Widget Title"),
    Form(
        Input(value=value),
        Button("Submit")
    )
)

# ✅ Correct Pattern
return Div(
    Card(
        H3(f"{step.show}"),
        Form(
            Input(value=value),
            Button("Submit", type="submit")
        )
    ),
    id=step_id
)
```

### 3. Inconsistent Container Structure
```python
# ❌ Broken Pattern
return Div(
    Card(...),
    id=step_id
)

# ✅ Correct Pattern
return Div(
    Card(...),
    Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
    id=step_id
)
```

## Recovery Process

### 1. Identify the Break
- Look for direct state manipulation
- Check for manual UI construction
- Verify container structure
- Check for missing chain reactions
- Verify state transitions

### 2. Apply the Fix
- Replace direct state updates with core methods
- Use standard rebuild patterns
- Restore container hierarchy
- Fix chain reactions
- Update state transitions

### 3. Verify the Recovery
- Check state transitions
- Validate UI structure
- Confirm workflow behavior
- Test revert functionality
- Verify error handling

## Prevention Guidelines

### 1. State Management
- Use core workflow methods
- Never manipulate state directly
- Maintain consistent state structure
- Use proper state transitions
- Handle finalization correctly

### 2. UI Construction
- Follow template patterns
- Use standard components
- Maintain consistent structure
- Keep container hierarchy
- Use proper HTMX triggers

### 3. Error Handling
- Use standard error patterns
- Provide clear error messages
- Handle edge cases gracefully
- Validate all inputs
- Use consistent error presentation

## Recovery Checklist

### 1. State Management
- [ ] Using core workflow methods
- [ ] No direct state manipulation
- [ ] Consistent state structure
- [ ] Proper state transitions
- [ ] Correct finalization

### 2. UI Construction
- [ ] Using standard components
- [ ] Following template patterns
- [ ] Proper container structure
- [ ] Correct chain reactions
- [ ] Proper HTMX triggers

### 3. Error Handling
- [ ] Using standard error patterns
- [ ] Clear error messages
- [ ] Edge case handling
- [ ] Input validation
- [ ] Error recovery

### 4. Container Structure
- [ ] Correct hierarchy
- [ ] Proper HTMX triggers
- [ ] Consistent layout
- [ ] Chain reaction intact
- [ ] Proper widget containers

## Implementation Steps

### 1. Widget Setup
1. Define widget configuration
2. Set unique APP_NAME
3. Set distinct DISPLAY_NAME
4. Configure widget options
5. Set up error handling

### 2. Core Implementation
1. Implement core methods
2. Handle state management
3. Construct UI elements
4. Handle form submission
5. Manage error cases

### 3. Testing and Validation
1. Test widget behavior
2. Verify state management
3. Check error handling
4. Test edge cases
5. Document implementation

## Advanced Patterns

### 1. Polling and Terminal Steps
```python
# Polling pattern
return Div(
    result_card,
    progress_indicator,
    cls="polling-status no-chain-reaction",
    hx_get=f"/{app_name}/check_status",
    hx_trigger="load, every 2s",
    hx_target=f"#{step_id}",
    id=step_id
)

# Terminal pattern
return Div(
    result_card,
    download_button,
    cls="terminal-response no-chain-reaction",
    id=step_id
)
```

### 2. Revert Control
```python
# Revert control pattern
return Div(
    pip.revert_control(
        step_id=step_id,
        app_name=app_name,
        message=f"{step.show}: {value}",
        steps=steps
    ),
    Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
    id=step_id
)
```

### 3. Message Queue
```python
# Message queue pattern
await self.message_queue.add(
    pip,
    message,
    verbatim=True,
    spaces_before=0,
    spaces_after=1
)
```

## Best Practices

### 1. Development
1. Start with placeholders
2. Add functionality incrementally
3. Test each phase
4. Maintain proper state
5. Keep LLM informed

### 2. Implementation
1. Follow template patterns
2. Use standard components
3. Maintain consistent structure
4. Handle errors properly
5. Test thoroughly

### 3. Deployment
1. Test configuration
2. Verify state management
3. Check error handling
4. Test edge cases
5. Document implementation

## Reference Examples

### 1. Basic Workflows
- [20_hello_workflow.py](mdc:pipulate/plugins/20_hello_workflow.py): Template
- [035_url_opener.py](mdc:pipulate/plugins/035_url_opener.py): URL handling

### 2. Complex Workflows
- [50_botify_export.py](mdc:pipulate/plugins/50_botify_export.py): Multi-step
- [60_widget_examples.py](mdc:pipulate/plugins/60_widget_examples.py): Widget patterns

Remember: Workflows are intentionally WET (Write Everything Twice) to allow maximum customization while maintaining consistent patterns. Follow the established patterns but feel free to adapt them to your specific needs.

## Implementation Pattern

### 1. Workflow Definition
```python
class Workflow:
    def __init__(self):
        self.steps = []
        self.state = {}
        self.current_step = 0
        self.is_complete = False
        self.error = None

    def add_step(self, step):
        """Add a step to the workflow."""
        self.steps.append(step)

    def execute(self):
        """Execute the workflow."""
        try:
            while self.current_step < len(self.steps):
                step = self.steps[self.current_step]
                step.execute(self.state)
                self.current_step += 1
            self.is_complete = True
        except Exception as e:
            self.error = str(e)
            raise
```

### 2. Step Implementation
```python
class Step:
    def __init__(self, name, handler):
        self.name = name
        self.handler = handler
        self.is_complete = False
        self.error = None

    def execute(self, state):
        """Execute the step."""
        try:
            self.handler(state)
            self.is_complete = True
        except Exception as e:
            self.error = str(e)
            raise
```

## Critical Patterns

### 1. State Management
- Track workflow state
- Track step state
- Update state efficiently
- Preserve state across steps
- Handle state transitions

### 2. Chain Reaction
- Propagate state changes
- Handle state dependencies
- Update dependent steps
- Preserve chain integrity
- Handle chain breaks

### 3. Error Handling
- Handle step errors
- Handle workflow errors
- Provide error recovery
- Preserve error state
- Support error reporting

### 4. Step Execution
- Execute steps in order
- Handle step dependencies
- Support parallel steps
- Handle step timeouts
- Support step retries

## Common Pitfalls
1. **State Management**: Don't lose state
2. **Chain Reaction**: Don't break the chain
3. **Error Handling**: Don't ignore errors
4. **Step Execution**: Don't execute out of order
5. **Dependencies**: Don't ignore dependencies
6. **Timeouts**: Don't forget timeouts
7. **Retries**: Don't forget retries
8. **Recovery**: Don't forget recovery

## Best Practices
1. **State Management**
   - Track all state
   - Update state efficiently
   - Preserve state
   - Handle transitions
   - Support rollback

2. **Chain Reaction**
   - Propagate changes
   - Handle dependencies
   - Update dependents
   - Preserve chain
   - Handle breaks

3. **Error Handling**
   - Handle all errors
   - Provide recovery
   - Preserve state
   - Support reporting
   - Handle timeouts

4. **Step Execution**
   - Execute in order
   - Handle dependencies
   - Support parallel
   - Handle timeouts
   - Support retries

## Related Patterns
- See: pattern-widget-implementation.mdc
- See: pattern-chain-reaction.mdc
- See: pattern-validation.mdc
- See: pattern-async-polling.mdc
- See: pattern-file-operations.mdc

## Step Anatomy and Phases

### Step Structure

Each step in a Pipulate workflow is modeled after a Jupyter Notebook cell, with two distinct parts:

1. **Visible Part** (`step_xx`): Builds the user interface for data collection
2. **Invisible Part** (`step_xx_submit`): Handles form submission and state management

### Step Phases

Each step goes through three distinct phases:

```python
if "finalized" in finalize_data and placeholder_value:
    # STEP STAGE: FINALIZED
    # - Workflow is locked
    # - Data is read-only
    # - Shows final state
elif placeholder_value and state.get("_revert_target") != step_id:
    # STEP STAGE: REVERT
    # - User has reverted to this step
    # - Previous data is preserved
    # - Allows modification
else:
    # STEP STAGE: DATA COLLECTION
    # - Initial data entry
    # - Form is active
    # - No previous data
```

### Chain Reaction Pattern

Steps are connected through a chain reaction pattern that enables automatic progression:

```python
return Div(
    Card(...),  # Current step content
    # This inner Div triggers loading of the next step
    Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
    id=step_id
)
```

Key points about chain reactions:
- Each step must include the next step's container
- The `hx_trigger="load"` attribute enables automatic progression
- This creates a "Run All Cells" experience similar to Jupyter Notebooks
- Chain reactions maintain the linear workflow model

### Step Definition

Steps are defined using a named tuple with specific fields:

```python
Step = namedtuple('Step', ['id', 'done', 'show', 'refill', 'transform'], defaults=(None,))
```

Where:
- `id`: Unique identifier for the step (e.g., 'step_01')
- `done`: Field name to store step data in state
- `show`: User-friendly name displayed in UI
- `refill`: Whether to preserve data on revert
- `transform`: Optional function to transform step data

### Best Practices

1. **State Management**:
   - Use the pipeline object for state management
   - Store step data in the `done` field
   - Use transforms for data processing

2. **UI Design**:
   - Keep the visible part focused on data collection
   - Use the submit part for state updates
   - Maintain consistent UI patterns

3. **Chain Reactions**:
   - Never remove `hx_trigger="load"`
   - Always include the next step's container
   - Preserve the linear progression model

4. **Error Handling**:
   - Validate data in the submit handler
   - Provide clear error messages
   - Handle edge cases gracefully

Remember: While the step structure may seem verbose, this WET (Write Everything Twice) approach allows for maximum customization while maintaining consistent patterns.

## Widget Implementation Patterns

### 1. Widget Categories
- **Input Widgets**: Text fields, text areas, dropdowns, checkboxes, radio buttons, switches, range selectors
- **Display Widgets**: Tables, markdown, mermaid diagrams, code syntax highlighting
- **Operation Widgets**: File uploads, API requests, data processing
- **Integration Widgets**: Browser interactions, search functionality

### 2. Widget State Management
```python
# Reading state
state = pip.read_state(pipeline_id)
step_data = pip.get_step_data(pipeline_id, step_id, {})

# Updating state
await pip.update_step_state(pipeline_id, step_id, value, steps)

# Finalizing state
await pip.finalize_workflow(pipeline_id)
return pip.rebuild(app_name, steps)
```

### 3. Widget UI Construction
```python
# Standard widget container structure
return Div(
    Card(
        H3(f"{step.show}"),
        Form(
            # Widget-specific input elements
            Button("Submit ▸", type="submit", cls="primary"),
            hx_post=f"/{app_name}/{step_id}_submit",
            hx_target=f"#{step_id}"
        )
    ),
    Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
    id=step_id
)
```

### 4. Widget Recovery Process
```python
# Revert control pattern
return Div(
    pip.revert_control(
        step_id=step_id,
        app_name=app_name,
        message=f"{step.show}: {value}",
        steps=steps
    ),
    Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
    id=step_id
)
```

## Widget Design Philosophy

### 1. Core Principles
- **Atomic Steps**: Each step should have a clear, focused purpose
- **State Preservation**: Maintain user inputs for reuse and review
- **Progressive Enhancement**: Start simple and evolve based on needs
- **Consistent UI**: Follow established patterns for visual consistency
- **Error Recovery**: Provide clear paths for error handling and recovery

### 2. Implementation Guidelines
1. **Start with Placeholders**
   - Use blank placeholder pattern for new widgets
   - Add functionality incrementally
   - Test each phase thoroughly

2. **State Management**
   - Never manage workflow state directly
   - Use core workflow methods for state transitions
   - Maintain widget state within workflow state
   - Preserve values when reverting

3. **UI Construction**
   - Follow template patterns for widget UI
   - Use standard components
   - Maintain consistent structure
   - Keep container hierarchy consistent
   - Use proper HTMX triggers

4. **Error Handling**
   - Use standard error patterns
   - Provide clear error messages
   - Handle edge cases gracefully
   - Validate all inputs
   - Use consistent error presentation

### 3. Common Widget Patterns

#### Text Input Widget
```python
async def step_01(self, request):
    pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
    step_id = "step_01"
    pipeline_id = db.get("pipeline_id", "unknown")
    
    # Get current value
    current_value = pip.get_step_data(pipeline_id, step_id, {}).get(step.done, "")
    
    # Return using standard container structure
    return Div(
        Card(
            H3(f"{step.show}"),
            Form(
                Input(value=current_value),
                Button("Submit ▸", type="submit", cls="primary")
            )
        ),
        id=step_id
    )
```

#### Dropdown Widget
```python
async def step_01(self, request):
    pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
    step_id = "step_01"
    pipeline_id = db.get("pipeline_id", "unknown")
    
    # Get options using core methods
    options = await self.get_options(pipeline_id)
    
    # Format options using standard patterns
    formatted_options = [await self.format_option(opt) for opt in options]
    
    # Return using standard container structure
    return Div(
        Card(
            H3(f"{step.show}"),
            Form(
                Select(*formatted_options),
                Button("Submit ▸", type="submit", cls="primary")
            )
        ),
        id=step_id
    )
```

### 4. Advanced Widget Patterns

#### File Upload Pattern
```python
# Form structure
Form(
    Input(
        type="file",
        name="uploaded_files",
        multiple="true",
        required="true",
        cls="contrast"
    ),
    Button("Upload Files ▸", type="submit", cls="primary"),
    hx_post=f"/{app_name}/{step_id}_submit",
    hx_target=f"#{step_id}",
    enctype="multipart/form-data"
)

# File processing
form_data = await request.form()
uploaded_files = form_data.getlist("uploaded_files")
```

#### Polling Pattern
```python
# Polling pattern
return Div(
    result_card,
    progress_indicator,
    cls="polling-status no-chain-reaction",
    hx_get=f"/{app_name}/check_status",
    hx_trigger="load, every 2s",
    hx_target=f"#{step_id}",
    id=step_id
)
```

#### Terminal Pattern
```python
# Terminal pattern
return Div(
    result_card,
    download_button,
    cls="terminal-response no-chain-reaction",
    id=step_id
)
```

## Widget Testing Checklist

### 1. State Management
- [ ] State transitions work correctly
- [ ] Values persist between steps
- [ ] Revert functionality works
- [ ] Finalization locks state properly
- [ ] State updates trigger UI updates

### 2. UI Construction
- [ ] Using standard components
- [ ] Following template patterns
- [ ] Proper container structure
- [ ] Correct chain reactions
- [ ] Proper HTMX triggers

### 3. Error Handling
- [ ] Using standard error patterns
- [ ] Clear error messages
- [ ] Edge case handling
- [ ] Input validation
- [ ] Error recovery

### 4. Container Structure
- [ ] Correct hierarchy
- [ ] Proper HTMX triggers
- [ ] Consistent layout
- [ ] Chain reaction intact
- [ ] Proper widget containers
