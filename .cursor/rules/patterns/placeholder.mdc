---
description: Use whenever working on Pipulate Workflow plugins
globs: 
alwaysApply: false
---
---
description: Pattern for creating and managing placeholder steps in workflow progression, including chain reaction mechanisms and state management
globs: ["pipulate/plugins/*.py"]
alwaysApply: false
---

# placeholder-step-pattern

## Overview
Placeholder steps are skeletal workflow steps that serve as preparation points for inserting fully-functional steps later. Like a `cat` command in a Unix pipeline or an empty Jupyter notebook cell, they maintain flow while providing space for future implementation.

## When to Use Placeholder Steps
- When planning a workflow's structure before implementing detailed functionality
- When creating a step that will be replaced with more complex widgets later (like a Jupyter cell TODO)
- When needing a "confirmation" or "review" step between functional steps (like `tee` in Unix pipelines)
- When creating a template for different widget types

## Implementation Pattern
To add a placeholder step to an existing workflow:

### 1. Add the Step Definition
```python
Step(
    id='step_XX',            # Use proper sequential numbering
    done='placeholder',      # Simple state field name
    show='Placeholder Step', # Descriptive UI text
    refill=True,             # Usually True for consistency
),
```

### 2. Create the GET Handler Method
```python
async def step_XX(self, request):
    """Handles GET request for placeholder step."""
    pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
    step_id = "step_XX"
    step_index = self.steps_indices[step_id]
    step = steps[step_index]
    next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'
    pipeline_id = db.get("pipeline_id", "unknown")
    state = pip.read_state(pipeline_id)
    
    # Simple form with just a proceed button
    return Div(
        Card(
            H4(f"{step.show}"),
            P("Click Proceed to continue to the next step."),
            Form(
                Button("Proceed", type="submit", cls="primary"),
                Button("Revert", type="button", cls="secondary",
                       hx_post=f"/{app_name}/handle_revert",
                       hx_vals=f'{{"step_id": "{step_id}"}}'),
                hx_post=f"/{app_name}/{step_id}_submit",
            ),
        ),
        # CRITICAL: Chain reaction to next step - DO NOT MODIFY OR REMOVE
        Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
        id=step_id
    )
```

### 3. Create the POST Handler Method
```python
async def step_XX_submit(self, request):
    """Process the submission for placeholder step."""
    pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
    step_id = "step_XX"
    step_index = self.steps_indices[step_id]
    step = steps[step_index]
    pipeline_id = db.get("pipeline_id", "unknown")
    next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'

    # Store minimal state data
    placeholder_value = "completed"
    state = pip.read_state(pipeline_id)
    state[step.done] = placeholder_value
    pip.write_state(pipeline_id, state)
    
    # Confirm completion and configure next step display
    await pip.update_step_state(pipeline_id, step_id, placeholder_value, steps)
    await self.message_queue.add(pip, f"{step.show} complete.", verbatim=True)
    
    # Return response with chain reaction to next step
    response = Div(
        Card(
            H4(f"{step.show} Complete"),
            P("Proceeding to next step..."),
        ),
        # CRITICAL: Chain reaction to next step - DO NOT MODIFY OR REMOVE
        Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
        id=step_id
    )
    return response
```

### 4. Add Suggestion for Step (Optional)
In the `get_suggestion` method, add a simple text for the placeholder:
```python
'step_XX': """Placeholder step - no user content needed.

This step serves as a placeholder for future functionality."""
```

## Critical Elements to Preserve
1. **Chain Reaction Pattern**: 
   ```python
   # CRITICAL - DO NOT MODIFY OR REMOVE
   Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load")
   ```
   - The `id=next_step_id` identifies the container for the next step
   - The `hx_get` attribute loads the next step's content
   - The `hx_trigger="load"` attribute is REQUIRED for automatic progression
   - NEVER remove `hx_trigger="load"` even if you think event bubbling would work
   - This explicit triggering pattern is the standard throughout the codebase

2. **Revert Button**: Always include for consistent user experience
3. **Step Numbering**: Maintain proper sequential numbering
4. **State Management**: Always store state even if minimal
5. **Message Queue Updates**: Always notify of step completion

## Common Implementation Pitfalls
- **SERIOUS ERROR**: Removing `hx_trigger="load"` from the chain reaction div will break progression
- **SERIOUS ERROR**: Using an empty div without the required attributes
- **SERIOUS ERROR**: Using event bubbling or implicit triggering instead of explicit triggers
- Using incorrect next_step_id calculation (especially for the last step)
- Forgetting to update steps_indices after adding new steps
- Not preserving the chain reaction pattern in both GET and POST handlers

## Placement Considerations
- **First Step**: If replacing the first step, ensure proper initialization
- **Middle Step**: Ensure proper next_step_id and previous step chain reaction
- **Last Step**: Properly handle transition to 'finalize' instead of next_step_id

## Example
See [60_widget_examples.py](mdc:pipulate/plugins/60_widget_examples.py) step_07 for a complete placeholder implementation.

## Upgrading Later
When ready to replace the placeholder with functional content:
1. Keep the same step_id and step definition
2. Add necessary form elements to collect data
3. Enhance the submit handler to process the collected data
4. Preserve the chain reaction pattern and revert functionality

# Placeholder Step Pattern for Pipulate Workflows

## Standard Workflow Step Structure
When implementing steps in Pipulate workflows, follow these patterns:

1. **Step Definition**: Use namedtuple `Step` with appropriate fields
   ```python
   Step(
       id='step_XX',          # HTML ID and URL path component
       done='field_name',     # State key indicating completion
       show='User-facing label',
       refill=True/False,     # Whether to refill on revert
       transform=lambda prev_val: f"Process {prev_val}"  # Optional
   )
   ```

2. **GET Handler Pattern** (`step_XX`):
   - Check finalization status
   - Check if step is complete but not being reverted
   - Use `wrap_with_inline_button` with "Next â–¸" label

3. **POST Handler Pattern** (`step_XX_submit`):
   - Validate input
   - Process data
   - Store with `pip.update_step_state`
   - Return navigation with `pip.create_step_navigation`

## Chain Reaction Mechanism
Always include the appropriate chain reaction elements when implementing steps:
- Include explicit `hx_trigger="load"` attributes in all step handlers
- Return appropriate navigation controls from submit handlers
- Use the standard `pip.create_step_navigation` helper

## Example
See implementation in [plugins/020_hello_workflow.py](mdc:pipulate/plugins/020_hello_workflow.py)

## Flow-Based Programming Context

Placeholder steps serve similar roles across different paradigms:

```bash
# Unix pipeline with placeholder (cat)
command1 | cat | command3  # cat maintains flow

# Jupyter notebook with placeholder
data = process1()           # Cell 1
# TODO: Add processing here # Cell 2 (placeholder)
result = process3(data)     # Cell 3

# Pipulate with placeholder
step_01 -> placeholder_step -> step_03
```

## Real-World Example: Browser Automation Integration

A particularly effective example of the placeholder pattern was demonstrated in the browser automation integration:

```python
# Original prompt that worked well:
"Splice in a blank placeholder to @550_browser_automation.py as Step 3, 
per pattern-placeholder.mdc without throwing off the pattern-chain-reaction.mdc. 
It's like going from @500_blank_workflow.py to @510_splice_workflow.py"
```

This example worked well because it:
1. Explicitly referenced the target file (@550_browser_automation.py)
2. Specified the exact step number (Step 3)
3. Referenced both required patterns (placeholder and chain-reaction)
4. Provided a clear analogy to existing workflow patterns
5. Maintained the critical chain reaction mechanism

The success of this prompt demonstrates how precise pattern references and clear analogies can lead to successful implementations that maintain workflow integrity.
