---
description: 
globs: 
alwaysApply: false
---
# Widget Error Handling Requirements

## Core Error Patterns

### Input Validation
```python
# Form validation
try:
    form = await request.form()
    value = form.get(step.done, "").strip()
except Exception as e:
    return P(
        f"Error processing form: {str(e)}", 
        style=pip.get_style("error"),
        role="alert"
    )

# Value validation
if not value:
    return P(
        "Error: Field is required", 
        style=pip.get_style("error"),
        role="alert"
    )

if len(value) > 1000:  # Example length limit
    return P(
        "Error: Text must be less than 1000 characters", 
        style=pip.get_style("error"),
        role="alert"
    )
```

### API Error Handling
```python
try:
    result = await api_call()
except Exception as e:
    return P(
        f"Error: {str(e)}", 
        style=pip.get_style("error"),
        role="alert"
    )
```

### File Operation Errors
```python
try:
    with open(filepath, 'w') as f:
        f.write(content)
except Exception as e:
    return P(
        f"Error saving file: {str(e)}", 
        style=pip.get_style("error"),
        role="alert"
    )
```

### State Recovery
```python
# Check state validity
if not pip.read_state(pipeline_id):
    return P(
        "Error: Invalid state", 
        style=pip.get_style("error"),
        role="alert"
    )

# Handle revert state
if state.get("_revert_target") == step_id:
    # Show input form
else:
    # Show completed state
```

## Implementation Examples

### Form with Validation
```python
async def handle_submit(self, request):
    try:
        # Get form data
        form = await request.form()
        value = form.get(step.done, "").strip()
        
        # Validate input
        if not value:
            return P(
                "Error: Field is required", 
                style=pip.get_style("error"),
                role="alert"
            )
        
        # Process data
        try:
            processed_value = process_data(value)
        except Exception as e:
            return P(
                f"Error processing data: {str(e)}", 
                style=pip.get_style("error"),
                role="alert"
            )
        
        # Save state
        try:
            await pip.update_step_state(pipeline_id, step_id, processed_value, steps)
        except Exception as e:
            return P(
                f"Error saving state: {str(e)}", 
                style=pip.get_style("error"),
                role="alert"
            )
        
        # Return success
        return Div(
            pip.revert_control(...),
            Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
            id=step_id
        )
    except Exception as e:
        return P(
            f"Unexpected error: {str(e)}", 
            style=pip.get_style("error"),
            role="alert"
        )
```

### API Call with Retry
```python
async def make_api_call(self, max_retries=3):
    for attempt in range(max_retries):
        try:
            return await api_call()
        except Exception as e:
            if attempt == max_retries - 1:
                raise
            await asyncio.sleep(1)  # Wait before retry
```

## Common Pitfalls
1. Missing error handling
2. Unclear error messages
3. No recovery options
4. Poor state validation
5. Missing retry logic
6. Inadequate logging
7. Poor user feedback
8. No error boundaries

## Testing Requirements
- Test invalid inputs
- Verify error messages
- Check recovery flows
- Test state corruption
- Validate retry logic
- Check error boundaries
- Test error display
- Verify logging

## Error Categories
- Input validation errors
- API communication errors
- File operation errors
- State management errors
- Network errors
- Permission errors
- Resource errors
- System errors

## Related Rules
- [Widget Implementation](mdc:widget-implementation.mdc)
- [State Management](mdc:state-management.mdc)
- [Accessibility](mdc:widget-accessibility.mdc)
