---
description: 
globs: 
alwaysApply: false
---
# WET Workflow Conventions: Emoji, Messaging, and User Experience Patterns

This document outlines the conventions and patterns for creating effective, user-friendly WET (Write Everything Twice) workflows in the Pipulate framework, based on innovations from the Botify Trifecta workflow.

## Emoji Usage Conventions

### Message Queue Emojis
Emojis serve as visual anchors for quick status recognition:

**Process Status Indicators:**
- üîç **Discovery/Analysis**: Finding optimal parameters, analyzing data
- üéØ **Success/Found**: Successful completion, optimal values found  
- ‚ö†Ô∏è **Warnings**: Non-critical issues, proceeding with caution
- ‚ùå **Errors**: Critical failures, operation stopped
- ‚úÖ **Completion**: Final success confirmation

**Data Type Indicators:**
- üìä **Analytics/Metrics**: Data analysis, performance metrics
- üîó **Links/Connections**: Link graphs, internal linking
- üìÑ **Content/Pages**: Page attributes, content analysis
- üîç **Search**: Search Console data, keyword analysis

**Action Indicators:**
- ‚¨áÔ∏è **Downloads**: File downloads, CSV exports
- üìÇ **File Operations**: Folder access, file management
- üêç **Code**: Python code generation, API debugging
- üîÑ **Processing**: Background operations, API calls

### Button Label Emojis
Reference: [535_botify_trifecta.py](mdc:pipulate/plugins/535_botify_trifecta.py) lines 180-190

```python
UI_CONSTANTS = {
    'BUTTON_LABELS': {
        'HIDE_SHOW_CODE': 'üêç Hide/Show Code',
        'VIEW_FOLDER': 'üìÇ View Folder', 
        'DOWNLOAD_CSV': '‚¨áÔ∏è Download CSV'
    }
}
```

## Message Queue Flow Patterns

### Progressive Feedback Pattern
Provide continuous feedback during long operations:

```python
# Initial status
await self.pipulate.message_queue.put(username, "üîç Finding optimal depth for Link Graph Edges...")

# Progress updates  
await self.pipulate.message_queue.put(username, f"Testing depth {depth}: {metric_value:,} edges")

# Final result
await self.pipulate.message_queue.put(username, f"üéØ Optimal depth: {optimal_depth} (for {final_count:,} edges).")
```

### Error Handling in Messages
Clear, actionable error messages with appropriate emojis:

```python
# Specific error context
await self.pipulate.message_queue.put(username, f"‚ùå API Error: {error_details}")

# Recovery suggestions
await self.pipulate.message_queue.put(username, "‚ö†Ô∏è Retrying with fallback parameters...")
```

## Template-Driven UI Patterns

### Dynamic User Messages
Templates should include user-facing explanations:

```python
QUERY_TEMPLATES = {
    'Template Name': {
        'user_message': 'This will download X data including Y and Z fields.',
        'button_label_suffix': 'Descriptive Action',
        # ... other config
    }
}
```

### Qualifier Configuration Pattern
For templates needing prerequisite queries to optimize parameters:

```python
'qualifier_config': {
    'enabled': True,
    'user_message_running': 'üîç Finding optimal parameters...',
    'user_message_found': 'üéØ Optimal value: {param_value} (for {metric_value:,} items).',
    'user_message_threshold_exceeded': '‚ö†Ô∏è Warning: Large dataset detected. Proceeding with caution.'
}
```

## Chain Reaction Pattern Conventions

### Step Progression
Each step follows the standard pattern for reliable progression:

```python
async def step_N_submit(self, request):
    # Process form data
    # Store results  
    # Provide user feedback
    
    # Return revert control + next step trigger
    return Div(
        self._create_revert_control(request, f"step_{N}"),
        Div(id=f"step_{N+1}", hx_get=f"/{self.APP_NAME}/step_{N+1}", hx_trigger="load")
    )
```

### Background Processing Pattern
For long-running operations, use Script tags with htmx.ajax:

```python
return Div(
    P("üîÑ Processing in background..."),
    Script(f"""
        htmx.ajax('POST', '/{self.APP_NAME}/step_N_process', {{
            values: {{'pipeline_id': '{pipeline_id}'}},
            target: '#step_N',
            swap: 'outerHTML'
        }});
    """)
)
```

## File Management Conventions

### Deterministic File Paths
Use consistent, predictable file naming:

```python
async def get_deterministic_filepath(self, username, project_name, analysis_slug, data_type=None):
    safe_project = re.sub(r'[^\w\-_]', '_', project_name)
    safe_analysis = re.sub(r'[^\w\-_]', '_', analysis_slug)
    
    if data_type:
        filename = f"{safe_project}_{safe_analysis}_{data_type}.csv"
    else:
        filename = f"{safe_project}_{safe_analysis}.csv"
    
    return f"downloads/{username}/{filename}"
```

### Cache-Aware Button Text
Buttons should reflect file availability:

```python
async def check_cached_file_for_button_text(self, username, project_name, analysis_slug, data_type):
    filepath = await self.get_deterministic_filepath(username, project_name, analysis_slug, data_type)
    if await self.check_file_exists(filepath):
        return f"‚¨áÔ∏è Download Cached {data_type.title()}"
    else:
        return f"üìä Generate {data_type.title()}"
```

## Code Generation Patterns

### Jupyter-Friendly Output
Generated code should be optimized for notebook debugging:

```python
def _generate_api_call_representations(self, method, url, headers, payload=None, step_context=None):
    # Generate both curl and Python requests versions
    # Include proper error handling
    # Add explanatory comments
    # Format for easy copying
```

### Syntax Highlighting Integration
When displaying code, ensure proper highlighting:

```python
Pre(
    Code(python_code, cls="language-python"),
    style="max-height: 400px; overflow-y: auto;"
)
```

## Error Handling Conventions

### Graceful Degradation
Always provide fallback behavior:

```python
try:
    optimal_value = await self._execute_qualifier_logic(...)
except Exception as e:
    await self.pipulate.message_queue.put(username, f"‚ö†Ô∏è Qualifier failed: {str(e)}. Using default value.")
    optimal_value = default_value
```

### User-Friendly Error Messages
Transform technical errors into actionable feedback:

```python
if "404" in str(error):
    message = "‚ùå Project not found. Please check your project URL."
elif "401" in str(error):
    message = "‚ùå Authentication failed. Please check your API token."
else:
    message = f"‚ùå Unexpected error: {str(error)}"
```

## State Management Patterns

### Consistent State Structure
Use predictable state keys across workflows:

```python
state_update = {
    'username': username,
    'project_name': project_name,
    'analysis_slug': analysis_slug,
    'template_config': template_config,
    'dynamic_parameters': dynamic_params
}
```

### Template Configuration Storage
Store template choices for later use:

```python
await self.pipulate.db.set_state(
    pipeline_id, 
    'template_config', 
    {
        'crawl_template': selected_template,
        'gsc_template': 'GSC Performance'
    }
)
```

## CSS Styling Hierarchy and Best Practices

### Philosophy: Layered Styling Approach
WET workflows should follow a strict hierarchy for CSS styling to ensure consistency, maintainability, and performance. This approach prevents style conflicts and makes global design changes manageable.

### CSS Styling Hierarchy (Priority Order)

#### 1. First Priority: Standard PicoCSS Classes
**Always favor built-in PicoCSS classes** from `pipulate/static/pico.css`:

```python
# ‚úÖ PREFERRED - Use PicoCSS classes
Button("Submit", cls="secondary")
Div(content, cls="container")
Article(content, cls="card")
Input(type="text", cls="form-control")
```

**Common PicoCSS Classes to Use:**
- Layout: `.container`, `.grid`, `.overflow-auto`
- Typography: `.text-secondary`, `.text-muted`, `.font-bold`
- Buttons: `.secondary`, `.contrast`, `.outline`
- Forms: Standard form styling is automatic
- Colors: Use semantic color classes when available

#### 2. Second Priority: Standard Pipulate Styles
**Use established Pipulate styles** from `pipulate/static/styles.css`:

```python
# ‚úÖ GOOD - Use Pipulate utility classes
Div(content, cls="text-secondary")
P(text, cls="text-muted")
Div(content, cls="mt-4 mb-2")
Code(code_text, cls="font-code")
```

**Common Pipulate Classes to Use:**
- Text utilities: `.text-secondary`, `.text-muted`, `.text-accent`
- Spacing: `.mt-4`, `.mb-2`, `.p-2`
- Layout: `.w-full`, `.flex`, `.items-center`
- Typography: `.font-code`, `.text-sm`

#### 3. Last Resort: Custom Inline Styles
**Only use custom styles when necessary**, and centralize them using UI_CONSTANTS:

```python
# ‚úÖ ACCEPTABLE - Centralized custom styles
style=f'color: {self.UI_CONSTANTS["COLORS"]["HEADER_TEXT"]}; '
      f'background-color: {self.UI_CONSTANTS["BACKGROUNDS"]["LIGHT_GRAY"]};'

# ‚ùå AVOID - Scattered hardcoded styles
style="color: #2c3e50; background-color: #f1f5f9;"
```

### UI Constants Pattern for Custom Styles

#### Centralized Constants Structure
When custom styles are necessary, centralize them at the top of the workflow class:

```python
class MyWorkflow:
    # UI Constants - Centralized control for global appearance
    UI_CONSTANTS = {
        'COLORS': {
            'HEADER_TEXT': '#2c3e50',           # Dark blue-gray for headers
            'BODY_TEXT': '#5a6c7d',             # Medium blue-gray for body text
            'SUBHEADER_TEXT': '#495057',        # Slightly darker for subheaders
            'ACCENT_BLUE': '#007bff',           # Blue accent for tips and highlights
            'ACCENT_INFO': '#0066cc',           # Info blue for special sections
            'SUCCESS_GREEN': '#28a745',         # Green for success indicators
        },
        'BACKGROUNDS': {
            'LIGHT_GRAY': '#f1f5f9',           # Soft gray for general sections
            'LIGHT_BLUE': '#f0f8ff',           # Light blue for blue-themed sections
            'INFO_BLUE': '#e7f3ff',            # Very light blue for info boxes
        },
        'SPACING': {
            'SECTION_PADDING': '0.75rem',       # Standard section padding
            'BORDER_RADIUS': '4px',             # Standard border radius
            'BORDER_WIDTH': '3px',              # Standard border width for accents
            'MARGIN_BOTTOM': '1rem',            # Standard bottom margin
            'SMALL_MARGIN': '0.25rem 0',       # Small vertical margins
            'TINY_MARGIN': '0.5rem',            # Tiny margins
        },
        'TYPOGRAPHY': {
            'SMALL_TEXT': '0.9rem',             # Small text size
            'TINY_TEXT': '0.85rem',             # Tiny text size
            'FONT_WEIGHT_MEDIUM': '500',        # Medium font weight
        }
    }
```

#### Usage Patterns for UI Constants
Reference constants using f-string formatting for dynamic style generation:

```python
# Template information box
Div(
    P(f"Template: {template_name}", 
      style=f'margin: {self.UI_CONSTANTS["SPACING"]["SMALL_MARGIN"]}; '
            f'font-weight: {self.UI_CONSTANTS["TYPOGRAPHY"]["FONT_WEIGHT_MEDIUM"]}; '
            f'color: {self.UI_CONSTANTS["COLORS"]["HEADER_TEXT"]};'),
    style=f'padding: {self.UI_CONSTANTS["SPACING"]["SECTION_PADDING"]}; '
          f'background-color: {self.UI_CONSTANTS["BACKGROUNDS"]["LIGHT_GRAY"]}; '
          f'border-left: {self.UI_CONSTANTS["SPACING"]["BORDER_WIDTH"]} solid {self.UI_CONSTANTS["COLORS"]["SUCCESS_GREEN"]}; '
          f'border-radius: {self.UI_CONSTANTS["SPACING"]["BORDER_RADIUS"]};'
)
```

### Style Migration Strategy

#### Preparation for Unification
Centralized UI constants serve as preparation for eventual extraction and unification with `styles.css`:

1. **Identify Common Patterns**: Track which custom styles are used across multiple workflows
2. **Standardize Values**: Use consistent color palettes and spacing scales
3. **Document Usage**: Comment on why custom styles are needed vs. standard classes
4. **Plan Extraction**: Prepare for moving common patterns to global stylesheets

#### Refactoring Guidelines
When updating existing workflows:

```python
# ‚ùå BEFORE - Scattered hardcoded styles
P("Header", style="color: #2c3e50; font-weight: 500;")
Div(content, style="background-color: #f1f5f9; padding: 0.75rem;")

# ‚úÖ AFTER - Centralized constants
P("Header", style=f'color: {self.UI_CONSTANTS["COLORS"]["HEADER_TEXT"]}; '
                  f'font-weight: {self.UI_CONSTANTS["TYPOGRAPHY"]["FONT_WEIGHT_MEDIUM"]};')
Div(content, style=f'background-color: {self.UI_CONSTANTS["BACKGROUNDS"]["LIGHT_GRAY"]}; '
                   f'padding: {self.UI_CONSTANTS["SPACING"]["SECTION_PADDING"]};')
```

### Benefits of This Hierarchy

#### Consistency and Performance
- **PicoCSS First**: Leverages optimized, tested styles with consistent behavior
- **Pipulate Second**: Uses established patterns that work across the application
- **Custom Last**: Minimizes custom CSS that could conflict or cause maintenance issues

#### Maintainability
- **Global Changes**: Modify PicoCSS/Pipulate styles to affect all workflows
- **Workflow-Specific**: Use UI constants for workflow-specific customizations
- **Easy Migration**: Centralized constants make it easy to extract common patterns

#### Design System Evolution
- **Foundation**: PicoCSS provides the design system foundation
- **Extensions**: Pipulate styles extend the system for specific needs
- **Customizations**: UI constants handle edge cases while preparing for unification

### Standard Color Categories
- **HEADER_TEXT**: Primary headers and important labels
- **BODY_TEXT**: Secondary text and descriptions
- **SUBHEADER_TEXT**: Section subheadings and intermediate hierarchy
- **ACCENT_BLUE**: Interactive elements and highlights
- **ACCENT_INFO**: Special information and tips
- **SUCCESS_GREEN**: Success states and positive indicators

### Standard Background Categories
- **LIGHT_GRAY**: General information sections
- **LIGHT_BLUE**: Blue-themed sections and highlights
- **INFO_BLUE**: Information boxes and tips

### Standard Spacing Categories
- **SECTION_PADDING**: Consistent padding for content sections
- **BORDER_RADIUS**: Uniform corner rounding
- **BORDER_WIDTH**: Standard accent border thickness
- **MARGIN_BOTTOM**: Consistent vertical spacing between sections
- **SMALL_MARGIN**: Tight spacing for related elements
- **TINY_MARGIN**: Minimal spacing for fine adjustments

## Template Assembly and Marker System

### Philosophy: Deterministic Template Processing
The WET workflow system uses **full-line markers** and **split/join methodology** instead of complex regex patterns for reliable, deterministic template assembly. This approach ensures helper scripts work predictably across different workflow templates.

### Atomic Transplantation Markers
**Reference**: [15_atomic_transplantation_system.mdc](mdc:15_atomic_transplantation_system.mdc)

The atomic transplantation system enables deterministic code transplantation between workflows using full-line markers and simple string operations. This system complements the template assembly patterns by providing a way to mark and transplant complete workflow sections.

#### Standard Atomic Transplantation Markers
For workflows that contain reusable atomic units (complete multi-step sections):

```python
# --- START_WORKFLOW_SECTION: steps_01_04_botify_data_collection ---
# This section handles the complete Botify data collection workflow (steps 1-4):
# - Step 1: Botify Project URL input and validation
# - Step 2: Crawl Analysis selection and download
# - Step 3: Web Logs availability check and download
# - Step 4: Search Console data check and download
# This is an atomic unit that should be transplanted together.

# --- SECTION_STEP_DEFINITION ---
steps = [
    Step(id='step_01', done='botify_project', show='Botify Project URL', refill=True),
    Step(id='step_02', done='analysis_data', show='Crawl Analysis', refill=False),
    Step(id='step_03', done='logs_check', show='Web Logs Check', refill=False),
    Step(id='step_04', done='gsc_check', show='Search Console Check', refill=False),
]
# --- END_SECTION_STEP_DEFINITION ---

# ... other class methods ...

# --- SECTION_STEP_METHODS ---
async def step_01(self, request):
    # Step 1 implementation
    pass

async def step_01_submit(self, request):
    # Step 1 submission handler
    pass

# ... more step methods ...

async def step_04_submit(self, request):
    # Final step submission handler
    pass
# --- END_SECTION_STEP_METHODS ---

# ... helper methods outside the atomic unit ...

# --- END_WORKFLOW_SECTION ---
```

#### Atomic Transplantation Marker Definitions
- `START_WORKFLOW_SECTION`: Beginning of atomic unit with descriptive documentation
- `SECTION_STEP_DEFINITION`: Step definitions list boundaries
- `END_SECTION_STEP_DEFINITION`: End of step definitions
- `SECTION_STEP_METHODS`: Step method implementations boundaries
- `END_SECTION_STEP_METHODS`: End of step methods
- `END_WORKFLOW_SECTION`: End of atomic unit

#### When to Use Atomic Transplantation Markers
- **Complex Multi-Step Workflows**: When you have 3+ related steps that form a logical unit
- **Reusable Workflow Components**: API integration patterns, data collection sequences
- **Cross-Workflow Sharing**: When similar functionality needs to be replicated across workflows
- **Maintenance Efficiency**: When bulk updates need to be applied to similar workflow sections

#### Atomic Transplantation Tool Usage
**Tool**: `pipulate/helpers/cleanup/atomic_transplantation_marker_tool.py`

```bash
# Add complete atomic markers to a workflow
python helpers/cleanup/atomic_transplantation_marker_tool.py add-markers plugins/my_workflow.py

# Complete Parameter Buster workflow markers (example)
python helpers/cleanup/atomic_transplantation_marker_tool.py complete-parameter-buster

# Custom marker insertion
python helpers/cleanup/atomic_transplantation_marker_tool.py insert-before "async def step_01" "# --- MARKER ---" file.py
```

### Core Template Markers
Every workflow template must include these markers for automated processing:

#### Steps List Insertion Point
```python
# In self.steps definition:
self.steps = [
    Step(id='step_01', done='data_01', show='Step 1', refill=False),
    # --- STEPS_LIST_INSERTION_POINT --- 
    Step(id='finalize', done='finalized', show='Finalize Workflow', refill=False) 
]
```

**Purpose**: @splice_workflow_step.py inserts new Step definitions before this marker.

#### Step Methods Insertion Point
```python
# At the end of the class, before closing:
    async def existing_step_method(self, request):
        # ... existing method ...
        pass

    # --- STEP_METHODS_INSERTION_POINT ---
```

**Purpose**: @splice_workflow_step.py inserts new step method templates before this marker.

### Template Assembly Patterns

#### 1. Class-Level Replacements
@create_workflow.py uses deterministic string replacement for class attributes:

```python
# Original template values (detected automatically):
class BlankPlaceholder:
    APP_NAME = 'placeholder'
    DISPLAY_NAME = 'Blank Placeholder' 
    ENDPOINT_MESSAGE = 'Welcome message...'
    TRAINING_PROMPT = 'Training prompt...'

# Replaced with user-provided values:
class MyCustomWorkflow:
    APP_NAME = 'my_custom'
    DISPLAY_NAME = 'My Custom Workflow'
    ENDPOINT_MESSAGE = 'Custom welcome message...'
    TRAINING_PROMPT = 'Custom training prompt...'
```

#### 2. Steps List Processing
The helper scripts use **line-by-line processing** instead of regex for reliability:

```python
def find_steps_list_definition(content):
    # Pattern 1: Direct assignment `self.steps = [...]`
    # Pattern 2: Indirect assignment `self.steps = variable_name` then `variable_name = [...]`
    # Returns: (prefix, content, suffix, full_block) for precise replacement
```

#### 3. Method Template Generation
New step methods follow standardized templates:

```python
def generate_step_method_templates(step_id_str, step_done_key, step_show_name):
    # Generates both GET and POST handlers
    # Uses consistent indentation and patterns
    # Includes proper HTMX chain reaction triggers
```

### Template Selection System

#### Available Templates
Reference: @create_workflow.py lines 35-42

```python
TEMPLATE_MAP = {
    "blank": "710_blank_placeholder.py",      # Minimal single-step template
    "trifecta": "535_botify_trifecta.py",     # Complex multi-export template
    # Future templates can be added here
}
```

#### Template Requirements
Any workflow can become a template by including:

1. **Required Markers**: Both insertion point markers
2. **Standard Attributes**: APP_NAME, DISPLAY_NAME, ENDPOINT_MESSAGE, TRAINING_PROMPT
3. **UI Constants**: Centralized styling constants for consistent appearance
4. **Consistent Patterns**: Standard step definitions and method signatures
5. **Documentation**: Clear docstrings explaining the workflow's purpose

### Helper Script Usage Patterns

#### Creating New Workflows
```bash
# From any location (script finds project root automatically):
python create_workflow.py 035_kungfu_workflow.py KungfuWorkflow kungfu "Kung Fu Download" "Welcome message" "Training prompt"

# Using different templates:
python create_workflow.py 036_custom_botify.py MyBotify my_botify "Custom Flow" "Welcome" "Training" --template trifecta
```

#### Adding Steps to Existing Workflows
```bash
# Insert at bottom (before finalize step - default):
python splice_workflow_step.py 035_kungfu_workflow.py

# Insert at top (becomes new first step):
python splice_workflow_step.py 035_kungfu_workflow.py --position top
```

### Marker Placement Best Practices

The WET workflow system uses two complementary marker systems:
1. **Template Assembly Markers**: For workflow creation and step insertion
2. **Atomic Transplantation Markers**: For reusable workflow section transplantation

#### Template Assembly Markers

##### Steps List Marker
- **Always** place immediately before the finalize step
- **Never** place inside conditional logic or loops
- **Maintain** consistent indentation with surrounding Step definitions

```python
# ‚úÖ CORRECT - Clear insertion point
self.steps = [
    Step(id='step_01', done='data_01', show='Step 1', refill=False),
    Step(id='step_02', done='data_02', show='Step 2', refill=False),
    # --- STEPS_LIST_INSERTION_POINT --- 
    Step(id='finalize', done='finalized', show='Finalize Workflow', refill=False) 
]

# ‚ùå INCORRECT - Marker inside conditional
if some_condition:
    # --- STEPS_LIST_INSERTION_POINT ---
```

##### Methods Marker
- **Always** place at class level (not inside methods)
- **Position** after all existing step methods
- **Maintain** consistent indentation (4 spaces for class members)

```python
# ‚úÖ CORRECT - At class level, proper indentation
class MyWorkflow:
    async def step_01(self, request):
        pass
    
    async def step_01_submit(self, request):
        pass
    
    # --- STEP_METHODS_INSERTION_POINT ---

# ‚ùå INCORRECT - Inside method or wrong indentation
    async def step_01(self, request):
        # --- STEP_METHODS_INSERTION_POINT ---  # Wrong location
        pass
```

#### Atomic Transplantation Markers

##### Workflow Section Markers
- **Use descriptive section names** that clearly identify the atomic unit
- **Include comprehensive documentation** explaining what the section does
- **Mark complete, self-contained workflow sections** (typically 3+ related steps)

```python
# ‚úÖ CORRECT - Complete atomic unit with clear boundaries
# --- START_WORKFLOW_SECTION: botify_data_collection ---
# This section handles the complete Botify data collection workflow:
# - Step 1: Project URL input and validation
# - Step 2: Analysis selection and download
# - Step 3: Web logs check and download
# This is an atomic unit that should be transplanted together.

# --- SECTION_STEP_DEFINITION ---
steps = [
    Step(id='step_01', done='botify_project', show='Botify Project URL', refill=True),
    Step(id='step_02', done='analysis_data', show='Crawl Analysis', refill=False),
    Step(id='step_03', done='logs_check', show='Web Logs Check', refill=False),
]
# --- END_SECTION_STEP_DEFINITION ---

# --- SECTION_STEP_METHODS ---
async def step_01(self, request):
    # Implementation
    pass

async def step_01_submit(self, request):
    # Implementation
    pass

async def step_02(self, request):
    # Implementation
    pass

async def step_02_submit(self, request):
    # Implementation
    pass
# --- END_SECTION_STEP_METHODS ---

# --- END_WORKFLOW_SECTION ---

# ‚ùå INCORRECT - Incomplete atomic unit
# --- START_WORKFLOW_SECTION: incomplete_section ---
async def step_01(self, request):
    pass
# Missing step definitions, missing end markers
```

##### Marker Hierarchy and Nesting
- **Atomic transplantation markers** can contain **template assembly markers**
- **Never nest** atomic transplantation sections within each other
- **Maintain clear boundaries** between different atomic units

```python
# ‚úÖ CORRECT - Atomic markers containing template markers
# --- START_WORKFLOW_SECTION: api_integration ---
# --- SECTION_STEP_DEFINITION ---
steps = [
    Step(id='step_01', done='api_setup', show='API Setup', refill=False),
    # --- STEPS_LIST_INSERTION_POINT ---  # Template marker inside atomic section
    Step(id='finalize', done='finalized', show='Finalize', refill=False)
]
# --- END_SECTION_STEP_DEFINITION ---

# --- SECTION_STEP_METHODS ---
async def step_01(self, request):
    pass

# --- STEP_METHODS_INSERTION_POINT ---  # Template marker inside atomic section
# --- END_SECTION_STEP_METHODS ---
# --- END_WORKFLOW_SECTION ---
```

#### Marker Selection Guidelines

##### Use Template Assembly Markers When:
- Creating new workflows from templates
- Adding individual steps to existing workflows
- Building simple, linear workflows
- Working with single-purpose workflows

##### Use Atomic Transplantation Markers When:
- Creating reusable multi-step workflow components
- Building complex workflows with distinct functional sections
- Planning to share workflow patterns across multiple implementations
- Working with API integration patterns that will be reused

##### Use Both Systems When:
- Building complex workflows that serve as templates for others
- Creating comprehensive workflow libraries
- Developing workflows with both reusable sections and extensible step lists
- Building enterprise-grade workflow systems

### Template Evolution Strategy

#### Making Any Workflow a Template
1. **Add Required Markers**: Insert both template assembly insertion point markers
2. **Add UI Constants**: Define centralized styling constants for consistent appearance
3. **Standardize Attributes**: Ensure all required class attributes are present (APP_NAME, DISPLAY_NAME, etc.)
4. **Document Patterns**: Add clear docstrings explaining the workflow's approach
5. **Test Assembly**: Verify the workflow works with helper scripts
6. **Register Template**: Add to TEMPLATE_MAP in create_workflow.py

#### Making Workflows Atomic Transplantation Ready
1. **Identify Reusable Sections**: Look for 3+ related steps that form logical units
2. **Add Atomic Markers**: Use the atomic transplantation marker tool to mark sections
3. **Document Atomic Units**: Include comprehensive comments explaining what each section does
4. **Test Transplantation**: Verify sections can be extracted and transplanted successfully
5. **Maintain Boundaries**: Ensure atomic units are self-contained and don't have external dependencies

#### Template Inheritance Patterns
Complex workflows can serve as templates for similar use cases:

- **API Integration Templates**: Based on Botify Trifecta pattern with atomic data collection sections
- **File Processing Templates**: Based on upload/download workflows with reusable file handling sections
- **Multi-Step Forms**: Based on data collection patterns with atomic form progression sections
- **Background Processing**: Based on long-running operation patterns with atomic processing sections

#### Hybrid Workflow Development
Combine both marker systems for maximum flexibility:

```python
class HybridWorkflow:
    # --- START_WORKFLOW_SECTION: core_data_collection ---
    # Core data collection that can be transplanted to other workflows
    
    # --- SECTION_STEP_DEFINITION ---
    steps = [
        Step(id='step_01', done='data_source', show='Data Source', refill=True),
        Step(id='step_02', done='data_fetch', show='Fetch Data', refill=False),
        # --- STEPS_LIST_INSERTION_POINT ---  # Allow additional steps to be inserted
        Step(id='finalize', done='finalized', show='Finalize', refill=False)
    ]
    # --- END_SECTION_STEP_DEFINITION ---
    
    # --- SECTION_STEP_METHODS ---
    async def step_01(self, request):
        # Core implementation
        pass
    
    async def step_02(self, request):
        # Core implementation  
        pass
    
    # --- STEP_METHODS_INSERTION_POINT ---  # Allow additional methods to be inserted
    # --- END_SECTION_STEP_METHODS ---
    
    # --- END_WORKFLOW_SECTION ---
    
    # Additional workflow-specific methods outside the atomic unit
    async def custom_helper_method(self, request):
        pass
```

### Why This Approach Works

#### Advantages of Full-Line Markers
- **Predictable**: No regex edge cases or escaping issues
- **Debuggable**: Easy to see exactly where insertions will occur
- **Maintainable**: Simple string operations instead of complex pattern matching
- **Reliable**: Works consistently across different code styles and formatting
- **Tool-Friendly**: Both AI and custom tools can work with these markers effectively

#### Split/Join Methodology Benefits
- **Preserves Formatting**: Maintains original indentation and style
- **Handles Edge Cases**: Works with various Python syntax patterns
- **Easy to Debug**: Can inspect intermediate steps in processing
- **Extensible**: Easy to add new processing steps without breaking existing logic
- **Deterministic**: Same input always produces same output

#### Complementary System Benefits
- **Template Assembly**: Enables rapid workflow creation and step addition
- **Atomic Transplantation**: Enables reusable component sharing across workflows
- **Combined Power**: Workflows can be both templates and sources of atomic components
- **Maintenance Efficiency**: Bulk updates can be applied to similar patterns across multiple workflows

#### Real-World Impact
- **Token Conservation**: Reduces AI token usage on routine tasks
- **Development Speed**: Faster workflow creation and modification
- **Code Consistency**: Standardized patterns across all workflows
- **Maintenance Reduction**: Changes to atomic units propagate across workflows
- **Knowledge Sharing**: Successful patterns become reusable components

This dual marker system ensures that WET workflows can serve multiple purposes: as templates for new workflow creation, as sources of reusable atomic components, and as maintainable, extensible systems that preserve the explicit, debuggable nature that makes WET patterns effective for complex data processing pipelines.

## Implementation Guidelines

### When to Apply These Conventions
- **New WET workflows**: Apply all conventions from the start, including UI constants
- **Existing workflows**: Gradually adopt conventions during maintenance, prioritizing UI constants for consistency
- **Message queue updates**: Prioritize emoji consistency for better UX
- **Template systems**: Implement dynamic user messages and qualifier patterns
- **Style updates**: Use centralized constants to make global appearance changes

### Key Benefits
- **Visual consistency**: Users can quickly scan and understand status
- **Reduced cognitive load**: Emojis provide instant context
- **Better error recovery**: Clear messaging helps users troubleshoot
- **Maintainable code**: Consistent patterns reduce development time
- **Easy customization**: Centralized constants enable quick global style changes
- **Design system**: Creates cohesive visual language across all workflows

These conventions ensure consistent user experience across all WET workflows while maintaining the explicit, debuggable nature that makes WET patterns effective for complex data processing pipelines.
