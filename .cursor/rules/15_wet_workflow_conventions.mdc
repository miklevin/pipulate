---
description: 
globs: 
alwaysApply: false
---
# WET Workflow Conventions: Emoji, Messaging, and User Experience Patterns

This document outlines the conventions and patterns for creating effective, user-friendly WET (Write Everything Twice) workflows in the Pipulate framework, based on innovations from the Botify Trifecta workflow.

## Emoji Usage Conventions

### Message Queue Emojis
Emojis serve as visual anchors for quick status recognition:

**Process Status Indicators:**
- üîç **Discovery/Analysis**: Finding optimal parameters, analyzing data
- üéØ **Success/Found**: Successful completion, optimal values found  
- ‚ö†Ô∏è **Warnings**: Non-critical issues, proceeding with caution
- ‚ùå **Errors**: Critical failures, operation stopped
- ‚úÖ **Completion**: Final success confirmation

**Data Type Indicators:**
- üìä **Analytics/Metrics**: Data analysis, performance metrics
- üîó **Links/Connections**: Link graphs, internal linking
- üìÑ **Content/Pages**: Page attributes, content analysis
- üîç **Search**: Search Console data, keyword analysis

**Action Indicators:**
- ‚¨áÔ∏è **Downloads**: File downloads, CSV exports
- üìÇ **File Operations**: Folder access, file management
- üêç **Code**: Python code generation, API debugging
- üîÑ **Processing**: Background operations, API calls

### Button Label Emojis
Reference: [535_botify_trifecta.py](mdc:pipulate/plugins/535_botify_trifecta.py) lines 180-190

```python
UI_CONSTANTS = {
    'BUTTON_LABELS': {
        'HIDE_SHOW_CODE': 'üêç Hide/Show Code',
        'VIEW_FOLDER': 'üìÇ View Folder', 
        'DOWNLOAD_CSV': '‚¨áÔ∏è Download CSV'
    }
}
```

## Message Queue Flow Patterns

### Progressive Feedback Pattern
Provide continuous feedback during long operations:

```python
# Initial status
await self.pipulate.message_queue.put(username, "üîç Finding optimal depth for Link Graph Edges...")

# Progress updates  
await self.pipulate.message_queue.put(username, f"Testing depth {depth}: {metric_value:,} edges")

# Final result
await self.pipulate.message_queue.put(username, f"üéØ Optimal depth: {optimal_depth} (for {final_count:,} edges).")
```

### Error Handling in Messages
Clear, actionable error messages with appropriate emojis:

```python
# Specific error context
await self.pipulate.message_queue.put(username, f"‚ùå API Error: {error_details}")

# Recovery suggestions
await self.pipulate.message_queue.put(username, "‚ö†Ô∏è Retrying with fallback parameters...")
```

## Template-Driven UI Patterns

### Dynamic User Messages
Templates should include user-facing explanations:

```python
QUERY_TEMPLATES = {
    'Template Name': {
        'user_message': 'This will download X data including Y and Z fields.',
        'button_label_suffix': 'Descriptive Action',
        # ... other config
    }
}
```

### Qualifier Configuration Pattern
For templates needing prerequisite queries to optimize parameters:

```python
'qualifier_config': {
    'enabled': True,
    'user_message_running': 'üîç Finding optimal parameters...',
    'user_message_found': 'üéØ Optimal value: {param_value} (for {metric_value:,} items).',
    'user_message_threshold_exceeded': '‚ö†Ô∏è Warning: Large dataset detected. Proceeding with caution.'
}
```

## Chain Reaction Pattern Conventions

### Step Progression
Each step follows the standard pattern for reliable progression:

```python
async def step_N_submit(self, request):
    # Process form data
    # Store results  
    # Provide user feedback
    
    # Return revert control + next step trigger
    return Div(
        self._create_revert_control(request, f"step_{N}"),
        Div(id=f"step_{N+1}", hx_get=f"/{self.APP_NAME}/step_{N+1}", hx_trigger="load")
    )
```

### Background Processing Pattern
For long-running operations, use Script tags with htmx.ajax:

```python
return Div(
    P("üîÑ Processing in background..."),
    Script(f"""
        htmx.ajax('POST', '/{self.APP_NAME}/step_N_process', {{
            values: {{'pipeline_id': '{pipeline_id}'}},
            target: '#step_N',
            swap: 'outerHTML'
        }});
    """)
)
```

## File Management Conventions

### Deterministic File Paths
Use consistent, predictable file naming:

```python
async def get_deterministic_filepath(self, username, project_name, analysis_slug, data_type=None):
    safe_project = re.sub(r'[^\w\-_]', '_', project_name)
    safe_analysis = re.sub(r'[^\w\-_]', '_', analysis_slug)
    
    if data_type:
        filename = f"{safe_project}_{safe_analysis}_{data_type}.csv"
    else:
        filename = f"{safe_project}_{safe_analysis}.csv"
    
    return f"downloads/{username}/{filename}"
```

### Cache-Aware Button Text
Buttons should reflect file availability:

```python
async def check_cached_file_for_button_text(self, username, project_name, analysis_slug, data_type):
    filepath = await self.get_deterministic_filepath(username, project_name, analysis_slug, data_type)
    if await self.check_file_exists(filepath):
        return f"‚¨áÔ∏è Download Cached {data_type.title()}"
    else:
        return f"üìä Generate {data_type.title()}"
```

## Code Generation Patterns

### Jupyter-Friendly Output
Generated code should be optimized for notebook debugging:

```python
def _generate_api_call_representations(self, method, url, headers, payload=None, step_context=None):
    # Generate both curl and Python requests versions
    # Include proper error handling
    # Add explanatory comments
    # Format for easy copying
```

### Syntax Highlighting Integration
When displaying code, ensure proper highlighting:

```python
Pre(
    Code(python_code, cls="language-python"),
    style="max-height: 400px; overflow-y: auto;"
)
```

## Error Handling Conventions

### Graceful Degradation
Always provide fallback behavior:

```python
try:
    optimal_value = await self._execute_qualifier_logic(...)
except Exception as e:
    await self.pipulate.message_queue.put(username, f"‚ö†Ô∏è Qualifier failed: {str(e)}. Using default value.")
    optimal_value = default_value
```

### User-Friendly Error Messages
Transform technical errors into actionable feedback:

```python
if "404" in str(error):
    message = "‚ùå Project not found. Please check your project URL."
elif "401" in str(error):
    message = "‚ùå Authentication failed. Please check your API token."
else:
    message = f"‚ùå Unexpected error: {str(error)}"
```

## State Management Patterns

### Consistent State Structure
Use predictable state keys across workflows:

```python
state_update = {
    'username': username,
    'project_name': project_name,
    'analysis_slug': analysis_slug,
    'template_config': template_config,
    'dynamic_parameters': dynamic_params
}
```

### Template Configuration Storage
Store template choices for later use:

```python
await self.pipulate.db.set_state(
    pipeline_id, 
    'template_config', 
    {
        'crawl_template': selected_template,
        'gsc_template': 'GSC Performance'
    }
)
```

## CSS Styling Hierarchy and Best Practices

### Philosophy: Layered Styling Approach
WET workflows should follow a strict hierarchy for CSS styling to ensure consistency, maintainability, and performance. This approach prevents style conflicts and makes global design changes manageable.

### CSS Styling Hierarchy (Priority Order)

#### 1. First Priority: Standard PicoCSS Classes
**Always favor built-in PicoCSS classes** from `pipulate/static/pico.css`:

```python
# ‚úÖ PREFERRED - Use PicoCSS classes
Button("Submit", cls="secondary")
Div(content, cls="container")
Article(content, cls="card")
Input(type="text", cls="form-control")
```

**Common PicoCSS Classes to Use:**
- Layout: `.container`, `.grid`, `.overflow-auto`
- Typography: `.text-secondary`, `.text-muted`, `.font-bold`
- Buttons: `.secondary`, `.contrast`, `.outline`
- Forms: Standard form styling is automatic
- Colors: Use semantic color classes when available

#### 2. Second Priority: Standard Pipulate Styles
**Use established Pipulate styles** from `pipulate/static/styles.css`:

```python
# ‚úÖ GOOD - Use Pipulate utility classes
Div(content, cls="text-secondary")
P(text, cls="text-muted")
Div(content, cls="mt-4 mb-2")
Code(code_text, cls="font-code")
```

**Common Pipulate Classes to Use:**
- Text utilities: `.text-secondary`, `.text-muted`, `.text-accent`
- Spacing: `.mt-4`, `.mb-2`, `.p-2`
- Layout: `.w-full`, `.flex`, `.items-center`
- Typography: `.font-code`, `.text-sm`

#### 3. Last Resort: Custom Inline Styles
**Only use custom styles when necessary**, and centralize them using UI_CONSTANTS:

```python
# ‚úÖ ACCEPTABLE - Centralized custom styles
style=f'color: {self.UI_CONSTANTS["COLORS"]["HEADER_TEXT"]}; '
      f'background-color: {self.UI_CONSTANTS["BACKGROUNDS"]["LIGHT_GRAY"]};'

# ‚ùå AVOID - Scattered hardcoded styles
style="color: #2c3e50; background-color: #f1f5f9;"
```

### UI Constants Pattern for Custom Styles

#### Centralized Constants Structure
When custom styles are necessary, centralize them at the top of the workflow class:

```python
class MyWorkflow:
    # UI Constants - Centralized control for global appearance
    UI_CONSTANTS = {
        'COLORS': {
            'HEADER_TEXT': '#2c3e50',           # Dark blue-gray for headers
            'BODY_TEXT': '#5a6c7d',             # Medium blue-gray for body text
            'SUBHEADER_TEXT': '#495057',        # Slightly darker for subheaders
            'ACCENT_BLUE': '#007bff',           # Blue accent for tips and highlights
            'ACCENT_INFO': '#0066cc',           # Info blue for special sections
            'SUCCESS_GREEN': '#28a745',         # Green for success indicators
        },
        'BACKGROUNDS': {
            'LIGHT_GRAY': '#f1f5f9',           # Soft gray for general sections
            'LIGHT_BLUE': '#f0f8ff',           # Light blue for blue-themed sections
            'INFO_BLUE': '#e7f3ff',            # Very light blue for info boxes
        },
        'SPACING': {
            'SECTION_PADDING': '0.75rem',       # Standard section padding
            'BORDER_RADIUS': '4px',             # Standard border radius
            'BORDER_WIDTH': '3px',              # Standard border width for accents
            'MARGIN_BOTTOM': '1rem',            # Standard bottom margin
            'SMALL_MARGIN': '0.25rem 0',       # Small vertical margins
            'TINY_MARGIN': '0.5rem',            # Tiny margins
        },
        'TYPOGRAPHY': {
            'SMALL_TEXT': '0.9rem',             # Small text size
            'TINY_TEXT': '0.85rem',             # Tiny text size
            'FONT_WEIGHT_MEDIUM': '500',        # Medium font weight
        }
    }
```

#### Usage Patterns for UI Constants
Reference constants using f-string formatting for dynamic style generation:

```python
# Template information box
Div(
    P(f"Template: {template_name}", 
      style=f'margin: {self.UI_CONSTANTS["SPACING"]["SMALL_MARGIN"]}; '
            f'font-weight: {self.UI_CONSTANTS["TYPOGRAPHY"]["FONT_WEIGHT_MEDIUM"]}; '
            f'color: {self.UI_CONSTANTS["COLORS"]["HEADER_TEXT"]};'),
    style=f'padding: {self.UI_CONSTANTS["SPACING"]["SECTION_PADDING"]}; '
          f'background-color: {self.UI_CONSTANTS["BACKGROUNDS"]["LIGHT_GRAY"]}; '
          f'border-left: {self.UI_CONSTANTS["SPACING"]["BORDER_WIDTH"]} solid {self.UI_CONSTANTS["COLORS"]["SUCCESS_GREEN"]}; '
          f'border-radius: {self.UI_CONSTANTS["SPACING"]["BORDER_RADIUS"]};'
)
```

### Style Migration Strategy

#### Preparation for Unification
Centralized UI constants serve as preparation for eventual extraction and unification with `styles.css`:

1. **Identify Common Patterns**: Track which custom styles are used across multiple workflows
2. **Standardize Values**: Use consistent color palettes and spacing scales
3. **Document Usage**: Comment on why custom styles are needed vs. standard classes
4. **Plan Extraction**: Prepare for moving common patterns to global stylesheets

#### Refactoring Guidelines
When updating existing workflows:

```python
# ‚ùå BEFORE - Scattered hardcoded styles
P("Header", style="color: #2c3e50; font-weight: 500;")
Div(content, style="background-color: #f1f5f9; padding: 0.75rem;")

# ‚úÖ AFTER - Centralized constants
P("Header", style=f'color: {self.UI_CONSTANTS["COLORS"]["HEADER_TEXT"]}; '
                  f'font-weight: {self.UI_CONSTANTS["TYPOGRAPHY"]["FONT_WEIGHT_MEDIUM"]};')
Div(content, style=f'background-color: {self.UI_CONSTANTS["BACKGROUNDS"]["LIGHT_GRAY"]}; '
                   f'padding: {self.UI_CONSTANTS["SPACING"]["SECTION_PADDING"]};')
```

### Benefits of This Hierarchy

#### Consistency and Performance
- **PicoCSS First**: Leverages optimized, tested styles with consistent behavior
- **Pipulate Second**: Uses established patterns that work across the application
- **Custom Last**: Minimizes custom CSS that could conflict or cause maintenance issues

#### Maintainability
- **Global Changes**: Modify PicoCSS/Pipulate styles to affect all workflows
- **Workflow-Specific**: Use UI constants for workflow-specific customizations
- **Easy Migration**: Centralized constants make it easy to extract common patterns

#### Design System Evolution
- **Foundation**: PicoCSS provides the design system foundation
- **Extensions**: Pipulate styles extend the system for specific needs
- **Customizations**: UI constants handle edge cases while preparing for unification

### Standard Color Categories
- **HEADER_TEXT**: Primary headers and important labels
- **BODY_TEXT**: Secondary text and descriptions
- **SUBHEADER_TEXT**: Section subheadings and intermediate hierarchy
- **ACCENT_BLUE**: Interactive elements and highlights
- **ACCENT_INFO**: Special information and tips
- **SUCCESS_GREEN**: Success states and positive indicators

### Standard Background Categories
- **LIGHT_GRAY**: General information sections
- **LIGHT_BLUE**: Blue-themed sections and highlights
- **INFO_BLUE**: Information boxes and tips

### Standard Spacing Categories
- **SECTION_PADDING**: Consistent padding for content sections
- **BORDER_RADIUS**: Uniform corner rounding
- **BORDER_WIDTH**: Standard accent border thickness
- **MARGIN_BOTTOM**: Consistent vertical spacing between sections
- **SMALL_MARGIN**: Tight spacing for related elements
- **TINY_MARGIN**: Minimal spacing for fine adjustments

## Template Assembly and Marker System

### Philosophy: Deterministic Template Processing
The WET workflow system uses **full-line markers** and **split/join methodology** instead of complex regex patterns for reliable, deterministic template assembly. This approach ensures helper scripts work predictably across different workflow templates.

### Critical Marker Requirements for Helper Tools

**Primary Reference**: See [05_workflow_creation_helpers.mdc](mdc:05_workflow_creation_helpers.mdc) for complete documentation of the 4-tool helper system.

#### Mandatory Markers for Template Compatibility

**ALL workflows that will be used as templates or targets for helper tools MUST include both markers:**

##### 1. Steps List Insertion Point (Required)
```python
# In self.steps definition:
self.steps = [
    Step(id='step_01', done='data_01', show='Step 1', refill=False),
    Step(id='step_02', done='data_02', show='Step 2', refill=False),
    # --- STEPS_LIST_INSERTION_POINT --- 
    Step(id='finalize', done='finalized', show='Finalize Workflow', refill=False) 
]
```

**Critical Requirements:**
- **Must be placed** immediately before the `finalize` step
- **Must be at the same indentation level** as Step definitions
- **Must be a full line** with no other code on the same line
- **Used by**: `splice_workflow_step.py` for adding new steps

##### 2. Step Methods Insertion Point (Required)
```python
# At the end of the class, before closing:
class MyWorkflow:
    async def existing_step_method(self, request):
        # ... existing method ...
        pass

    async def existing_step_submit(self, request):
        # ... existing method ...
        pass

    # --- STEP_METHODS_INSERTION_POINT ---
```

**Critical Requirements:**
- **Must be at class level** (4 spaces indentation)
- **Must be after all existing step methods**
- **Must be before class closing**
- **Must be a full line** with no other code
- **Used by**: `splice_workflow_step.py` for adding new step method templates

#### Helper Tool Marker Dependencies

##### splice_workflow_step.py Requirements
**Source Template**: Not required (generates new placeholder code)
**Target Workflow**: MUST have both insertion point markers

```python
# Target workflow must have:
# 1. --- STEPS_LIST_INSERTION_POINT --- in self.steps
# 2. --- STEP_METHODS_INSERTION_POINT --- at class level
```

**Failure Mode**: If markers missing, script fails with "insertion point not found" error.

##### swap_workflow_step.py Requirements  
**Source Workflow**: Must have the step methods you want to copy
**Target Workflow**: Must have the step ID you want to replace

```python
# Source workflow must have:
async def step_01(self, request):
    # Source implementation
    pass

async def step_01_submit(self, request):
    # Source implementation  
    pass

# Target workflow must have:
async def step_01(self, request):
    # Will be replaced
    pass

async def step_01_submit(self, request):
    # Will be replaced
    pass
```

**Critical Requirements:**
- **Exact step ID matching**: `step_01` in source must match target step parameter
- **Method pair detection**: Tool finds both `step_N` and `step_N_submit` methods
- **Boundary detection**: Tool identifies where each method starts and ends

##### manage_class_attributes.py Requirements
**Source Workflow**: Must have the class attributes to merge (e.g., `UI_CONSTANTS`)
**Target Workflow**: Must have class structure compatible with attribute insertion

```python
# Source workflow must have (example):
class SourceWorkflow:
    UI_CONSTANTS = {
        'COLORS': {...},
        'SPACING': {...}
    }

# Target workflow receives merged attributes automatically
```

##### create_workflow.py Requirements
**Source Template**: Must be in `TEMPLATE_MAP` and have standard class attributes
**Target**: Creates new file, no existing requirements

```python
# Template must have these replaceable attributes:
class TemplateWorkflow:
    APP_NAME = 'template_name'           # Will be replaced
    DISPLAY_NAME = 'Template Display'    # Will be replaced  
    ENDPOINT_MESSAGE = 'Template message'  # Will be replaced
    TRAINING_PROMPT = 'Template prompt'    # Will be replaced
```

#### Common Marker Failure Modes and Solutions

##### Missing Insertion Point Markers
**Error**: `splice_workflow_step.py` fails with "STEPS_LIST_INSERTION_POINT not found"
**Solution**: Add both required markers to target workflow

```python
# Add to self.steps:
# --- STEPS_LIST_INSERTION_POINT --- 

# Add at class level:  
# --- STEP_METHODS_INSERTION_POINT ---
```

##### Incorrect Indentation
**Error**: Markers found but code inserted at wrong indentation level
**Solution**: Ensure markers match surrounding code indentation exactly

```python
# ‚úÖ CORRECT - Matches Step indentation
self.steps = [
    Step(id='step_01', done='data', show='Step 1', refill=False),
    # --- STEPS_LIST_INSERTION_POINT ---  # Same level as Step
    Step(id='finalize', done='finalized', show='Finalize', refill=False)
]

# ‚ùå INCORRECT - Wrong indentation
self.steps = [
    Step(id='step_01', done='data', show='Step 1', refill=False),
# --- STEPS_LIST_INSERTION_POINT ---  # Wrong level
    Step(id='finalize', done='finalized', show='Finalize', refill=False)
]
```

##### Step Method Not Found
**Error**: `swap_workflow_step.py` fails with "step_01 not found in source"
**Solution**: Verify exact step ID exists in source workflow with both methods

```python
# Must have both methods:
async def step_01(self, request):      # GET handler
    pass

async def step_01_submit(self, request):  # POST handler  
    pass
```

#### Template Validation Checklist

Before using a workflow as a template or target, verify:

- [ ] **STEPS_LIST_INSERTION_POINT** present before finalize step
- [ ] **STEP_METHODS_INSERTION_POINT** present at class level after methods
- [ ] **Standard class attributes** present (APP_NAME, DISPLAY_NAME, etc.)
- [ ] **UI_CONSTANTS** defined if sharing styling patterns
- [ ] **Step methods** follow `step_N` and `step_N_submit` naming convention
- [ ] **No syntax errors** that would break helper script parsing
- [ ] **Consistent indentation** throughout class definition

### Atomic Transplantation Markers
**Reference**: [15_atomic_transplantation_system.mdc](mdc:15_atomic_transplantation_system.mdc)

The atomic transplantation system enables deterministic code transplantation between workflows using full-line markers and simple string operations. This system complements the template assembly patterns by providing a way to mark and transplant complete workflow sections.

#### Standard Atomic Transplantation Markers
For workflows that contain reusable atomic units (complete multi-step sections):

```python
# --- START_WORKFLOW_SECTION: steps_01_04_botify_data_collection ---
# This section handles the complete Botify data collection workflow (steps 1-4):
# - Step 1: Botify Project URL input and validation
# - Step 2: Crawl Analysis selection and download
# - Step 3: Web Logs availability check and download
# - Step 4: Search Console data check and download
# This is an atomic unit that should be transplanted together.

# --- SECTION_STEP_DEFINITION ---
steps = [
    Step(id='step_01', done='botify_project', show='Botify Project URL', refill=True),
    Step(id='step_02', done='analysis_data', show='Crawl Analysis', refill=False),
    Step(id='step_03', done='logs_check', show='Web Logs Check', refill=False),
    Step(id='step_04', done='gsc_check', show='Search Console Check', refill=False),
]
# --- END_SECTION_STEP_DEFINITION ---

# ... other class methods ...

# --- SECTION_STEP_METHODS ---
async def step_01(self, request):
    # Step 1 implementation
    pass

async def step_01_submit(self, request):
    # Step 1 submission handler
    pass

# ... more step methods ...

async def step_04_submit(self, request):
    # Final step submission handler
    pass
# --- END_SECTION_STEP_METHODS ---

# ... helper methods outside the atomic unit ...

# --- END_WORKFLOW_SECTION ---
```

#### Atomic Transplantation Marker Definitions
- `START_WORKFLOW_SECTION`: Beginning of atomic unit with descriptive documentation
- `SECTION_STEP_DEFINITION`: Step definitions list boundaries
- `END_SECTION_STEP_DEFINITION`: End of step definitions
- `SECTION_STEP_METHODS`: Step method implementations boundaries
- `END_SECTION_STEP_METHODS`: End of step methods
- `END_WORKFLOW_SECTION`: End of atomic unit

#### When to Use Atomic Transplantation Markers
- **Complex Multi-Step Workflows**: When you have 3+ related steps that form a logical unit
- **Reusable Workflow Components**: API integration patterns, data collection sequences
- **Cross-Workflow Sharing**: When similar functionality needs to be replicated across workflows
- **Maintenance Efficiency**: When bulk updates need to be applied to similar workflow sections

#### Atomic Transplantation Tool Usage
**Tool**: `pipulate/helpers/cleanup/atomic_transplantation_marker_tool.py`

```bash
# Add complete atomic markers to a workflow
python helpers/cleanup/atomic_transplantation_marker_tool.py add-markers plugins/my_workflow.py

# Complete Parameter Buster workflow markers (example)
python helpers/cleanup/atomic_transplantation_marker_tool.py complete-parameter-buster

# Custom marker insertion
python helpers/cleanup/atomic_transplantation_marker_tool.py insert-before "async def step_01" "# --- MARKER ---" file.py
```

### Core Template Markers
Every workflow template must include these markers for automated processing:

#### Steps List Insertion Point
```python
# In self.steps definition:
self.steps = [
    Step(id='step_01', done='data_01', show='Step 1', refill=False),
    # --- STEPS_LIST_INSERTION_POINT --- 
    Step(id='finalize', done='finalized', show='Finalize Workflow', refill=False) 
]
```

**Purpose**: @splice_workflow_step.py inserts new Step definitions before this marker.

#### Step Methods Insertion Point
```python
# At the end of the class, before closing:
    async def existing_step_method(self, request):
        # ... existing method ...
        pass

    # --- STEP_METHODS_INSERTION_POINT ---
```

**Purpose**: @splice_workflow_step.py inserts new step method templates before this marker.

### Template Assembly Patterns

#### 1. Class-Level Replacements
@create_workflow.py uses deterministic string replacement for class attributes:

```python
# Original template values (detected automatically):
class BlankPlaceholder:
    APP_NAME = 'placeholder'
    DISPLAY_NAME = 'Blank Placeholder' 
    ENDPOINT_MESSAGE = 'Welcome message...'
    TRAINING_PROMPT = 'Training prompt...'

# Replaced with user-provided values:
class MyCustomWorkflow:
    APP_NAME = 'my_custom'
    DISPLAY_NAME = 'My Custom Workflow'
    ENDPOINT_MESSAGE = 'Custom welcome message...'
    TRAINING_PROMPT = 'Custom training prompt...'
```

#### 2. Steps List Processing
The helper scripts use **line-by-line processing** instead of regex for reliability:

```python
def find_steps_list_definition(content):
    # Pattern 1: Direct assignment `self.steps = [...]`
    # Pattern 2: Indirect assignment `self.steps = variable_name` then `variable_name = [...]`
    # Returns: (prefix, content, suffix, full_block) for precise replacement
```

#### 3. Method Template Generation
New step methods follow standardized templates:

```python
def generate_step_method_templates(step_id_str, step_done_key, step_show_name):
    # Generates both GET and POST handlers
    # Uses consistent indentation and patterns
    # Includes proper HTMX chain reaction triggers
```

### Template Selection System

#### Available Templates
Reference: @create_workflow.py lines 35-42

```python
TEMPLATE_MAP = {
    "blank": "710_blank_placeholder.py",      # Minimal single-step template
    "trifecta": "535_botify_trifecta.py",     # Complex multi-export template
    # Future templates can be added here
}
```

#### Template Requirements
Any workflow can become a template by including:

1. **Required Markers**: Both insertion point markers
2. **Standard Attributes**: APP_NAME, DISPLAY_NAME, ENDPOINT_MESSAGE, TRAINING_PROMPT
3. **UI Constants**: Centralized styling constants for consistent appearance
4. **Consistent Patterns**: Standard step definitions and method signatures
5. **Documentation**: Clear docstrings explaining the workflow's purpose

### Helper Script Usage Patterns

#### Creating New Workflows
```bash
# From any location (script finds project root automatically):
python create_workflow.py 035_kungfu_workflow.py KungfuWorkflow kungfu "Kung Fu Download" "Welcome message" "Training prompt"

# Using different templates:
python create_workflow.py 036_custom_botify.py MyBotify my_botify "Custom Flow" "Welcome" "Training" --template trifecta
```

#### Adding Steps to Existing Workflows
```bash
# Insert at bottom (before finalize step - default):
python splice_workflow_step.py 035_kungfu_workflow.py

# Insert at top (becomes new first step):
python splice_workflow_step.py 035_kungfu_workflow.py --position top
```

### Marker Placement Best Practices

The WET workflow system uses two complementary marker systems:
1. **Template Assembly Markers**: For workflow creation and step insertion
2. **Atomic Transplantation Markers**: For reusable workflow section transplantation

#### Template Assembly Markers

##### Steps List Marker
- **Always** place immediately before the finalize step
- **Never** place inside conditional logic or loops
- **Maintain** consistent indentation with surrounding Step definitions

```python
# ‚úÖ CORRECT - Clear insertion point
self.steps = [
    Step(id='step_01', done='data_01', show='Step 1', refill=False),
    Step(id='step_02', done='data_02', show='Step 2', refill=False),
    # --- STEPS_LIST_INSERTION_POINT --- 
    Step(id='finalize', done='finalized', show='Finalize Workflow', refill=False) 
]

# ‚ùå INCORRECT - Marker inside conditional
if some_condition:
    # --- STEPS_LIST_INSERTION_POINT ---
```

##### Methods Marker
- **Always** place at class level (not inside methods)
- **Position** after all existing step methods
- **Maintain** consistent indentation (4 spaces for class members)

```python
# ‚úÖ CORRECT - At class level, proper indentation
class MyWorkflow:
    async def step_01(self, request):
        pass
    
    async def step_01_submit(self, request):
        pass
    
    # --- STEP_METHODS_INSERTION_POINT ---

# ‚ùå INCORRECT - Inside method or wrong indentation
    async def step_01(self, request):
        # --- STEP_METHODS_INSERTION_POINT ---  # Wrong location
        pass
```

#### Atomic Transplantation Markers

##### Workflow Section Markers
- **Use descriptive section names** that clearly identify the atomic unit
- **Include comprehensive documentation** explaining what the section does
- **Mark complete, self-contained workflow sections** (typically 3+ related steps)

```python
# ‚úÖ CORRECT - Complete atomic unit with clear boundaries
# --- START_WORKFLOW_SECTION: botify_data_collection ---
# This section handles the complete Botify data collection workflow:
# - Step 1: Project URL input and validation
# - Step 2: Analysis selection and download
# - Step 3: Web logs check and download
# This is an atomic unit that should be transplanted together.

# --- SECTION_STEP_DEFINITION ---
steps = [
    Step(id='step_01', done='botify_project', show='Botify Project URL', refill=True),
    Step(id='step_02', done='analysis_data', show='Crawl Analysis', refill=False),
    Step(id='step_03', done='logs_check', show='Web Logs Check', refill=False),
]
# --- END_SECTION_STEP_DEFINITION ---

# --- SECTION_STEP_METHODS ---
async def step_01(self, request):
    # Implementation
    pass

async def step_01_submit(self, request):
    # Implementation
    pass

async def step_02(self, request):
    # Implementation
    pass

async def step_02_submit(self, request):
    # Implementation
    pass
# --- END_SECTION_STEP_METHODS ---

# --- END_WORKFLOW_SECTION ---

# ‚ùå INCORRECT - Incomplete atomic unit
# --- START_WORKFLOW_SECTION: incomplete_section ---
async def step_01(self, request):
    pass
# Missing step definitions, missing end markers
```

##### Marker Hierarchy and Nesting
- **Atomic transplantation markers** can contain **template assembly markers**
- **Never nest** atomic transplantation sections within each other
- **Maintain clear boundaries** between different atomic units

```python
# ‚úÖ CORRECT - Atomic markers containing template markers
# --- START_WORKFLOW_SECTION: api_integration ---
# --- SECTION_STEP_DEFINITION ---
steps = [
    Step(id='step_01', done='api_setup', show='API Setup', refill=False),
    # --- STEPS_LIST_INSERTION_POINT ---  # Template marker inside atomic section
    Step(id='finalize', done='finalized', show='Finalize', refill=False)
]
# --- END_SECTION_STEP_DEFINITION ---

# --- SECTION_STEP_METHODS ---
async def step_01(self, request):
    pass

# --- STEP_METHODS_INSERTION_POINT ---  # Template marker inside atomic section
# --- END_SECTION_STEP_METHODS ---
# --- END_WORKFLOW_SECTION ---
```

#### Marker Selection Guidelines

##### Use Template Assembly Markers When:
- Creating new workflows from templates
- Adding individual steps to existing workflows
- Building simple, linear workflows
- Working with single-purpose workflows

##### Use Atomic Transplantation Markers When:
- Creating reusable multi-step workflow components
- Building complex workflows with distinct functional sections
- Planning to share workflow patterns across multiple implementations
- Working with API integration patterns that will be reused

##### Use Both Systems When:
- Building complex workflows that serve as templates for others
- Creating comprehensive workflow libraries
- Developing workflows with both reusable sections and extensible step lists
- Building enterprise-grade workflow systems

### Template Evolution Strategy

#### Making Any Workflow a Template
1. **Add Required Markers**: Insert both template assembly insertion point markers
2. **Add UI Constants**: Define centralized styling constants for consistent appearance
3. **Standardize Attributes**: Ensure all required class attributes are present (APP_NAME, DISPLAY_NAME, etc.)
4. **Document Patterns**: Add clear docstrings explaining the workflow's approach
5. **Test Assembly**: Verify the workflow works with helper scripts
6. **Register Template**: Add to TEMPLATE_MAP in create_workflow.py

#### Making Workflows Atomic Transplantation Ready
1. **Identify Reusable Sections**: Look for 3+ related steps that form logical units
2. **Add Atomic Markers**: Use the atomic transplantation marker tool to mark sections
3. **Document Atomic Units**: Include comprehensive comments explaining what each section does
4. **Test Transplantation**: Verify sections can be extracted and transplanted successfully
5. **Maintain Boundaries**: Ensure atomic units are self-contained and don't have external dependencies

#### Template Inheritance Patterns
Complex workflows can serve as templates for similar use cases:

- **API Integration Templates**: Based on Botify Trifecta pattern with atomic data collection sections
- **File Processing Templates**: Based on upload/download workflows with reusable file handling sections
- **Multi-Step Forms**: Based on data collection patterns with atomic form progression sections
- **Background Processing**: Based on long-running operation patterns with atomic processing sections

#### Hybrid Workflow Development
Combine both marker systems for maximum flexibility:

```python
class HybridWorkflow:
    # --- START_WORKFLOW_SECTION: core_data_collection ---
    # Core data collection that can be transplanted to other workflows
    
    # --- SECTION_STEP_DEFINITION ---
    steps = [
        Step(id='step_01', done='data_source', show='Data Source', refill=True),
        Step(id='step_02', done='data_fetch', show='Fetch Data', refill=False),
        # --- STEPS_LIST_INSERTION_POINT ---  # Allow additional steps to be inserted
        Step(id='finalize', done='finalized', show='Finalize', refill=False)
    ]
    # --- END_SECTION_STEP_DEFINITION ---
    
    # --- SECTION_STEP_METHODS ---
    async def step_01(self, request):
        # Core implementation
        pass
    
    async def step_02(self, request):
        # Core implementation  
        pass
    
    # --- STEP_METHODS_INSERTION_POINT ---  # Allow additional methods to be inserted
    # --- END_SECTION_STEP_METHODS ---
    
    # --- END_WORKFLOW_SECTION ---
    
    # Additional workflow-specific methods outside the atomic unit
    async def custom_helper_method(self, request):
        pass
```

### Why This Approach Works

#### Advantages of Full-Line Markers
- **Predictable**: No regex edge cases or escaping issues
- **Debuggable**: Easy to see exactly where insertions will occur
- **Maintainable**: Simple string operations instead of complex pattern matching
- **Reliable**: Works consistently across different code styles and formatting
- **Tool-Friendly**: Both AI and custom tools can work with these markers effectively

#### Split/Join Methodology Benefits
- **Preserves Formatting**: Maintains original indentation and style
- **Handles Edge Cases**: Works with various Python syntax patterns
- **Easy to Debug**: Can inspect intermediate steps in processing
- **Extensible**: Easy to add new processing steps without breaking existing logic
- **Deterministic**: Same input always produces same output

#### Template-Based System Benefits
- **Template Assembly**: Enables rapid workflow creation with proven 4-tool system
- **Marker Requirements**: Clear, mandatory requirements prevent common failures
- **Failure Mode Prevention**: Explicit marker validation catches issues early
- **Developer Experience**: Template validation checklist ensures compatibility
- **Consistency**: All workflows using templates have consistent marker patterns

#### Real-World Impact Based on 4-Tool Helper System
- **95% Success Rate**: Template-based creation works reliably when markers present
- **Clear Error Messages**: Helper tools provide specific marker requirement failures
- **Development Speed**: 5-command sequences create complex workflows in minutes
- **Learning Path**: Progressive education through workflow genesis system
- **Maintenance Reduction**: Template innovations can propagate to workflows built from templates

#### Template Compatibility Benefits
- **Mandatory Markers**: STEPS_LIST_INSERTION_POINT and STEP_METHODS_INSERTION_POINT ensure splice compatibility
- **Method Detection**: Reliable step method boundary detection for swapping logic
- **Attribute Merging**: Safe UI_CONSTANTS sharing across compatible workflows
- **Template Evolution**: New templates can be added to TEMPLATE_MAP as they mature

#### Proven Success Pattern
The 4-tool helper system (Rule 05) demonstrates the power of this marker approach:
1. **create_workflow.py** creates working foundation with proper markers
2. **manage_class_attributes.py** shares styling through reliable attribute detection
3. **splice_workflow_step.py** adds steps using precise marker insertion
4. **swap_workflow_step.py** replaces logic through deterministic method boundary detection

This marker system ensures that WET workflows maintain their explicit, debuggable nature while enabling rapid development through template-based creation and proven helper tool patterns.

## Evolution Lessons: From Complex Tools to Simple Templates

### Key Learning: Template-Based Creation Supersedes Complex Helper Systems

**Historical Evolution**:
- **Early Phase**: Atomic transplantation and complex cleanup helpers
- **Problems Discovered**: Dependency conflicts, maintenance overhead, token waste
- **Current Solution**: 4-tool template-based creation system (Rule 05)

### Critical Success Factors for Template-Based Development

#### Mandatory Template Requirements
**Every workflow intended for template use or helper tool compatibility MUST have:**

1. **Both Insertion Point Markers**:
   - `--- STEPS_LIST_INSERTION_POINT ---` before finalize step
   - `--- STEP_METHODS_INSERTION_POINT ---` at class level

2. **Standard Class Attributes**:
   - `APP_NAME`, `DISPLAY_NAME`, `ENDPOINT_MESSAGE`, `TRAINING_PROMPT`

3. **UI Constants Definition**:
   - Centralized styling for consistent appearance across workflows

#### Workflow Genesis Integration
The [510_workflow_genesis.py](mdc:pipulate/plugins/510_workflow_genesis.py) workflow provides **educational progression**:
- **Step 1**: Parameter definition
- **Step 2**: Template selection with appropriate commands
- **Step 3**: Individual helper tool education
- **Step 4**: Complete command sequence for complex builds

### Development Strategy Evolution

#### Template Selection Strategy
- **Blank Template**: Learning, heavy customization ‚Üí Requires 5-command sequence
- **Hello Template**: Simple demos, 2-step workflows ‚Üí Single command creation
- **Trifecta Template**: Complex data workflows ‚Üí Single command creation

#### Command Sequence Intelligence
**Simple Templates**: Single `create_workflow.py` command sufficient
**Complex Builds**: 5-command sequence for transforming blank template:
1. Create base from blank template
2. Merge UI constants from source
3. Swap step_01 logic 
4. Add step_02 placeholder
5. Swap step_02 logic

## Implementation Guidelines

### When to Apply These Conventions
- **New WET workflows**: Start with template-based creation (Rule 05) and apply UI conventions
- **Template creation**: Ensure all mandatory markers and attributes present
- **Existing workflows**: Add markers for helper tool compatibility
- **Message queue updates**: Prioritize emoji consistency for better UX
- **Style updates**: Use centralized UI constants for global appearance changes

### Marker Implementation Checklist
Before considering a workflow "template-ready":
- [ ] `STEPS_LIST_INSERTION_POINT` before finalize step (correct indentation)
- [ ] `STEP_METHODS_INSERTION_POINT` at class level after methods  
- [ ] Standard class attributes defined and replaceable
- [ ] UI_CONSTANTS defined for styling consistency
- [ ] Step methods follow `step_N` and `step_N_submit` convention
- [ ] No syntax errors that break helper script parsing

### Key Benefits
- **Template-Based Speed**: Proven 4-tool system creates workflows in minutes
- **Clear Requirements**: Mandatory markers prevent common failure modes
- **Educational Value**: Progressive learning through workflow genesis
- **Maintenance Efficiency**: Template innovations propagate to derived workflows
- **Visual Consistency**: UI constants enable consistent appearance
- **Error Prevention**: Validation checklist catches compatibility issues early

### Success Metrics from Real Usage
- **95% Success Rate**: When mandatory markers present, helper tools work reliably
- **5-Command Sequences**: Transform blank templates into complex workflows
- **Single Commands**: Create working hello/trifecta workflows instantly
- **Clear Error Messages**: Helper tools provide specific failure diagnostics

These conventions ensure consistent user experience across all WET workflows while leveraging the proven template-based creation system that maintains the explicit, debuggable nature that makes WET patterns effective for complex data processing pipelines.
