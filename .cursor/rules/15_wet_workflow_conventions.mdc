---
description: 
globs: 
alwaysApply: false
---
# WET Workflow Conventions: Emoji, Messaging, and User Experience Patterns

This document outlines the conventions and patterns for creating effective, user-friendly WET (Write Everything Twice) workflows in the Pipulate framework, based on innovations from the Botify Trifecta workflow.

## Emoji Usage Conventions

### Message Queue Emojis
Emojis serve as visual anchors for quick status recognition:

**Process Status Indicators:**
- üîç **Discovery/Analysis**: Finding optimal parameters, analyzing data
- üéØ **Success/Found**: Successful completion, optimal values found  
- ‚ö†Ô∏è **Warnings**: Non-critical issues, proceeding with caution
- ‚ùå **Errors**: Critical failures, operation stopped
- ‚úÖ **Completion**: Final success confirmation

**Data Type Indicators:**
- üìä **Analytics/Metrics**: Data analysis, performance metrics
- üîó **Links/Connections**: Link graphs, internal linking
- üìÑ **Content/Pages**: Page attributes, content analysis
- üîç **Search**: Search Console data, keyword analysis

**Action Indicators:**
- ‚¨áÔ∏è **Downloads**: File downloads, CSV exports
- üìÇ **File Operations**: Folder access, file management
- üêç **Code**: Python code generation, API debugging
- üîÑ **Processing**: Background operations, API calls

### Button Label Emojis
Reference: [400_botify_quadfecta.py](mdc:pipulate/plugins/400_botify_quadfecta.py) lines 180-190

```python
UI_CONSTANTS = {
    'BUTTON_LABELS': {
        'HIDE_SHOW_CODE': 'üêç Hide/Show Code',
        'VIEW_FOLDER': 'üìÇ View Folder', 
        'DOWNLOAD_CSV': '‚¨áÔ∏è Download CSV'
    }
}
```

## Message Queue Flow Patterns

### Progressive Feedback Pattern
Provide continuous feedback during long operations:

```python
# Initial status
await self.pipulate.message_queue.put(username, "üîç Finding optimal depth for Link Graph Edges...")

# Progress updates  
await self.pipulate.message_queue.put(username, f"Testing depth {depth}: {metric_value:,} edges")

# Final result
await self.pipulate.message_queue.put(username, f"üéØ Optimal depth: {optimal_depth} (for {final_count:,} edges).")
```

### Error Handling in Messages
Clear, actionable error messages with appropriate emojis:

```python
# Specific error context
await self.pipulate.message_queue.put(username, f"‚ùå API Error: {error_details}")

# Recovery suggestions
await self.pipulate.message_queue.put(username, "‚ö†Ô∏è Retrying with fallback parameters...")
```

## Template-Driven UI Patterns

### Dynamic User Messages
Templates should include user-facing explanations:

```python
QUERY_TEMPLATES = {
    'Template Name': {
        'user_message': 'This will download X data including Y and Z fields.',
        'button_label_suffix': 'Descriptive Action',
        # ... other config
    }
}
```

### Qualifier Configuration Pattern
For templates needing prerequisite queries to optimize parameters:

```python
'qualifier_config': {
    'enabled': True,
    'user_message_running': 'üîç Finding optimal parameters...',
    'user_message_found': 'üéØ Optimal value: {param_value} (for {metric_value:,} items).',
    'user_message_threshold_exceeded': '‚ö†Ô∏è Warning: Large dataset detected. Proceeding with caution.'
}
```

## Chain Reaction Pattern Conventions

### Step Progression
Each step follows the standard pattern for reliable progression:

```python
async def step_N_submit(self, request):
    # Process form data
    # Store results  
    # Provide user feedback
    
    # Return revert control + next step trigger
    return Div(
        self._create_revert_control(request, f"step_{N}"),
        Div(id=f"step_{N+1}", hx_get=f"/{self.APP_NAME}/step_{N+1}", hx_trigger="load")
    )
```

### Background Processing Pattern
For long-running operations, use Script tags with htmx.ajax:

```python
return Div(
    P("üîÑ Processing in background..."),
    Script(f"""
        htmx.ajax('POST', '/{self.APP_NAME}/step_N_process', {{
            values: {{'pipeline_id': '{pipeline_id}'}},
            target: '#step_N',
            swap: 'outerHTML'
        }});
    """)
)
```

## File Management Conventions

### Deterministic File Paths
Use consistent, predictable file naming:

```python
async def get_deterministic_filepath(self, username, project_name, analysis_slug, data_type=None):
    safe_project = re.sub(r'[^\w\-_]', '_', project_name)
    safe_analysis = re.sub(r'[^\w\-_]', '_', analysis_slug)
    
    if data_type:
        filename = f"{safe_project}_{safe_analysis}_{data_type}.csv"
    else:
        filename = f"{safe_project}_{safe_analysis}.csv"
    
    return f"downloads/{username}/{filename}"
```

### Cache-Aware Button Text
Buttons should reflect file availability:

```python
async def check_cached_file_for_button_text(self, username, project_name, analysis_slug, data_type):
    filepath = await self.get_deterministic_filepath(username, project_name, analysis_slug, data_type)
    if await self.check_file_exists(filepath):
        return f"‚¨áÔ∏è Download Cached {data_type.title()}"
    else:
        return f"üìä Generate {data_type.title()}"
```

## Code Generation Patterns

### Jupyter-Friendly Output
Generated code should be optimized for notebook debugging:

```python
def _generate_api_call_representations(self, method, url, headers, payload=None, step_context=None):
    # Generate both curl and Python requests versions
    # Include proper error handling
    # Add explanatory comments
    # Format for easy copying
```

### Syntax Highlighting Integration
When displaying code, ensure proper highlighting:

```python
Pre(
    Code(python_code, cls="language-python"),
    style="max-height: 400px; overflow-y: auto;"
)
```

## Error Handling Conventions

### Graceful Degradation
Always provide fallback behavior:

```python
try:
    optimal_value = await self._execute_qualifier_logic(...)
except Exception as e:
    await self.pipulate.message_queue.put(username, f"‚ö†Ô∏è Qualifier failed: {str(e)}. Using default value.")
    optimal_value = default_value
```

### User-Friendly Error Messages
Transform technical errors into actionable feedback:

```python
if "404" in str(error):
    message = "‚ùå Project not found. Please check your project URL."
elif "401" in str(error):
    message = "‚ùå Authentication failed. Please check your API token."
else:
    message = f"‚ùå Unexpected error: {str(error)}"
```

## State Management Patterns

### Consistent State Structure
Use predictable state keys across workflows:

```python
state_update = {
    'username': username,
    'project_name': project_name,
    'analysis_slug': analysis_slug,
    'template_config': template_config,
    'dynamic_parameters': dynamic_params
}
```

### Template Configuration Storage
Store template choices for later use:

```python
await self.pipulate.db.set_state(
    pipeline_id, 
    'template_config', 
    {
        'crawl_template': selected_template,
        'gsc_template': 'GSC Performance'
    }
)
```

## CSS Styling Hierarchy and Best Practices

### Philosophy: Layered Styling Approach
WET workflows should follow a strict hierarchy for CSS styling to ensure consistency, maintainability, and performance. This approach prevents style conflicts and makes global design changes manageable.

### CSS Styling Hierarchy (Priority Order)

#### 1. First Priority: Standard PicoCSS Classes
**Always favor built-in PicoCSS classes** from `pipulate/static/pico.css`:

```python
# ‚úÖ PREFERRED - Use PicoCSS classes
Button("Submit", cls="secondary")
Div(content, cls="container")
Article(content, cls="card")
Input(type="text", cls="form-control")
```

**Common PicoCSS Classes to Use:**
- Layout: `.container`, `.grid`, `.overflow-auto`
- Typography: `.text-secondary`, `.text-muted`, `.font-bold`
- Buttons: `.secondary`, `.contrast`, `.outline`
- Forms: Standard form styling is automatic
- Colors: Use semantic color classes when available

#### 2. Second Priority: Standard Pipulate Styles
**Use established Pipulate styles** from `pipulate/static/styles.css`:

```python
# ‚úÖ GOOD - Use Pipulate utility classes
Div(content, cls="text-secondary")
P(text, cls="text-muted")
Div(content, cls="mt-4 mb-2")
Code(code_text, cls="font-code")
```

**Common Pipulate Classes to Use:**
- Text utilities: `.text-secondary`, `.text-muted`, `.text-accent`
- Spacing: `.mt-4`, `.mb-2`, `.p-2`
- Layout: `.w-full`, `.flex`, `.items-center`
- Typography: `.font-code`, `.text-sm`

#### 3. Last Resort: Custom Inline Styles
**Only use custom styles when necessary**, and centralize them using UI_CONSTANTS:

```python
# ‚úÖ ACCEPTABLE - Centralized custom styles
style=f'color: {self.UI_CONSTANTS["COLORS"]["HEADER_TEXT"]}; '
      f'background-color: {self.UI_CONSTANTS["BACKGROUNDS"]["LIGHT_GRAY"]};'

# ‚ùå AVOID - Scattered hardcoded styles
style="color: #2c3e50; background-color: #f1f5f9;"
```

### UI Constants Pattern for Custom Styles

#### Centralized Constants Structure
When custom styles are necessary, centralize them at the top of the workflow class:

```python
class MyWorkflow:
    # UI Constants - Centralized control for global appearance
    UI_CONSTANTS = {
        'COLORS': {
            'HEADER_TEXT': '#2c3e50',           # Dark blue-gray for headers
            'BODY_TEXT': '#5a6c7d',             # Medium blue-gray for body text
            'SUBHEADER_TEXT': '#495057',        # Slightly darker for subheaders
            'ACCENT_BLUE': '#007bff',           # Blue accent for tips and highlights
            'ACCENT_INFO': '#0066cc',           # Info blue for special sections
            'SUCCESS_GREEN': '#28a745',         # Green for success indicators
        },
        'BACKGROUNDS': {
            'LIGHT_GRAY': '#f1f5f9',           # Soft gray for general sections
            'LIGHT_BLUE': '#f0f8ff',           # Light blue for blue-themed sections
            'INFO_BLUE': '#e7f3ff',            # Very light blue for info boxes
        },
        'SPACING': {
            'SECTION_PADDING': '0.75rem',       # Standard section padding
            'BORDER_RADIUS': '4px',             # Standard border radius
            'BORDER_WIDTH': '3px',              # Standard border width for accents
            'MARGIN_BOTTOM': '1rem',            # Standard bottom margin
            'SMALL_MARGIN': '0.25rem 0',       # Small vertical margins
            'TINY_MARGIN': '0.5rem',            # Tiny margins
        },
        'TYPOGRAPHY': {
            'SMALL_TEXT': '0.9rem',             # Small text size
            'TINY_TEXT': '0.85rem',             # Tiny text size
            'FONT_WEIGHT_MEDIUM': '500',        # Medium font weight
        }
    }
```

#### Usage Patterns for UI Constants
Reference constants using f-string formatting for dynamic style generation:

```python
# Template information box
Div(
    P(f"Template: {template_name}", 
      style=f'margin: {self.UI_CONSTANTS["SPACING"]["SMALL_MARGIN"]}; '
            f'font-weight: {self.UI_CONSTANTS["TYPOGRAPHY"]["FONT_WEIGHT_MEDIUM"]}; '
            f'color: {self.UI_CONSTANTS["COLORS"]["HEADER_TEXT"]};'),
    style=f'padding: {self.UI_CONSTANTS["SPACING"]["SECTION_PADDING"]}; '
          f'background-color: {self.UI_CONSTANTS["BACKGROUNDS"]["LIGHT_GRAY"]}; '
          f'border-left: {self.UI_CONSTANTS["SPACING"]["BORDER_WIDTH"]} solid {self.UI_CONSTANTS["COLORS"]["SUCCESS_GREEN"]}; '
          f'border-radius: {self.UI_CONSTANTS["SPACING"]["BORDER_RADIUS"]};'
)
```

### Style Migration Strategy

#### Preparation for Unification
Centralized UI constants serve as preparation for eventual extraction and unification with `styles.css`:

1. **Identify Common Patterns**: Track which custom styles are used across multiple workflows
2. **Standardize Values**: Use consistent color palettes and spacing scales
3. **Document Usage**: Comment on why custom styles are needed vs. standard classes
4. **Plan Extraction**: Prepare for moving common patterns to global stylesheets

#### Refactoring Guidelines
When updating existing workflows:

```python
# ‚ùå BEFORE - Scattered hardcoded styles
P("Header", style="color: #2c3e50; font-weight: 500;")
Div(content, style="background-color: #f1f5f9; padding: 0.75rem;")

# ‚úÖ AFTER - Centralized constants
P("Header", style=f'color: {self.UI_CONSTANTS["COLORS"]["HEADER_TEXT"]}; '
                  f'font-weight: {self.UI_CONSTANTS["TYPOGRAPHY"]["FONT_WEIGHT_MEDIUM"]};')
Div(content, style=f'background-color: {self.UI_CONSTANTS["BACKGROUNDS"]["LIGHT_GRAY"]}; '
                   f'padding: {self.UI_CONSTANTS["SPACING"]["SECTION_PADDING"]};')
```

### Benefits of This Hierarchy

#### Consistency and Performance
- **PicoCSS First**: Leverages optimized, tested styles with consistent behavior
- **Pipulate Second**: Uses established patterns that work across the application
- **Custom Last**: Minimizes custom CSS that could conflict or cause maintenance issues

#### Maintainability
- **Global Changes**: Modify PicoCSS/Pipulate styles to affect all workflows
- **Workflow-Specific**: Use UI constants for workflow-specific customizations
- **Easy Migration**: Centralized constants make it easy to extract common patterns

#### Design System Evolution
- **Foundation**: PicoCSS provides the design system foundation
- **Extensions**: Pipulate styles extend the system for specific needs
- **Customizations**: UI constants handle edge cases while preparing for unification

### Standard Color Categories
- **HEADER_TEXT**: Primary headers and important labels
- **BODY_TEXT**: Secondary text and descriptions
- **SUBHEADER_TEXT**: Section subheadings and intermediate hierarchy
- **ACCENT_BLUE**: Interactive elements and highlights
- **ACCENT_INFO**: Special information and tips
- **SUCCESS_GREEN**: Success states and positive indicators

### Standard Background Categories
- **LIGHT_GRAY**: General information sections
- **LIGHT_BLUE**: Blue-themed sections and highlights
- **INFO_BLUE**: Information boxes and tips

### Standard Spacing Categories
- **SECTION_PADDING**: Consistent padding for content sections
- **BORDER_RADIUS**: Uniform corner rounding
- **BORDER_WIDTH**: Standard accent border thickness
- **MARGIN_BOTTOM**: Consistent vertical spacing between sections
- **SMALL_MARGIN**: Tight spacing for related elements
- **TINY_MARGIN**: Minimal spacing for fine adjustments

## Template Assembly and Marker System

### Philosophy: Deterministic Template Processing
The WET workflow system uses **full-line markers** and **split/join methodology** instead of complex regex patterns for reliable, deterministic template assembly. This approach ensures helper scripts work predictably across different workflow templates.

### Critical Marker Requirements for Helper Tools

**Primary Reference**: See [05_workflow_creation_helpers.mdc](mdc:05_workflow_creation_helpers.mdc) for complete documentation of the 4-tool helper system.

#### Mandatory Markers for Template Compatibility

**ALL workflows that will be used as templates or targets for helper tools MUST include both markers:**

##### 1. Steps List Insertion Point (Required)
```python
# In self.steps definition:
self.steps = [
    Step(id='step_01', done='data_01', show='Step 1', refill=False),
    Step(id='step_02', done='data_02', show='Step 2', refill=False),
    # --- STEPS_LIST_INSERTION_POINT --- 
    Step(id='finalize', done='finalized', show='Finalize Workflow', refill=False) 
]
```

**Critical Requirements:**
- **Must be placed** immediately before the `finalize` step
- **Must be at the same indentation level** as Step definitions
- **Must be a full line** with no other code on the same line
- **Used by**: `splice_workflow_step.py` for adding new steps

##### 2. Step Methods Insertion Point (Required)
```python
# At the end of the class, before closing:
class MyWorkflow:
    async def existing_step_method(self, request):
        # ... existing method ...
        pass

    async def existing_step_submit(self, request):
        # ... existing method ...
        pass

    # --- STEP_METHODS_INSERTION_POINT ---
```

**Critical Requirements:**
- **Must be at class level** (4 spaces indentation)
- **Must be after all existing step methods**
- **Must be before class closing**
- **Must be a full line** with no other code
- **Used by**: `splice_workflow_step.py` for adding new step method templates

#### Helper Tool Marker Dependencies

##### splice_workflow_step.py Requirements
**Source Template**: Not required (generates new placeholder code)
**Target Workflow**: MUST have both insertion point markers

```python
# Target workflow must have:
# 1. --- STEPS_LIST_INSERTION_POINT --- in self.steps
# 2. --- STEP_METHODS_INSERTION_POINT --- at class level
```

**Failure Mode**: If markers missing, script fails with "insertion point not found" error.

##### swap_workflow_step.py Requirements  
**Source Workflow**: Must have the step methods you want to copy
**Target Workflow**: Must have the step ID you want to replace

```python
# Source workflow must have:
async def step_01(self, request):
    # Source implementation
    pass

async def step_01_submit(self, request):
    # Source implementation  
    pass

# Target workflow must have:
async def step_01(self, request):
    # Will be replaced
    pass

async def step_01_submit(self, request):
    # Will be replaced
    pass
```

**Critical Requirements:**
- **Exact step ID matching**: `step_01` in source must match target step parameter
- **Method pair detection**: Tool finds both `step_N` and `step_N_submit` methods
- **Boundary detection**: Tool identifies where each method starts and ends

##### manage_class_attributes.py Requirements
**Source Workflow**: Must have the class attributes to merge (e.g., `UI_CONSTANTS`)
**Target Workflow**: Must have class structure compatible with attribute insertion

```python
# Source workflow must have (example):
class SourceWorkflow:
    UI_CONSTANTS = {
        'COLORS': {...},
        'SPACING': {...}
    }

# Target workflow receives merged attributes automatically
```

##### create_workflow.py Requirements
**Source Template**: Must be in `TEMPLATE_MAP` and have standard class attributes
**Target**: Creates new file, no existing requirements

```python
# Template must have these replaceable attributes:
class TemplateWorkflow:
    APP_NAME = 'template_name'           # Will be replaced
    DISPLAY_NAME = 'Template Display'    # Will be replaced  
    ENDPOINT_MESSAGE = 'Template message'  # Will be replaced
    TRAINING_PROMPT = 'Template prompt'    # Will be replaced
```

#### Common Marker Failure Modes and Solutions

##### Missing Insertion Point Markers
**Error**: `splice_workflow_step.py` fails with "STEPS_LIST_INSERTION_POINT not found"
**Solution**: Add both required markers to target workflow

```python
# Add to self.steps:
# --- STEPS_LIST_INSERTION_POINT --- 

# Add at class level:  
# --- STEP_METHODS_INSERTION_POINT ---
```

##### Incorrect Indentation
**Error**: Markers found but code inserted at wrong indentation level
**Solution**: Ensure markers match surrounding code indentation exactly

```python
# ‚úÖ CORRECT - Matches Step indentation
self.steps = [
    Step(id='step_01', done='data', show='Step 1', refill=False),
    # --- STEPS_LIST_INSERTION_POINT ---  # Same level as Step
    Step(id='finalize', done='finalized', show='Finalize', refill=False)
]

# ‚ùå INCORRECT - Wrong indentation
self.steps = [
    Step(id='step_01', done='data', show='Step 1', refill=False),
# --- STEPS_LIST_INSERTION_POINT ---  # Wrong level
    Step(id='finalize', done='finalized', show='Finalize', refill=False)
]
```

##### Step Method Not Found
**Error**: `swap_workflow_step.py` fails with "step_01 not found in source"
**Solution**: Verify exact step ID exists in source workflow with both methods

```python
# Must have both methods:
async def step_01(self, request):      # GET handler
    pass

async def step_01_submit(self, request):  # POST handler  
    pass
```

#### Template Validation Checklist

Before using a workflow as a template or target, verify:

- [ ] **STEPS_LIST_INSERTION_POINT** present before finalize step
- [ ] **STEP_METHODS_INSERTION_POINT** present at class level after methods
- [ ] **Standard class attributes** present (APP_NAME, DISPLAY_NAME, etc.)
- [ ] **UI_CONSTANTS** defined if sharing styling patterns
- [ ] **Step methods** follow `step_N` and `step_N_submit` naming convention
- [ ] **No syntax errors** that would break helper script parsing
- [ ] **Consistent indentation** throughout class definition

### Atomic Transplantation Markers
**Reference**: [15_atomic_transplantation_system.mdc](mdc:15_atomic_transplantation_system.mdc)

The atomic transplantation system enables deterministic code transplantation between workflows using full-line markers and simple string operations. This system complements the template assembly patterns by providing a way to mark and transplant complete workflow sections.

#### Standard Atomic Transplantation Markers
For workflows that contain reusable atomic units (complete multi-step sections):

```python
# --- START_WORKFLOW_SECTION: steps_01_04_botify_data_collection ---
# This section handles the complete Botify data collection workflow (steps 1-4):
# - Step 1: Botify Project URL input and validation
# - Step 2: Crawl Analysis selection and download
# - Step 3: Web Logs availability check and download
# - Step 4: Search Console data check and download
# This is an atomic unit that should be transplanted together.

# --- SECTION_STEP_DEFINITION ---
steps = [
    Step(id='step_01', done='botify_project', show='Botify Project URL', refill=True),
    Step(id='step_02', done='analysis_data', show='Crawl Analysis', refill=False),
    Step(id='step_03', done='logs_check', show='Web Logs Check', refill=False),
    Step(id='step_04', done='gsc_check', show='Search Console Check', refill=False),
]
# --- END_SECTION_STEP_DEFINITION ---

# ... other class methods ...

# --- SECTION_STEP_METHODS ---
async def step_01(self, request):
    # Step 1 implementation
    pass

async def step_01_submit(self, request):
    # Step 1 submission handler
    pass

# ... more step methods ...

async def step_04_submit(self, request):
    # Final step submission handler
    pass
# --- END_SECTION_STEP_METHODS ---

# ... helper methods outside the atomic unit ...

# --- END_WORKFLOW_SECTION ---
```

#### Atomic Transplantation Marker Definitions
- `START_WORKFLOW_SECTION`: Beginning of atomic unit with descriptive documentation
- `SECTION_STEP_DEFINITION`: Step definitions list boundaries
- `END_SECTION_STEP_DEFINITION`: End of step definitions
- `SECTION_STEP_METHODS`: Step method implementations boundaries
- `END_SECTION_STEP_METHODS`: End of step methods
- `END_WORKFLOW_SECTION`: End of atomic unit

#### When to Use Atomic Transplantation Markers
- **Complex Multi-Step Workflows**: When you have 3+ related steps that form a logical unit
- **Reusable Workflow Components**: API integration patterns, data collection sequences
- **Cross-Workflow Sharing**: When similar functionality needs to be replicated across workflows
- **Maintenance Efficiency**: When bulk updates need to be applied to similar workflow sections

#### Atomic Transplantation Tool Usage
**Tool**: `pipulate/helpers/cleanup/atomic_transplantation_marker_tool.py`

```bash
# Add complete atomic markers to a workflow
python helpers/cleanup/atomic_transplantation_marker_tool.py add-markers plugins/my_workflow.py

# Complete Parameter Buster workflow markers (example)
python helpers/cleanup/atomic_transplantation_marker_tool.py complete-parameter-buster

# Custom marker insertion
python helpers/cleanup/atomic_transplantation_marker_tool.py insert-before "async def step_01" "# --- MARKER ---" file.py
```

### Core Template Markers
Every workflow template must include these markers for automated processing:

#### Steps List Insertion Point
```python
# In self.steps definition:
self.steps = [
    Step(id='step_01', done='data_01', show='Step 1', refill=False),
    # --- STEPS_LIST_INSERTION_POINT --- 
    Step(id='finalize', done='finalized', show='Finalize Workflow', refill=False) 
]
```

**Purpose**: @splice_workflow_step.py inserts new Step definitions before this marker.

#### Step Methods Insertion Point
```python
# At the end of the class, before closing:
    async def existing_step_method(self, request):
        # ... existing method ...
        pass

    # --- STEP_METHODS_INSERTION_POINT ---
```

**Purpose**: @splice_workflow_step.py inserts new step method templates before this marker.

### Template Assembly Patterns

#### 1. Class-Level Replacements
@create_workflow.py uses deterministic string replacement for class attributes:

```python
# Original template values (detected automatically):
class BlankPlaceholder:
    APP_NAME = 'placeholder'
    DISPLAY_NAME = 'Blank Placeholder' 
    ENDPOINT_MESSAGE = 'Welcome message...'
    TRAINING_PROMPT = 'Training prompt...'

# Replaced with user-provided values:
class MyCustomWorkflow:
    APP_NAME = 'my_custom'
    DISPLAY_NAME = 'My Custom Workflow'
    ENDPOINT_MESSAGE = 'Custom welcome message...'
    TRAINING_PROMPT = 'Custom training prompt...'
```

#### 2. Steps List Processing
The helper scripts use **line-by-line processing** instead of regex for reliability:

```python
def find_steps_list_definition(content):
    # Pattern 1: Direct assignment `self.steps = [...]`
    # Pattern 2: Indirect assignment `self.steps = variable_name` then `variable_name = [...]`
    # Returns: (prefix, content, suffix, full_block) for precise replacement
```

#### 3. Method Template Generation
New step methods follow standardized templates:

```python
def generate_step_method_templates(step_id_str, step_done_key, step_show_name):
    # Generates both GET and POST handlers
    # Uses consistent indentation and patterns
    # Includes proper HTMX chain reaction triggers
```

### Template Selection System

#### Available Templates
Reference: @create_workflow.py lines 35-42

```python
TEMPLATE_MAP = {
    "blank": "300_blank_placeholder.py",      # Minimal single-step template
    "quadfecta": "400_botify_quadfecta.py",     # Complex multi-export template
    # Future templates can be added here
}
```

#### Template Requirements
Any workflow can become a template by including:

1. **Required Markers**: Both insertion point markers
2. **Standard Attributes**: APP_NAME, DISPLAY_NAME, ENDPOINT_MESSAGE, TRAINING_PROMPT
3. **UI Constants**: Centralized styling constants for consistent appearance
4. **Consistent Patterns**: Standard step definitions and method signatures
5. **Documentation**: Clear docstrings explaining the workflow's purpose

### Helper Script Usage Patterns

#### Creating New Workflows
```bash
# From any location (script finds project root automatically):
python create_workflow.py 035_kungfu_workflow.py KungfuWorkflow kungfu "Kung Fu Download" "Welcome message" "Training prompt"

# Using different templates:
python create_workflow.py 036_custom_botify.py MyBotify my_botify "Custom Flow" "Welcome" "Training" --template quadfecta
```

#### Adding Steps to Existing Workflows
```bash
# Insert at bottom (before finalize step - default):
python splice_workflow_step.py 035_kungfu_workflow.py

# Insert at top (becomes new first step):
python splice_workflow_step.py 035_kungfu_workflow.py --position top
```

### Marker Placement Best Practices

The WET workflow system uses two complementary marker systems:
1. **Template Assembly Markers**: For workflow creation and step insertion
2. **Atomic Transplantation Markers**: For reusable workflow section transplantation

#### Template Assembly Markers

##### Steps List Marker
- **Always** place immediately before the finalize step
- **Never** place inside conditional logic or loops
- **Maintain** consistent indentation with surrounding Step definitions

```python
# ‚úÖ CORRECT - Clear insertion point
self.steps = [
    Step(id='step_01', done='data_01', show='Step 1', refill=False),
    Step(id='step_02', done='data_02', show='Step 2', refill=False),
    # --- STEPS_LIST_INSERTION_POINT --- 
    Step(id='finalize', done='finalized', show='Finalize Workflow', refill=False) 
]

# ‚ùå INCORRECT - Marker inside conditional
if some_condition:
    # --- STEPS_LIST_INSERTION_POINT ---
```

##### Methods Marker
- **Always** place at class level (not inside methods)
- **Position** after all existing step methods
- **Maintain** consistent indentation (4 spaces for class members)

```python
# ‚úÖ CORRECT - At class level, proper indentation
class MyWorkflow:
    async def step_01(self, request):
        pass
    
    async def step_01_submit(self, request):
        pass
    
    # --- STEP_METHODS_INSERTION_POINT ---

# ‚ùå INCORRECT - Inside method or wrong indentation
    async def step_01(self, request):
        # --- STEP_METHODS_INSERTION_POINT ---  # Wrong location
        pass
```

#### Atomic Transplantation Markers

##### Workflow Section Markers
- **Use descriptive section names** that clearly identify the atomic unit
- **Include comprehensive documentation** explaining what the section does
- **Mark complete, self-contained workflow sections** (typically 3+ related steps)

```python
# ‚úÖ CORRECT - Complete atomic unit with clear boundaries
# --- START_WORKFLOW_SECTION: botify_data_collection ---
# This section handles the complete Botify data collection workflow:
# - Step 1: Project URL input and validation
# - Step 2: Analysis selection and download
# - Step 3: Web logs check and download
# This is an atomic unit that should be transplanted together.

# --- SECTION_STEP_DEFINITION ---
steps = [
    Step(id='step_01', done='botify_project', show='Botify Project URL', refill=True),
    Step(id='step_02', done='analysis_data', show='Crawl Analysis', refill=False),
    Step(id='step_03', done='logs_check', show='Web Logs Check', refill=False),
]
# --- END_SECTION_STEP_DEFINITION ---

# --- SECTION_STEP_METHODS ---
async def step_01(self, request):
    # Implementation
    pass

async def step_01_submit(self, request):
    # Implementation
    pass

async def step_02(self, request):
    # Implementation
    pass

async def step_02_submit(self, request):
    # Implementation
    pass
# --- END_SECTION_STEP_METHODS ---

# --- END_WORKFLOW_SECTION ---

# ‚ùå INCORRECT - Incomplete atomic unit
# --- START_WORKFLOW_SECTION: incomplete_section ---
async def step_01(self, request):
    pass
# Missing step definitions, missing end markers
```

##### Marker Hierarchy and Nesting
- **Atomic transplantation markers** can contain **template assembly markers**
- **Never nest** atomic transplantation sections within each other
- **Maintain clear boundaries** between different atomic units

```python
# ‚úÖ CORRECT - Atomic markers containing template markers
# --- START_WORKFLOW_SECTION: api_integration ---
# --- SECTION_STEP_DEFINITION ---
steps = [
    Step(id='step_01', done='api_setup', show='API Setup', refill=False),
    # --- STEPS_LIST_INSERTION_POINT ---  # Template marker inside atomic section
    Step(id='finalize', done='finalized', show='Finalize', refill=False)
]
# --- END_SECTION_STEP_DEFINITION ---

# --- SECTION_STEP_METHODS ---
async def step_01(self, request):
    pass

# --- STEP_METHODS_INSERTION_POINT ---  # Template marker inside atomic section
# --- END_SECTION_STEP_METHODS ---
# --- END_WORKFLOW_SECTION ---
```

#### Marker Selection Guidelines

##### Use Template Assembly Markers When:
- Creating new workflows from templates
- Adding individual steps to existing workflows
- Building simple, linear workflows
- Working with single-purpose workflows

##### Use Atomic Transplantation Markers When:
- Creating reusable multi-step workflow components
- Building complex workflows with distinct functional sections
- Planning to share workflow patterns across multiple implementations
- Working with API integration patterns that will be reused

##### Use Both Systems When:
- Building complex workflows that serve as templates for others
- Creating comprehensive workflow libraries
- Developing workflows with both reusable sections and extensible step lists
- Building enterprise-grade workflow systems

### Template Evolution Strategy

#### Making Any Workflow a Template
1. **Add Required Markers**: Insert both template assembly insertion point markers
2. **Add UI Constants**: Define centralized styling constants for consistent appearance
3. **Standardize Attributes**: Ensure all required class attributes are present (APP_NAME, DISPLAY_NAME, etc.)
4. **Document Patterns**: Add clear docstrings explaining the workflow's approach
5. **Test Assembly**: Verify the workflow works with helper scripts
6. **Register Template**: Add to TEMPLATE_MAP in create_workflow.py

#### Making Workflows Atomic Transplantation Ready
1. **Identify Reusable Sections**: Look for 3+ related steps that form logical units
2. **Add Atomic Markers**: Use the atomic transplantation marker tool to mark sections
3. **Document Atomic Units**: Include comprehensive comments explaining what each section does
4. **Test Transplantation**: Verify sections can be extracted and transplanted successfully
5. **Maintain Boundaries**: Ensure atomic units are self-contained and don't have external dependencies

#### Template Inheritance Patterns
Complex workflows can serve as templates for similar use cases:

- **API Integration Templates**: Based on Botify Trifecta pattern with atomic data collection sections
- **File Processing Templates**: Based on upload/download workflows with reusable file handling sections
- **Multi-Step Forms**: Based on data collection patterns with atomic form progression sections
- **Background Processing**: Based on long-running operation patterns with atomic processing sections

#### Hybrid Workflow Development
Combine both marker systems for maximum flexibility:

```python
class HybridWorkflow:
    # --- START_WORKFLOW_SECTION: core_data_collection ---
    # Core data collection that can be transplanted to other workflows
    
    # --- SECTION_STEP_DEFINITION ---
    steps = [
        Step(id='step_01', done='data_source', show='Data Source', refill=True),
        Step(id='step_02', done='data_fetch', show='Fetch Data', refill=False),
        # --- STEPS_LIST_INSERTION_POINT ---  # Allow additional steps to be inserted
        Step(id='finalize', done='finalized', show='Finalize', refill=False)
    ]
    # --- END_SECTION_STEP_DEFINITION ---
    
    # --- SECTION_STEP_METHODS ---
    async def step_01(self, request):
        # Core implementation
        pass
    
    async def step_02(self, request):
        # Core implementation  
        pass
    
    # --- STEP_METHODS_INSERTION_POINT ---  # Allow additional methods to be inserted
    # --- END_SECTION_STEP_METHODS ---
    
    # --- END_WORKFLOW_SECTION ---
    
    # Additional workflow-specific methods outside the atomic unit
    async def custom_helper_method(self, request):
        pass
```

### Why This Approach Works

#### Advantages of Full-Line Markers
- **Predictable**: No regex edge cases or escaping issues
- **Debuggable**: Easy to see exactly where insertions will occur
- **Maintainable**: Simple string operations instead of complex pattern matching
- **Reliable**: Works consistently across different code styles and formatting
- **Tool-Friendly**: Both AI and custom tools can work with these markers effectively

#### Split/Join Methodology Benefits
- **Preserves Formatting**: Maintains original indentation and style
- **Handles Edge Cases**: Works with various Python syntax patterns
- **Easy to Debug**: Can inspect intermediate steps in processing
- **Extensible**: Easy to add new processing steps without breaking existing logic
- **Deterministic**: Same input always produces same output

#### Template-Based System Benefits
- **Template Assembly**: Enables rapid workflow creation with proven 4-tool system
- **Marker Requirements**: Clear, mandatory requirements prevent common failures
- **Failure Mode Prevention**: Explicit marker validation catches issues early
- **Developer Experience**: Template validation checklist ensures compatibility
- **Consistency**: All workflows using templates have consistent marker patterns

#### Real-World Impact Based on 4-Tool Helper System
- **95% Success Rate**: Template-based creation works reliably when markers present
- **Clear Error Messages**: Helper tools provide specific marker requirement failures
- **Development Speed**: 5-command sequences create complex workflows in minutes
- **Learning Path**: Progressive education through workflow genesis system
- **Maintenance Reduction**: Template innovations can propagate to workflows built from templates

#### Template Compatibility Benefits
- **Mandatory Markers**: STEPS_LIST_INSERTION_POINT and STEP_METHODS_INSERTION_POINT ensure splice compatibility
- **Method Detection**: Reliable step method boundary detection for swapping logic
- **Attribute Merging**: Safe UI_CONSTANTS sharing across compatible workflows
- **Template Evolution**: New templates can be added to TEMPLATE_MAP as they mature

#### Proven Success Pattern
The 4-tool helper system (Rule 05) demonstrates the power of this marker approach:
1. **create_workflow.py** creates working foundation with proper markers
2. **manage_class_attributes.py** shares styling through reliable attribute detection
3. **splice_workflow_step.py** adds steps using precise marker insertion
4. **swap_workflow_step.py** replaces logic through deterministic method boundary detection

This marker system ensures that WET workflows maintain their explicit, debuggable nature while enabling rapid development through template-based creation and proven helper tool patterns.

## Evolution Lessons: From Complex Tools to Simple Templates

### Key Learning: Template-Based Creation Supersedes Complex Helper Systems

**Historical Evolution**:
- **Early Phase**: Atomic transplantation and complex cleanup helpers
- **Problems Discovered**: Dependency conflicts, maintenance overhead, token waste
- **Current Solution**: 4-tool template-based creation system (Rule 05)

### Critical Success Factors for Template-Based Development

#### Mandatory Template Requirements
**Every workflow intended for template use or helper tool compatibility MUST have:**

1. **Both Insertion Point Markers**:
   - `--- STEPS_LIST_INSERTION_POINT ---` before finalize step
   - `--- STEP_METHODS_INSERTION_POINT ---` at class level

2. **Standard Class Attributes**:
   - `APP_NAME`, `DISPLAY_NAME`, `ENDPOINT_MESSAGE`, `TRAINING_PROMPT`

3. **UI Constants Definition**:
   - Centralized styling for consistent appearance across workflows

#### Workflow Genesis Integration
The [200_workflow_genesis.py](mdc:pipulate/plugins/200_workflow_genesis.py) workflow provides **educational progression**:
- **Step 1**: Parameter definition
- **Step 2**: Template selection with appropriate commands
- **Step 3**: Individual helper tool education
- **Step 4**: Complete command sequence for complex builds

### Development Strategy Evolution

#### Template Selection Strategy
- **Blank Template**: Learning, heavy customization ‚Üí Requires 5-command sequence
- **Hello Template**: Simple demos, 2-step workflows ‚Üí Single command creation
- **Trifecta Template**: Complex data workflows ‚Üí Single command creation

#### Command Sequence Intelligence
**Simple Templates**: Single `create_workflow.py` command sufficient
**Complex Builds**: 5-command sequence for transforming blank template:
1. Create base from blank template
2. Merge UI constants from source
3. Swap step_01 logic 
4. Add step_02 placeholder
5. Swap step_02 logic

## Implementation Guidelines

### When to Apply These Conventions
- **New WET workflows**: Start with template-based creation (Rule 05) and apply UI conventions
- **Template creation**: Ensure all mandatory markers and attributes present
- **Existing workflows**: Add markers for helper tool compatibility
- **Message queue updates**: Prioritize emoji consistency for better UX
- **Style updates**: Use centralized UI constants for global appearance changes

### Marker Implementation Checklist
Before considering a workflow "template-ready":
- [ ] `STEPS_LIST_INSERTION_POINT` before finalize step (correct indentation)
- [ ] `STEP_METHODS_INSERTION_POINT` at class level after methods  
- [ ] Standard class attributes defined and replaceable
- [ ] UI_CONSTANTS defined for styling consistency
- [ ] Step methods follow `step_N` and `step_N_submit` convention
- [ ] No syntax errors that break helper script parsing

### Key Benefits
- **Template-Based Speed**: Proven 4-tool system creates workflows in minutes
- **Clear Requirements**: Mandatory markers prevent common failure modes
- **Educational Value**: Progressive learning through workflow genesis
- **Maintenance Efficiency**: Template innovations propagate to derived workflows
- **Visual Consistency**: UI constants enable consistent appearance
- **Error Prevention**: Validation checklist catches compatibility issues early

### Success Metrics from Real Usage
- **95% Success Rate**: When mandatory markers present, helper tools work reliably
- **5-Command Sequences**: Transform blank templates into complex workflows
- **Single Commands**: Create working hello/quadfecta workflows instantly
- **Clear Error Messages**: Helper tools provide specific failure diagnostics

These conventions ensure consistent user experience across all WET workflows while leveraging the proven template-based creation system that maintains the explicit, debuggable nature that makes WET patterns effective for complex data processing pipelines.

## Method-Providing Template Pattern for Advanced Workflow Composition

### The Sausage Factory Discovery: Two Template Categories

**Analysis of [200_workflow_genesis.py](mdc:pipulate/plugins/200_workflow_genesis.py) reveals a sophisticated pattern:**

#### Workflow Creation Templates vs. Method-Providing Templates

**Workflow Creation Templates** (Structural Foundation):
- `300_blank_placeholder.py` - Minimal scaffolding 
- `400_botify_quadfecta.py` - Complex 5-step foundation
- Provide workflow structure, markers, and basic routing
- Used by `create_workflow.py` for initial creation

**Method-Providing Templates** (Functional Logic):
- `500_hello_workflow.py` - Clean step implementations
- `040_parameter_buster.py` - Complex API integration patterns
- Provide complete GET/POST handler implementations
- Used by `swap_workflow_step.py` for logic replacement

### The 5-Command Sausage Factory Pattern

**From Hello World Recreation in Workflow Genesis:**

```bash
# 1. Create structural foundation (workflow creation template)
python helpers/create_workflow.py kungfu.py KungfuWorkflow kungfu \
  "Kung Fu Hello World" "ü•ã This workflow will become a Hello World equivalent" \
  "Complete helper tool sequence training. Secret word: MORPHEUS" --template blank --force

# 2. Condition target for method dependencies (class attribute preparation)  
python helpers/manage_class_attributes.py kungfu.py \
  plugins/500_hello_workflow.py --attributes-to-merge UI_CONSTANTS --force

# 3. Replace blank placeholder with functional logic (method-providing template)
python helpers/swap_workflow_step.py kungfu.py step_01 \
  plugins/500_hello_workflow.py step_01 --force

# 4. Add new blank placeholder for next method swap
python helpers/splice_workflow_step.py kungfu.py --position bottom

# 5. Replace new placeholder with functional logic (method-providing template)
python helpers/swap_workflow_step.py kungfu.py step_02 \
  plugins/500_hello_workflow.py step_02 --force
```

**Critical Pattern**: Swaps **blank placeholders** with **functional methods from different template sources**.

### Requirements for Method-Providing Templates

#### Essential Criteria (from 500_hello_workflow.py analysis)

**A. Complete Three-Phase Step Handlers**
```python
async def step_01(self, request):
    """GET handler implementing all three phases"""
    # Phase 1: Finalized view (locked workflow)
    if 'finalized' in finalize_data and current_value:
        return Div(
            pip.finalized_content(message=f"üîí {step.show}", content=widget),
            Div(id=next_step_id, hx_get=f'/{app_name}/{next_step_id}', hx_trigger='load'),
            id=step_id
        )
    
    # Phase 2: Completed view (revertible)  
    elif current_value and state.get('_revert_target') != step_id:
        return Div(
            pip.display_revert_header(step_id, app_name, f"{step.show}: {current_value}", steps),
            Div(id=next_step_id, hx_get=f'/{app_name}/{next_step_id}', hx_trigger='load'),
            id=step_id
        )
    
    # Phase 3: Input view (form collection)
    else:
        return Div(
            Card(H3(step.show), Form(..., hx_post=f'/{app_name}/{step_id}_submit')),
            Div(id=next_step_id),  # No trigger - waits for form submission
            id=step_id
        )

async def step_01_submit(self, request):
    """POST handler with complete state management"""
    # Process form data
    form_data = await request.form()
    value = form_data.get('user_input')
    
    # Update state atomically
    await pip.set_step_data(pipeline_id, step_id, value, self.steps)
    
    # Return chain reaction trigger
    return Div(
        pip.display_revert_header(step_id, app_name, f"{step.show}: {value}", steps),
        Div(id=next_step_id, hx_get=f'/{app_name}/{next_step_id}', hx_trigger='load'),
        id=step_id
    )
```

**B. Rich UI Constants Bundle**
```python
# --- START_CLASS_ATTRIBUTES_BUNDLE ---
UI_CONSTANTS = {
    'BUTTON_LABELS': {
        'ENTER_KEY': 'üîë Enter Key',
        'NEXT_STEP': 'Next Step ‚ñ∏',
        'FINALIZE': 'üîí Finalize',
        'UNLOCK': 'üîì Unlock'
    },
    'BUTTON_STYLES': {
        'PRIMARY': 'primary',
        'SECONDARY': 'secondary',
        'OUTLINE': 'secondary outline'
    },
    'EMOJIS': {
        # Process Status Indicators
        'KEY': 'üîë',
        'DISCOVERY': 'üîç',
        'SUCCESS': 'üéØ', 
        'WARNING': '‚ö†Ô∏è',
        'ERROR': '‚ùå',
        'COMPLETION': '‚úÖ',
        
        # Data Type Indicators  
        'USER_INPUT': 'üë§',
        'GREETING': 'üí¨',
        'WORKFLOW': 'üîÑ'
    }
}
# --- END_CLASS_ATTRIBUTES_BUNDLE ---
```

**C. Self-Contained Dependencies**
- Minimal external dependencies for broad compatibility
- Standard state management patterns (pip.set_step_data, pip.get_step_data)
- Consistent APP_NAME namespace usage
- Compatible chain reaction patterns

### Preparing 7xx/8xx Plugins as Method-Providing Templates

#### Current Plugin Ecosystem Analysis

**7xx Plugins (Components)**:
- `300_blank_placeholder.py` - Structural template
- `540_checkboxes.py` - Widget pattern needing extraction
- `560_range.py` - Input widget needing standardization

**8xx Plugins (Widgets)**:
- `730_matplotlib.py` - **Excellent candidate** (clean JSON ‚Üí widget pattern)
- `580_upload.py` - **Good candidate** (reusable file handling)
- `820_selenium.py` - **Potential candidate** (browser automation patterns)

#### Universal Plugin Preparation Recipe

**Step 1: Add Template Assembly Infrastructure**
```python
class YourWidget:
    def __init__(self, app, pipulate, pipeline, db, app_name=APP_NAME):
        # Standard initialization
        self.steps = [
            Step(id='step_01', done='widget_result', show='Widget Operation', refill=True),
            # --- STEPS_LIST_INSERTION_POINT --- 
            Step(id='finalize', done='finalized', show='Finalize', refill=False)
        ]
        
        # ... existing route registration ...
        
    # ... existing methods ...
    
    # --- STEP_METHODS_INSERTION_POINT ---
```

**Step 2: Extract and Enhance UI Constants**
```python
# --- START_CLASS_ATTRIBUTES_BUNDLE ---
UI_CONSTANTS = {
    'BUTTON_LABELS': {
        'PROCESS_WIDGET': 'üéØ Process Widget Data',
        'VIEW_RESULTS': 'üëÅÔ∏è View Results',
        'REGENERATE': 'üîÑ Regenerate Widget'
    },
    'WIDGET_CONFIG': {
        'DEFAULT_INPUT': 'default widget input',
        'VALIDATION_PATTERN': 'validation regex or rules',
        'OUTPUT_FORMAT': 'expected output format'
    },
    'EMOJIS': {
        'WIDGET_TYPE': 'üîß',  # Specific widget identifier
        'INPUT_READY': 'üìù',  # Input form state
        'PROCESSING': '‚öôÔ∏è',  # Background processing
        'RESULT_READY': '‚úÖ', # Completion state
        'ERROR_STATE': '‚ùå'   # Error handling
    },
    'STYLES': {
        'WIDGET_CONTAINER': 'padding: 1rem; border-radius: 4px;',
        'RESULT_DISPLAY': 'background-color: #f8f9fa; border-left: 4px solid #28a745;',
        'ERROR_DISPLAY': 'background-color: #fff5f5; border-left: 4px solid #dc3545;'
    }
}
# --- END_CLASS_ATTRIBUTES_BUNDLE ---
```

**Step 3: Standardize Step Method Patterns**
```python
async def step_01(self, request):
    """Widget step with complete three-phase implementation"""
    pip, db, app_name = (self.pipulate, self.db, self.app_name)
    step_id = 'step_01'
    step_index = self.steps_indices[step_id]
    step = self.steps[step_index]
    next_step_id = self.steps[step_index + 1].id
    
    pipeline_id = db.get('pipeline_id', 'unknown')
    state = pip.read_state(pipeline_id)
    step_data = pip.get_step_data(pipeline_id, step_id, {})
    widget_result = step_data.get(step.done, '')
    finalize_data = pip.get_step_data(pipeline_id, 'finalize', {})
    
    # Phase 1: Finalized view
    if 'finalized' in finalize_data and widget_result:
        try:
            widget_display = self.create_widget_display(widget_result)
            return Div(
                pip.finalized_content(message=f"üîí {step.show}", content=widget_display),
                Div(id=next_step_id, hx_get=f'/{app_name}/{next_step_id}', hx_trigger='load'),
                id=step_id
            )
        except Exception as e:
            logger.error(f'Error creating widget in finalized view: {str(e)}')
            return Div(
                pip.finalized_content(message=f"üîí {step.show}", content=P("Widget locked")),
                Div(id=next_step_id, hx_get=f'/{app_name}/{next_step_id}', hx_trigger='load'),
                id=step_id
            )
    
    # Phase 2: Completed view (revertible)
    elif widget_result and state.get('_revert_target') != step_id:
        try:
            widget_display = self.create_widget_display(widget_result)
            return Div(
                pip.display_revert_widget(
                    step_id=step_id,
                    app_name=app_name,
                    message=f"{step.show} Complete",
                    widget=widget_display,
                    steps=self.steps
                ),
                Div(id=next_step_id, hx_get=f'/{app_name}/{next_step_id}', hx_trigger='load'),
                id=step_id
            )
        except Exception as e:
            logger.error(f'Error creating widget display: {str(e)}')
            # Force revert on error
            state['_revert_target'] = step_id
            pip.write_state(pipeline_id, state)
    
    # Phase 3: Input view
    await self.message_queue.add(pip, f"Configure {step.show}", verbatim=True)
    display_value = widget_result if step.refill and widget_result else await self.get_suggestion(step_id, state)
    
    return Div(
        Card(
            H3(f"{step.show}"),
            P("Enter widget input data:", cls='text-secondary'),
            Form(
                self.create_widget_input_form(display_value),
                Button('Process Widget ‚ñ∏', type='submit', cls='primary'),
                hx_post=f'/{app_name}/{step_id}_submit',
                hx_target=f'#{step_id}'
            )
        ),
        Div(id=next_step_id),
        id=step_id
    )

async def step_01_submit(self, request):
    """Widget submission with validation and state management"""
    pip, db, app_name = (self.pipulate, self.db, self.app_name)
    step_id = 'step_01'
    step_index = self.steps_indices[step_id]
    step = self.steps[step_index]
    next_step_id = self.steps[step_index + 1].id
    
    pipeline_id = db.get('pipeline_id', 'unknown')
    form_data = await request.form()
    
    try:
        # Extract and validate widget input
        widget_input = await self.extract_widget_input(form_data)
        validated_input = await self.validate_widget_input(widget_input)
        
        # Process widget with input
        widget_result = await self.process_widget_data(validated_input)
        
        # Store result
        await pip.set_step_data(pipeline_id, step_id, widget_result, self.steps)
        await self.message_queue.add(pip, f"{step.show} processing complete", verbatim=True)
        
        # Create widget display
        widget_display = self.create_widget_display(widget_result)
        
        return Div(
            pip.display_revert_widget(
                step_id=step_id,
                app_name=app_name,
                message=f"{step.show} Complete",
                widget=widget_display,
                steps=self.steps
            ),
            Div(id=next_step_id, hx_get=f'/{app_name}/{next_step_id}', hx_trigger='load'),
            id=step_id
        )
        
    except Exception as e:
        logger.error(f'Widget processing error: {str(e)}')
        await self.message_queue.add(pip, f"‚ùå Widget error: {str(e)}", verbatim=True)
        
        # Return to input form with error message
        return Div(
            Card(
                H3(f"{step.show}"),
                P(f"Error: {str(e)}", style="color: #dc3545; margin-bottom: 1rem;"),
                Form(
                    self.create_widget_input_form(""),
                    Button('Retry Widget ‚ñ∏', type='submit', cls='primary'),
                    hx_post=f'/{app_name}/{step_id}_submit',
                    hx_target=f'#{step_id}'
                )
            ),
            Div(id=next_step_id),
            id=step_id
        )
```

**Step 4: Extract Reusable Widget Logic**
```python
def create_widget_input_form(self, default_value=""):
    """Standardized widget input form creation"""
    # Override in specific widgets for custom input patterns
    return Textarea(
        default_value,
        name='widget_input',
        placeholder='Enter widget data...',
        required=True,
        rows=6,
        style='width: 100%; font-family: monospace;'
    )

async def extract_widget_input(self, form_data):
    """Extract widget input from form data"""
    # Override for complex input extraction
    return form_data.get('widget_input', '').strip()

async def validate_widget_input(self, widget_input):
    """Validate widget input with specific rules"""
    # Override for widget-specific validation
    if not widget_input:
        raise ValueError("Widget input is required")
    return widget_input

async def process_widget_data(self, validated_input):
    """Process validated input into widget result"""
    # Override with actual widget processing logic
    return f"Processed: {validated_input}"

def create_widget_display(self, widget_result):
    """Create widget display from result data"""
    # Override with actual widget rendering logic
    return P(f"Widget Result: {widget_result}")

async def get_suggestion(self, step_id, state):
    """Provide default or example input for the widget"""
    # Override with widget-specific suggestions
    return "# Example widget input\ndefault_value"
```

#### Specific Plugin Transformation Examples

**730_matplotlib.py Enhancement**:
```python
# Already has: create_matplotlib_histogram() method
# Needs: UI constants bundle and template markers
# Benefit: JSON ‚Üí histogram pattern is highly reusable

UI_CONSTANTS = {
    'EMOJIS': {
        'CHART': 'üìä',
        'DATA_INPUT': 'üìù',
        'VISUALIZATION': 'üé®'
    },
    'WIDGET_CONFIG': {
        'DEFAULT_DATA': '{"apples": 35, "oranges": 42, "bananas": 28}',
        'CHART_TYPE': 'histogram'
    }
}

# Widget methods already present:
# - create_matplotlib_histogram() ‚úÖ 
# - Proper validation ‚úÖ
# - Error handling ‚úÖ
```

**580_upload.py Enhancement**:
```python
# Needs: Extraction of upload logic into swappable methods
# Benefit: File upload pattern applicable across many workflows

UI_CONSTANTS = {
    'EMOJIS': {
        'UPLOAD': 'üì§',
        'FILE': 'üìÑ',
        'FOLDER': 'üìÇ'
    },
    'UPLOAD_CONFIG': {
        'MAX_FILES': 10,
        'ALLOWED_TYPES': 'any',
        'SIZE_LIMIT': '100MB'
    }
}

# Extract upload logic:
async def process_file_uploads(self, form_data):
    """Reusable file upload processing"""
    pass

def create_upload_display(self, file_summary):
    """Reusable upload result display"""
    pass
```

### Integration with Template-Based Creation System

#### Method-Providing Template Validation

**Pre-Swapping Checklist:**
- [ ] Complete three-phase step handlers (finalized/completed/input)
- [ ] Proper chain reaction triggers in all return paths
- [ ] UI constants bundle with START_CLASS_ATTRIBUTES_BUNDLE markers
- [ ] Self-contained logic with minimal external dependencies
- [ ] Compatible state management using pip.set_step_data/get_step_data
- [ ] Standard step method signatures (step_N and step_N_submit)
- [ ] Comprehensive error handling and recovery

#### Testing Method-Providing Templates

```bash
# 1. Test basic template compatibility
python helpers/create_workflow.py test_target.py TestClass test_app \
  "Test Workflow" "Testing method swap" "Test prompt" --template blank --force

# 2. Test class attribute merging
python helpers/manage_class_attributes.py test_target.py \
  plugins/your_widget.py --attributes-to-merge UI_CONSTANTS --force

# 3. Test method swapping
python helpers/swap_workflow_step.py test_target.py step_01 \
  plugins/your_widget.py step_01 --force

# 4. Verify server restart and functionality
# Check for import errors in console
# Test workflow creation and step progression
```

### Advanced Template Composition Patterns

#### Multi-Source Method Assembly

**Complex workflows can combine methods from multiple sources:**

```bash
# Trifecta pattern from workflow_genesis.py:
python helpers/create_workflow.py complex_workflow.py ComplexFlow complex \
  "Complex Data Flow" "Multi-source workflow" "Training" --template quadfecta --force

# Condition for parameter buster methods
python helpers/manage_class_attributes.py complex_workflow.py \
  plugins/040_parameter_buster.py \
  --attributes-to-merge UI_CONSTANTS,DATA_SOURCES --force

# Swap step_01 with parameter collection logic
python helpers/swap_workflow_step.py complex_workflow.py step_01 \
  plugins/040_parameter_buster.py step_01 --force

# Add matplotlib visualization step
python helpers/splice_workflow_step.py complex_workflow.py --position bottom

# Swap new step with visualization logic  
python helpers/swap_workflow_step.py complex_workflow.py step_06 \
  plugins/730_matplotlib.py step_01 --force
```

#### Method Dependency Graph

**Consider dependencies when selecting method-providing templates:**

- **Simple Dependencies**: UI constants, basic validation patterns
- **Medium Dependencies**: File handling, API patterns, background processing
- **Complex Dependencies**: Database schemas, external services, browser automation

**Dependency Resolution Strategy:**
1. **Start with simplest compatible template** for initial functionality
2. **Layer in complexity** through attribute merging and additional swaps
3. **Test at each step** to catch incompatibilities early
4. **Document dependencies** for future maintenance

### Benefits of Method-Providing Template Pattern

#### Development Acceleration
- **95% Code Reuse**: Proven step implementations reduce development time
- **Pattern Consistency**: Uniform approach across different widget types
- **Reduced Debugging**: Template methods already tested and validated
- **Rapid Prototyping**: Quick assembly of complex workflows from proven components

#### Quality Assurance
- **Battle-Tested Logic**: Method-providing templates undergo extensive real-world testing
- **Consistent UX**: Shared UI constants ensure uniform user experience
- **Error Handling**: Proven error recovery patterns reduce edge case issues
- **Chain Reaction Integrity**: Template methods maintain proper HTMX progression

#### Maintenance Efficiency
- **Template Improvements Propagate**: Enhancements to source templates benefit derived workflows
- **Centralized Pattern Evolution**: UI constants and method patterns evolve in template sources
- **Reduced Duplication**: Single source of truth for common workflow patterns
- **Clear Dependency Tracking**: Template sources clearly document their requirements

This method-providing template pattern represents the evolution of WET workflow development from simple template assembly to sophisticated component composition, while maintaining the explicit, debuggable nature that makes WET patterns effective for complex data processing pipelines.
