---
description: 
globs: 
alwaysApply: false
---
# LLM Context Synchronization Pattern

This rule ensures the LLM maintains awareness of what users see in the UI, enabling more contextual responses.

## Core Principle
The LLM should be "seeing" everything the user sees, plus relevant behind-the-scenes context. This is achieved by inserting UI text and state changes into the conversation history using the Pipulate helper method.

## Implementation in [plugins/020_hello_workflow.py](mdc:plugins/020_hello_workflow.py)

### Key Methods for Context Sync

1. **Message Queue Updates**
   - Use `message_queue.add()` for user-visible messages
   - Always follow with `pip.append_to_history()` to sync LLM context
   ```python
   await self.message_queue.add(pip, message, verbatim=True)
   pip.append_to_history(message)
   ```

2. **UI Text Elements**
   - When showing explanatory text (P tags), sync to LLM:
   ```python
   P_text = "Explanation shown to user..."
   pip.append_to_history(P_text)
   return P(P_text, style=pip.get_style("muted"))
   ```

3. **State Changes**
   - When workflow state changes (finalize, unfinalize, revert):
   ```python
   state_msg = f"Workflow is now {new_state}"
   pip.append_to_history(state_msg)
   ```

4. **Validation & Errors**
   - Sync validation messages to LLM context:
   ```python
   is_valid, error_msg, error_component = pip.validate_step_input(...)
   if not is_valid:
       error_context = f"Validation failed: {error_msg}"
       pip.append_to_history(error_context)
   ```

## Using the Pipulate Helper

The `append_to_history` method is the preferred way to update LLM context:

```python
def append_to_history(self, message: str, role: str = "system", quiet: bool = True) -> None:
    """Add a message to the LLM conversation history without triggering a response.
    
    This is the preferred way for workflows to update the LLM's context about:
    - UI state changes
    - Form submissions
    - Validation results
    - Explanatory text shown to users
    - Step completion status
    """
```

## Best Practices

1. Always use `pip.append_to_history()` instead of direct conversation manipulation
2. Keep messages concise and descriptive
3. Include both user-visible text and relevant context
4. Sync messages before returning UI components
5. Use the method's default parameters (`role="system", quiet=True`) for most cases

## Common Sync Points

- Landing page loads
- Step transitions
- Form submissions
- Validation results
- State changes (finalize/unfinalize)
- Error messages
- Help text display
- Generated suggestions

## Example Workflow

```python
# 1. Show empty form
form_msg = "Showing name input form. No name has been entered yet."
pip.append_to_history(form_msg)

# 2. User submits form
submit_msg = f"User submitted name: {user_val}"
pip.append_to_history(submit_msg)

# 3. Validation result
if not is_valid:
    error_context = f"Name validation failed: {error_msg}"
    pip.append_to_history(error_context)
    return error_component

# 4. Success confirmation
confirm_msg = f"{step.show}: {processed_val}"
await self.message_queue.add(pip, confirm_msg, verbatim=True)
pip.append_to_history(confirm_msg)
```

This pattern ensures the LLM can provide relevant help by maintaining awareness of the user's current context in the workflow. By using the Pipulate helper method, we maintain consistent conversation history management across all workflows.
