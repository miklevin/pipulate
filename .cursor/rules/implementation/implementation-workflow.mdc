---
description: 
globs: 
alwaysApply: false
---
# Workflow Implementation Guide

## Workflow Structure

Every Pipulate workflow follows this basic structure:

```python
class MyWorkflow:
    APP_NAME = "unique_identifier"    # Unique ID used in database
    DISPLAY_NAME = "User-Facing Name" # Shown in navigation menu
    ENDPOINT_MESSAGE = "Description"  # User guidance
    TRAINING_PROMPT = "prompt.md"     # Training file if using AI

    def __init__(self, pipulate, db, pipeline, rt):
        self.pipulate, self.db, self.pipeline = pipulate, db, pipeline
        self.message_queue = MessageQueue()
        
        # Define steps
        Step = namedtuple('Step', ['id', 'done', 'show', 'refill', 'transform'])
        self.steps = [
            Step(id='step_01', done='field_name', show='Step 1', refill=True),
            Step(id='step_02', done='field_name_2', show='Step 2', refill=True),
            # More steps...
        ]
        
        # Index steps for quick lookup
        self.steps_indices = {step.id: i for i, step in enumerate(self.steps)}
        
        # Register routes
        self.register_routes(rt)
```

## Required Methods

Every workflow must implement these methods:

1. **landing**: Initial page display
2. **init**: Workflow initialization (creates pipeline record)
3. **step_XX**: GET handler for each step
4. **step_XX_submit**: POST handler for each step's form submission
5. **finalize/unfinalize**: Marks workflow as complete/reopens it
6. **handle_revert**: Logic for reverting to a previous step

## Development Workflow

1. **Start with Placeholder**: Create the basic workflow class with minimal steps
2. **Test Progression**: Ensure chain reaction works between landing → step_01 → finalize
3. **Add Steps Incrementally**: Add one step at a time, testing the chain reaction after each addition
4. **Refine Form Logic**: Enhance each step with proper input validation and state management
5. **Add Step Guidance**: Fill in user instructions and suggestions

## Naming and Menu Position

- File naming determines menu position and public route:
  - `10_my_workflow.py` → Menu position 10, route: `/my_workflow`
- Development workflow:
  1. Start with `my_workflow (Copy).py` (won't register due to parentheses)
  2. Rename to `xx_my_workflow.py` for testing (won't register due to `xx_` prefix)
  3. Finalize as `NN_my_workflow.py` to activate (where `NN` is the menu position number)

## State Management

Track workflow state through these methods:

```python
# Read workflow state
pipeline_id = db.get("pipeline_id", "unknown")
state = pip.read_state(pipeline_id)
step_data = pip.get_step_data(pipeline_id, step_id, {})

# Update state
state[step.done] = user_input
pip.write_state(pipeline_id, state)
await pip.update_step_state(pipeline_id, step_id, user_input, steps)
```

## Data Transformation Between Steps

To pass data between steps, use the `transform` function in step definition:

```python
Step(
    id='step_02',
    done='processed_data',
    show='Process Data',
    refill=True,
    transform=lambda raw_data: process_function(raw_data)
)
```

## User Notifications

Send messages to the user about progress:

```python
await self.message_queue.add(
    pip,
    f"{step.show} complete: {value}",
    verbatim=True,
    spaces_before=0,
    spaces_after=1
)
```

## Error Handling

Use consistent error presentation:

```python
try:
    # Operation
except Exception as e:
    return P(f"Error: {str(e)}", style=pip.get_style("error"))
```

## Best Practices

1. **Keep Steps Focused**: Each step should do one thing well
2. **Provide Clear Instructions**: Always include user guidance
3. **Validate All Inputs**: Check user inputs before processing
4. **Preserve Chain Reaction**: Always maintain the proper progression pattern
5. **Document Step Dependencies**: If steps depend on previous outputs, document it
6. **Use Revert Controls**: Always add revert controls for better user experience
