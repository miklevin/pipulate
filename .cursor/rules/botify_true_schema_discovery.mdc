---
description: 
globs: 
alwaysApply: false
---
# Botify True Schema Discovery System

## Overview

The Botify True Schema Discovery system uses official Botify API endpoints to discover the complete data schema, providing comprehensive field and collection information for building robust Botify integrations in Pipulate workflows.

## Core Discovery Script

**Primary Tool**: [true_schema_discoverer.py](mdc:pipulate/helpers/botify/true_schema_discoverer.py)

This script uses official Botify endpoints for real schema discovery:
- `/analyses/{username}/{project_slug}/{analysis_slug}/urls/datamodel` - Complete datamodel schema
- `/analyses/{username}/{project_slug}/{analysis_slug}/urls/datasets` - Available datasets with field information

## Proven Results vs. Alternative Approaches

**True Schema Discovery (Winner)**:
- **4,449 Fields** discovered across 10 categories
- **100 Collections** found
- **5.9MB** comprehensive schema data
- Uses official API endpoints for guaranteed accuracy

**Previous Field Testing Approach (Removed)**:
- Only 18 fields found by testing predefined field names
- 2 collections discovered
- 247x less comprehensive than true discovery
- Prone to missing new fields and collections

## Key Implementation Insights

### Official Endpoint Usage
```python
# Datamodel endpoint - complete schema structure
url = f"{self.base_url}/urls/datamodel"
response = await client.get(url, headers=self.headers)

# Datasets endpoint - field definitions with deprecated_fields=True
url = f"{self.base_url}/urls/datasets"
params = {"deprecated_fields": True}
response = await client.get(url, headers=self.headers, params=params)
```

### Field Categorization System
The discovery system automatically categorizes fields into logical groups:
- **URL Structure** (404 fields): url, domain, path, query parameters
- **HTTP Response** (273 fields): status codes, redirects, response headers
- **Metadata** (108 fields): title, description, h1, h2, meta tags
- **Content** (199 fields): body text, word count, content analysis
- **Linking** (319 fields): internal/external links, link analysis
- **Performance** (24 fields): load time, first byte, speed metrics
- **Crawling** (404 fields): crawl compliance, depth, visit data
- **Search Console** (243 fields): impressions, clicks, CTR, position
- **Analytics** (1,584 fields): user behavior, sessions, pageviews
- **Technical SEO** (49 fields): sitemaps, robots, canonical
- **Other** (1,053 fields): specialized and emerging fields

### Output File Structure
The discovery generates three key files in the script directory:
- `{project}_{analysis}_true_schema_discovery.json` - Complete discovery results
- `{project}_{analysis}_discovered_collections.csv` - Collection summary
- `{project}_{analysis}_discovered_fields.csv` - Field catalog with categories

## Integration with Pipulate Workflows

### Template Integration Pattern
For workflows like [400_botify_quadfecta.py](mdc:pipulate/plugins/400_botify_quadfecta.py), the discovery results can inform:

**Query Template Enhancement**:
```python
# Use discovered fields to build comprehensive query templates
QUERY_TEMPLATES = {
    'Advanced Crawl': {
        'dimensions': [
            # Fields discovered through true schema discovery
            '{collection}.url',
            '{collection}.http_code', 
            '{collection}.metadata.title.content',
            '{collection}.compliant.is_compliant',
            # ... more fields from discovery results
        ]
    }
}
```

**Dynamic Field Selection**:
- Load discovered fields from CSV for user selection
- Validate field availability before query execution
- Provide field descriptions and categories for better UX

### Workflow Step Integration
The true schema discovery can become a workflow step:
1. **Schema Discovery Step**: Run discovery and cache results
2. **Field Selection Step**: Present categorized fields for user selection
3. **Query Building Step**: Build BQL queries with selected fields
4. **Data Export Step**: Execute queries with validated field sets

## Configuration Requirements

### Required Files
- `botify_token.txt` - API authentication token
- `config.json` - Project configuration:
  ```json
  {
    "org": "organization-slug",
    "project": "project-slug", 
    "analysis": "analysis-slug"
  }
  ```

### Dependencies
- `httpx` - Async HTTP client for API calls
- `pandas` - Data processing and CSV export
- `pathlib` - File path management

## Best Practices

### Discovery Execution
- Run discovery once per analysis and cache results
- Use `deprecated_fields=True` parameter for complete schema
- Handle API errors gracefully with fallback behavior
- Save results in script directory for easy access

### Field Usage
- Always validate field existence before using in queries
- Use categorization to help users find relevant fields
- Consider field deprecation status when building queries
- Test queries with small datasets before full exports

### Performance Considerations
- Discovery is a one-time operation per analysis
- Cache results to avoid repeated API calls
- Use async operations for better performance
- Implement proper timeout handling for large schemas

## Error Handling Patterns

### API Error Recovery
```python
try:
    response = await client.get(url, headers=self.headers)
    if response.status_code == 200:
        return response.json()
    else:
        print(f"API request failed: {response.status_code}")
        return {}
except Exception as e:
    print(f"Discovery error: {e}")
    return {}
```

### Schema Parsing Resilience
- Handle varying schema structures gracefully
- Use recursive exploration with depth limits
- Provide fallback categorization for unknown field types
- Log parsing issues for debugging

## Future Enhancement Opportunities

### Advanced Features
- **Field Relationship Mapping**: Discover which fields work together
- **Query Optimization**: Suggest optimal field combinations
- **Schema Versioning**: Track schema changes over time
- **Field Usage Analytics**: Track which fields are most valuable

### Workflow Integration
- **Interactive Field Browser**: UI for exploring discovered schema
- **Query Builder**: Visual query construction using discovered fields
- **Template Generator**: Auto-generate query templates from schema
- **Validation Engine**: Real-time field validation during query building

## API Documentation Resources

### Two Critical Documentation Files

**[botify_api.md](mdc:pipulate/training/botify_api.md)** - High-Level Integration Guide:
- Strategic overview of Botify API integration patterns
- Conceptual explanations of BQL (Botify Query Language) versions
- Workflow-focused guidance for data collection strategies
- Best practices for API authentication and error handling
- Used for understanding integration approaches and patterns

**[botify_open_api.md](mdc:pipulate/training/botify_open_api.md)** - Complete API Reference:
- Comprehensive endpoint documentation with Python examples
- **2,898 lines** of detailed API specifications
- Every endpoint with parameters, request/response formats
- Ready-to-use Python code examples for each endpoint
- **Critical Discovery Endpoints**:
  - `GET /analyses/{username}/{project_slug}/{analysis_slug}/urls/datamodel`
  - `GET /analyses/{username}/{project_slug}/{analysis_slug}/urls/datasets`
- Used for implementation details and exact API usage

### Documentation Usage Strategy

**For Schema Discovery Implementation**:
1. **Start with [botify_open_api.md](mdc:pipulate/training/botify_open_api.md)** - Find exact endpoint specifications
2. **Reference [botify_api.md](mdc:pipulate/training/botify_api.md)** - Understand integration context and patterns
3. **Use True Schema Discovery** - Leverage official endpoints for comprehensive field discovery

**Key Insight**: The OpenAPI documentation provided the exact endpoint specifications (`/urls/datamodel` and `/urls/datasets`) that enabled the breakthrough from 18 fields to 4,449 fields. The high-level API guide provides context, but the OpenAPI reference provides implementation precision.

This true schema discovery system provides the foundation for building sophisticated, schema-aware Botify integrations that can adapt to API changes and leverage the full power of the Botify data platform.
