import asyncio
import json
from collections import namedtuple
from datetime import datetime
from pathlib import Path

from fasthtml.common import * # type: ignore
from starlette.responses import HTMLResponse
from loguru import logger
from rich.console import Console
from rich.table import Table

"""
Pipulate Widget Examples

This workflow demonstrates various widget types that can be integrated into Pipulate Workflows:

1. Simple HTMX Widget: Basic HTML content with no JavaScript execution
2. Rich Table Widget: HTML generated by Python's Rich library
3. JavaScript Execution Widget: DOM manipulation via JavaScript in HTMX-injected content
4. Markdown Renderer Widget: Client-side Markdown rendering using marked.js

This serves as a reference implementation for creating visualization widgets in Pipulate.
"""

# Model for a workflow step (Do not change)
Step = namedtuple('Step', ['id', 'done', 'show', 'refill', 'transform'], defaults=(None,))


class WidgetExamples:
    """
    Widget Examples Workflow
    
    Demonstrates various widget types for Pipulate Workflows:
    1. Simple HTMX Widget - No JS execution
    2. Rich Table Widget - Using Python's Rich library
    3. JavaScript Execution Widget - Running JS in HTMX-injected content
    4. Markdown Renderer - Client-side rendering using marked.js
    
    Key Implementation Notes:
    - Widgets use pip.widget_container for consistent styling and DOM structure
    - JavaScript widgets use unique IDs for targeting in the DOM
    - Client-side libraries are loaded in server.py's hdrs tuple
    - HX-Trigger headers are used for reliable JS execution in HTMX-injected content
    """
    # --- Workflow Configuration ---
    APP_NAME = "widgets"
    DISPLAY_NAME = "Widget Examples"
    ENDPOINT_MESSAGE = (
        "This workflow demonstrates various widget types for Pipulate. "
        "Enter an ID to start or resume your workflow."
    )
    TRAINING_PROMPT = "Demonstrates various widget types in Pipulate Workflows"
    PRESERVE_REFILL = True

    # --- Initialization ---
    def __init__(self, app, pipulate, pipeline, db, app_name=APP_NAME):
        """
        Initialize the workflow, define steps, and register routes.
        """
        self.app = app
        self.app_name = app_name
        self.pipulate = pipulate
        self.pipeline = pipeline
        self.steps_indices = {}
        self.db = db
        pip = self.pipulate
        self.message_queue = pip.message_queue
        
        # Define workflow steps
        steps = [
            Step(
                id='step_01',
                done='simple_content',
                show='Simple HTMX Widget',
                refill=True,
            ),
            Step(
                id='step_02',
                done='table_data',
                show='Rich Table Widget',
                refill=True,
            ),
            Step(
                id='step_03',
                done='js_content',
                show='JavaScript Widget',
                refill=True,
            ),
            Step(
                id='step_04',
                done='markdown_content',
                show='Markdown Renderer',
                refill=True,
            ),
        ]
        
        # Standard workflow routes
        routes = [
            (f"/{app_name}", self.landing),
            (f"/{app_name}/init", self.init, ["POST"]),
            (f"/{app_name}/jump_to_step", self.jump_to_step, ["POST"]),
            (f"/{app_name}/revert", self.handle_revert, ["POST"]),
            (f"/{app_name}/finalize", self.finalize, ["GET", "POST"]),
            (f"/{app_name}/unfinalize", self.unfinalize, ["POST"]),
        ]

        # Routes for each custom step
        self.steps = steps
        for step in steps:
            step_id = step.id
            routes.append((f"/{app_name}/{step_id}", getattr(self, step_id)))
            routes.append((f"/{app_name}/{step_id}_submit", getattr(self, f"{step_id}_submit"), ["POST"]))

        # Register routes with the FastHTML app
        for path, handler, *methods in routes:
            method_list = methods[0] if methods else ["GET"]
            app.route(path, methods=method_list)(handler)

        # Define UI messages
        self.step_messages = {
            "finalize": {
                "ready": "All steps complete. Ready to finalize workflow.",
                "complete": f"Workflow finalized. Use {pip.UNLOCK_BUTTON_LABEL} to make changes."
            },
            "new": "Please complete each step to explore different widget types."
        }

        # Default messages for each step
        for step in steps:
            self.step_messages[step.id] = {
                "input": f"{pip.fmt(step.id)}: Enter content for {step.show}.",
                "complete": f"{step.show} complete. Continue to next step."
            }

        # Add finalize step
        steps.append(Step(id='finalize', done='finalized', show='Finalize', refill=False))
        self.steps_indices = {step.id: i for i, step in enumerate(steps)}

    # --- Core Workflow Engine Methods ---

    async def landing(self):
        """ Renders the initial landing page with the key input form. """
        pip, pipeline, steps, app_name = self.pipulate, self.pipeline, self.steps, self.app_name
        context = pip.get_plugin_context(self)
        title = f"{self.DISPLAY_NAME or app_name.title()}"
        full_key, prefix, user_part = pip.generate_pipeline_key(self)
        default_value = full_key
        pipeline.xtra(app_name=app_name)
        matching_records = [record.pkey for record in pipeline() if record.pkey.startswith(prefix)]
        datalist_options = [f"{prefix}{record_key.replace(prefix, '')}" for record_key in matching_records]

        return Container(
            Card(
                H2(title),
                P(self.ENDPOINT_MESSAGE, style="font-size: 0.9em; color: #666;"),
                Form(
                    pip.wrap_with_inline_button(
                        Input(
                            placeholder="Existing or new üóù here (Enter for auto)", name="pipeline_id",
                            list="pipeline-ids", type="search", required=False, autofocus=True,
                            value=default_value, _onfocus="this.setSelectionRange(this.value.length, this.value.length)",
                            cls="contrast"
                        ),
                        button_label=f"Enter üîë", button_class="secondary"
                    ),
                    pip.update_datalist("pipeline-ids", options=datalist_options if datalist_options else None),
                    hx_post=f"/{app_name}/init", hx_target=f"#{app_name}-container"
                )
            ),
            Div(id=f"{app_name}-container")
        )

    async def init(self, request):
        """ Initialize the workflow state and redirect to the first step. """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        form = await request.form()
        user_input = form.get("pipeline_id", "").strip()

        if not user_input:
            from starlette.responses import Response
            response = Response("")
            response.headers["HX-Refresh"] = "true"
            return response

        # Generate or parse the unique pipeline ID
        context = pip.get_plugin_context(self)
        plugin_name = context['plugin_name'] or app_name
        profile_name = context['profile_name'] or "default"
        profile_part = profile_name.replace(" ", "_")
        plugin_part = plugin_name.replace(" ", "_")
        expected_prefix = f"{profile_part}-{plugin_part}-"

        if user_input.startswith(expected_prefix):
            pipeline_id = user_input
        else:
            _, prefix, user_provided_id = pip.generate_pipeline_key(self, user_input)
            pipeline_id = f"{prefix}{user_provided_id}"

        db["pipeline_id"] = pipeline_id
        logger.debug(f"Using pipeline ID: {pipeline_id}")

        # Initialize state if missing
        state, error = pip.initialize_if_missing(pipeline_id, {"app_name": app_name})
        if error: return error
        all_steps_complete = all(step.id in state and step.done in state[step.id] for step in steps[:-1])
        is_finalized = "finalize" in state and "finalized" in state["finalize"]

        # Add initial status messages
        await self.message_queue.add(pip, f"Workflow ID: {pipeline_id}", verbatim=True, spaces_before=0)
        await self.message_queue.add(pip, f"Return later by selecting '{pipeline_id}' from the dropdown.", verbatim=True, spaces_before=0)
        if all_steps_complete:
            status_msg = f"Workflow is complete and finalized. Use {pip.UNLOCK_BUTTON_LABEL} to make changes." if is_finalized \
                else "Workflow is complete but not finalized. Press Finalize to lock your data."
            await self.message_queue.add(pip, status_msg, verbatim=True)
        elif not any(step.id in state for step in self.steps):
            await self.message_queue.add(pip, self.step_messages["new"], verbatim=True)

        # Update the datalist
        parsed = pip.parse_pipeline_key(pipeline_id)
        prefix = f"{parsed['profile_part']}-{parsed['plugin_part']}-"
        self.pipeline.xtra(app_name=app_name)
        matching_records = [record.pkey for record in self.pipeline() if record.pkey.startswith(prefix)]
        if pipeline_id not in matching_records: matching_records.append(pipeline_id)
        updated_datalist = pip.update_datalist("pipeline-ids", options=matching_records)

        # Rebuild the UI, triggering the first step load
        return pip.rebuild(app_name, steps)

    async def finalize(self, request):
        """ Handle GET/POST requests to finalize (lock) the workflow. """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        pipeline_id = db.get("pipeline_id", "unknown")
        finalize_step = steps[-1]
        finalize_data = pip.get_step_data(pipeline_id, finalize_step.id, {})

        if request.method == "GET":
            # Show locked view or finalize button
            if finalize_step.done in finalize_data:
                return Card(
                    H4("Workflow is locked."),
                    Form(
                        Button(pip.UNLOCK_BUTTON_LABEL, type="submit", cls="secondary outline"),
                        hx_post=f"/{app_name}/unfinalize", hx_target=f"#{app_name}-container", hx_swap="outerHTML"
                    ),
                    id=finalize_step.id
                )
            else:
                # Check if all steps are complete before offering finalize
                all_steps_complete = all(pip.get_step_data(pipeline_id, step.id, {}).get(step.done) for step in steps[:-1])
                if all_steps_complete:
                    return Card(
                        H4("All steps complete. Finalize?"),
                        P("You can revert to any step and make changes.", style="font-size: 0.9em; color: #666;"),
                        Form(
                            Button("Finalize", type="submit", cls="primary"),
                            hx_post=f"/{app_name}/finalize", hx_target=f"#{app_name}-container", hx_swap="outerHTML"
                        ),
                        id=finalize_step.id
                    )
                else:
                    return Div(id=finalize_step.id)
        else:  # POST request
            await pip.finalize_workflow(pipeline_id)
            await self.message_queue.add(pip, self.step_messages["finalize"]["complete"], verbatim=True)
            return pip.rebuild(app_name, steps)

    async def unfinalize(self, request):
        """ Handle POST request to unlock the workflow. """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        pipeline_id = db.get("pipeline_id", "unknown")
        await pip.unfinalize_workflow(pipeline_id)
        await self.message_queue.add(pip, "Workflow unfinalized! You can now revert to any step and make changes.", verbatim=True)
        return pip.rebuild(app_name, steps)

    async def jump_to_step(self, request):
        """ Handle POST request from breadcrumb navigation to jump to a step. """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        form = await request.form()
        step_id = form.get("step_id")
        db["step_id"] = step_id
        return pip.rebuild(app_name, steps)

    async def get_suggestion(self, step_id, state):
        """ Gets a suggested input value for a step, often using the previous step's transformed output. """
        pip, db, steps = self.pipulate, self.db, self.steps
        
        # Pre-populated examples for each widget type
        examples = {
            'step_01': """Simple HTML content example:
- Basic text formatting
- No complex HTML tags
- Plain content for demonstration
- Easy to modify

This is a sample widget that shows basic text content.
It works well with the HTMX updates and keeps things simple.""",
            
            'step_02': """[
    {"Name": "John", "Age": 32, "Role": "Developer"},
    {"Name": "Jane", "Age": 28, "Role": "Designer"},
    {"Name": "Bob", "Age": 45, "Role": "Manager"}
]""",
            
            'step_03': """// Simple counter example
let count = 0;
const countDisplay = document.createElement('div');
countDisplay.style.fontSize = '24px';
countDisplay.style.margin = '20px 0';
countDisplay.textContent = count;

const button = document.createElement('button');
button.textContent = 'Increment Count';
button.onclick = function() {
    count++;
    countDisplay.textContent = count;
};

widget.appendChild(countDisplay);
widget.appendChild(button);""",
            
            'step_04': """# Simple Markdown Example

## Basic Features
- Bold and *italic* text
- Simple lists
- Code blocks

## Example Code
```
function hello() {
    return "Hello World";
}
```

Simple table:
| Item | Value |
|------|-------|
| One  | 1     |
| Two  | 2     |

That's it!"""
        }
        
        # Return pre-populated example or empty string
        return examples.get(step_id, "")

    async def handle_revert(self, request):
        """ Handle POST request to revert to a previous step. """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        form = await request.form()
        step_id = form.get("step_id")
        pipeline_id = db.get("pipeline_id", "unknown")
        if not step_id: return P("Error: No step specified", style=pip.get_style("error"))

        # Clear state from the target step onwards
        await pip.clear_steps_from(pipeline_id, step_id, steps)
        # Mark the target step for revert logic in GET handlers
        state = pip.read_state(pipeline_id)
        state["_revert_target"] = step_id
        pip.write_state(pipeline_id, state)

        # Add message and rebuild UI
        message = await pip.get_state_message(pipeline_id, steps, self.step_messages)
        await self.message_queue.add(pip, message, verbatim=True)
        return pip.rebuild(app_name, steps)

    # --- Step 1: Simple HTMX Widget ---
    async def step_01(self, request):
        """ Handles GET request for Step 1: Simple HTMX Widget. """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        step_id = "step_01"
        step_index = self.steps_indices[step_id]
        step = steps[step_index]
        next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'
        pipeline_id = db.get("pipeline_id", "unknown")
        state = pip.read_state(pipeline_id)
        step_data = pip.get_step_data(pipeline_id, step_id, {})
        user_val = step_data.get(step.done, "")
        
        # Check if workflow is finalized
        finalize_data = pip.get_step_data(pipeline_id, "finalize", {})
        if "finalized" in finalize_data:
            return Div(
                Card(f"üîí {step.show}: <content locked>"),
                Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load")
            )
            
        # Check if step is complete and not reverting
        if user_val and state.get("_revert_target") != step_id:
            return Div(
                pip.revert_control(step_id=step_id, app_name=app_name, message=f"{step.show} Configured", steps=steps),
                Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load")
            )
        else:
            # Show input form
            display_value = user_val if step.refill and user_val else await self.get_suggestion(step_id, state)
            await self.message_queue.add(pip, self.step_messages[step_id]["input"], verbatim=True)
            
            return Div(
                Card(
                    H4(f"{pip.fmt(step_id)}: Configure {step.show}"),
                    P("Enter HTML content for the simple widget. Example is pre-populated."),
                    Form(
                        Div(
                            Textarea(
                                display_value,
                                name=step.done,
                                placeholder="Enter HTML content for the widget",
                                required=True,
                                rows=10,
                                style="width: 100%; font-family: monospace;"
                            ),
                            Div(
                                Button("Submit", type="submit", cls="primary"),
                                style="margin-top: 1vh; text-align: right;"
                            ),
                            style="width: 100%;"
                        ),
                        hx_post=f"/{app_name}/{step_id}_submit",
                        hx_target=f"#{step_id}"
                    )
                ),
                Div(id=next_step_id),
                id=step_id
            )

    async def step_01_submit(self, request):
        """ Process the submission for Step 1. """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        step_id = "step_01"
        step_index = self.steps_indices[step_id]
        step = steps[step_index]
        pipeline_id = db.get("pipeline_id", "unknown")

        # Get form data
        form = await request.form()
        user_val = form.get(step.done, "")

        # Validate input
        is_valid, error_msg, error_component = pip.validate_step_input(user_val, step.show)
        if not is_valid:
            return error_component

        # Save the value to state
        await pip.update_step_state(pipeline_id, step_id, user_val, steps)

        # Create a simple HTML widget with the user's content
        simple_widget = Div(
            user_val,
            style="padding: 1rem; background-color: #f8f9fa; border-radius: 4px;"
        )
        
        # Send confirmation message
        await self.message_queue.add(pip, f"{step.show} complete.", verbatim=True)

        # Return the widget container and trigger for next step
        return pip.create_step_navigation(step_id, step_index, steps, app_name, "Simple content provided")

    # --- Step 2: Rich Table Widget ---
    async def step_02(self, request):
        """ Handles GET request for Step 2: Rich Table Widget. """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        step_id = "step_02"
        step_index = self.steps_indices[step_id]
        step = steps[step_index]
        next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'
        pipeline_id = db.get("pipeline_id", "unknown")
        state = pip.read_state(pipeline_id)
        step_data = pip.get_step_data(pipeline_id, step_id, {})
        user_val = step_data.get(step.done, "")
        
        # Check if workflow is finalized
        finalize_data = pip.get_step_data(pipeline_id, "finalize", {})
        if "finalized" in finalize_data:
            return Div(
                Card(f"üîí {step.show}: <content locked>"),
                Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load")
            )
            
        # Check if step is complete and not reverting
        if user_val and state.get("_revert_target") != step_id:
            # Create the table widget from the existing data
            try:
                table_widget = self.create_rich_table(user_val)
                content_container = pip.widget_container(
                    step_id=step_id,
                    app_name=app_name,
                    message=f"{step.show} Configured",
                    widget=table_widget,
                    steps=steps
                )
                return Div(
                    content_container,
                    Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load")
                )
            except Exception as e:
                # If there's an error creating the widget, revert to input form
                logger.error(f"Error creating table widget: {str(e)}")
                state["_revert_target"] = step_id
                pip.write_state(pipeline_id, state)
        
        # Show input form
        display_value = user_val if step.refill and user_val else await self.get_suggestion(step_id, state)
        await self.message_queue.add(pip, self.step_messages[step_id]["input"], verbatim=True)
        
        return Div(
            Card(
                H4(f"{pip.fmt(step_id)}: Configure {step.show}"),
                P("Enter table data as JSON array. Example is pre-populated."),
                P("Format: [[column1, column2, ...], [row1col1, row1col2, ...], ...]", 
                  style="font-size: 0.8em; font-style: italic;"),
                Form(
                    Div(
                        Textarea(
                            display_value,
                            name=step.done,
                            placeholder="Enter JSON array data for the table",
                            required=True,
                            rows=10,
                            style="width: 100%; font-family: monospace;"
                        ),
                        Div(
                            Button("Submit", type="submit", cls="primary"),
                            style="margin-top: 1vh; text-align: right;"
                        ),
                        style="width: 100%;"
                    ),
                    hx_post=f"/{app_name}/{step_id}_submit",
                    hx_target=f"#{step_id}"
                )
            ),
            Div(id=next_step_id),
            id=step_id
        )

    async def step_02_submit(self, request):
        """ Process the submission for Step 2. """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        step_id = "step_02"
        step_index = self.steps_indices[step_id]
        step = steps[step_index]
        pipeline_id = db.get("pipeline_id", "unknown")

        # Get form data
        form = await request.form()
        user_val = form.get(step.done, "")

        # Validate input
        is_valid, error_msg, error_component = pip.validate_step_input(user_val, step.show)
        if not is_valid:
            return error_component
            
        # Additional validation for JSON format
        try:
            json_data = json.loads(user_val)
            if not isinstance(json_data, list) or not json_data:
                return P("Invalid JSON: Must be a non-empty array of objects", style=pip.get_style("error"))
            if not all(isinstance(item, dict) for item in json_data):
                return P("Invalid JSON: All items must be objects (dictionaries)", style=pip.get_style("error"))
        except json.JSONDecodeError:
            return P("Invalid JSON format. Please check your syntax.", style=pip.get_style("error"))

        # Save the value to state
        await pip.update_step_state(pipeline_id, step_id, user_val, steps)

        # Create a Rich table from the JSON data
        table = Table(title="User Provided Data")
        try:
            data = json.loads(user_val)
            
            # Add columns
            for column in data[0].keys():
                table.add_column(column, style="blue")
            
            # Add rows
            for row in data:
                table.add_row(*[str(v) for v in row.values()])
            
            # Capture the HTML using Rich's Console
            console = Console(record=True)
            console.print(table)
            html_output = console.export_html(inline_styles=True)
            
            # Wrap in a Div with raw HTML
            rich_table = Div(html_output, _raw=True)
            
            # Send confirmation message
            await self.message_queue.add(pip, f"{step.show} complete. Table rendered successfully.", verbatim=True)
            
            # Return the widget container with the table
            return Div(
                pip.widget_container(
                    step_id=step_id,
                    app_name=app_name,
                    message=f"{step.show}: Table rendered from Python's Rich library",
                    widget=rich_table,
                    steps=steps
                ),
                Div(id=f"{steps[step_index + 1].id}", hx_get=f"/{app_name}/{steps[step_index + 1].id}", hx_trigger="load"),
                id=step_id
            )
        except Exception as e:
            logger.error(f"Error creating Rich table: {e}")
            return P(f"Error creating table: {str(e)}", style=pip.get_style("error"))

    # --- Step 3: JavaScript Execution Widget ---
    async def step_03(self, request):
        """ Handles GET request for Step 3: JavaScript Widget. """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        step_id = "step_03"
        step_index = self.steps_indices[step_id]
        step = steps[step_index]
        next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'
        pipeline_id = db.get("pipeline_id", "unknown")
        state = pip.read_state(pipeline_id)
        step_data = pip.get_step_data(pipeline_id, step_id, {})
        user_val = step_data.get(step.done, "")
        
        # Check if workflow is finalized
        finalize_data = pip.get_step_data(pipeline_id, "finalize", {})
        if "finalized" in finalize_data:
            return Div(
                Card(f"üîí {step.show}: <content locked>"),
                Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load")
            )
            
        # Check if step is complete and not reverting
        if user_val and state.get("_revert_target") != step_id:
            # Create the JS widget from the existing code
            try:
                widget_id = f"js-widget-{pipeline_id.split('-')[-1]}"
                js_widget = self.create_js_widget(user_val, widget_id)
                content_container = pip.widget_container(
                    step_id=step_id,
                    app_name=app_name,
                    message=f"{step.show} Configured",
                    widget=js_widget,
                    steps=steps
                )
                return Div(
                    content_container,
                    Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load")
                )
            except Exception as e:
                # If there's an error creating the widget, revert to input form
                logger.error(f"Error creating JS widget: {str(e)}")
                state["_revert_target"] = step_id
                pip.write_state(pipeline_id, state)
        
        # Show input form
        display_value = user_val if step.refill and user_val else await self.get_suggestion(step_id, state)
        await self.message_queue.add(pip, self.step_messages[step_id]["input"], verbatim=True)
        
        return Div(
            Card(
                H4(f"{pip.fmt(step_id)}: Configure {step.show}"),
                P("Enter JavaScript code for the widget. Example is pre-populated."),
                P("Use the 'widget' variable to access the container element.", 
                  style="font-size: 0.8em; font-style: italic;"),
                Form(
                    Div(
                        Textarea(
                            display_value,
                            name=step.done,
                            placeholder="Enter JavaScript code",
                            required=True,
                            rows=12,
                            style="width: 100%; font-family: monospace;"
                        ),
                        Div(
                            Button("Submit", type="submit", cls="primary"),
                            style="margin-top: 1vh; text-align: right;"
                        ),
                        style="width: 100%;"
                    ),
                    hx_post=f"/{app_name}/{step_id}_submit",
                    hx_target=f"#{step_id}"
                )
            ),
            Div(id=next_step_id),
            id=step_id
        )

    async def step_03_submit(self, request):
        """ Process the submission for Step 3. """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        step_id = "step_03"
        step_index = self.steps_indices[step_id]
        step = steps[step_index]
        pipeline_id = db.get("pipeline_id", "unknown")
        next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'

        # Get form data
        form = await request.form()
        user_val = form.get(step.done, "")

        # Validate input
        is_valid, error_msg, error_component = pip.validate_step_input(user_val, step.show)
        if not is_valid:
            return error_component

        # Save the value to state
        await pip.update_step_state(pipeline_id, step_id, user_val, steps)
        
        # Generate unique widget ID for this step and pipeline
        widget_id = f"js-widget-{pipeline_id}-{step_id}".replace("-", "_")
        
        # Create the JavaScript widget
        js_widget = Div(
            Div(
                # Container that will be manipulated by the JS code
                P("This element will be modified by JavaScript...", id=f"{widget_id}_target", 
                  style="padding: 1rem; background-color: #f0f0f0; border-radius: 4px;"),
                # Display the code in a styled pre
                H5("JavaScript Code:"),
                Pre(
                    user_val,
                    style="padding: 1rem; background-color: #f8f9fa; border-radius: 4px; overflow-x: auto; font-family: monospace;"
                ),
                # Button to re-run the JavaScript
                Button(
                    "Re-run JavaScript", 
                    type="button", 
                    _onclick=f"runJsWidget('{widget_id}', `{user_val.replace('`', '\\`')}`, '{widget_id}_target')",
                    style="margin-top: 1rem;"
                )
            ),
            id=widget_id
        )
        
        # Create an HTMLResponse with the widget container
        response = HTMLResponse(
            to_xml(
                Div(
                    pip.widget_container(
                        step_id=step_id,
                        app_name=app_name,
                        message=f"{step.show}: JavaScript execution example",
                        widget=js_widget,
                        steps=steps
                    ),
                    Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
                    id=step_id
                )
            )
        )
        
        # Add HX-Trigger header to execute the JS code
        response.headers["HX-Trigger"] = json.dumps({
            "runJavaScript": {
                "widgetId": widget_id,
                "code": user_val,
                "targetId": f"{widget_id}_target"
            }
        })
        
        # Send confirmation message
        await self.message_queue.add(pip, f"{step.show} complete. JavaScript executed.", verbatim=True)
        
        return response

    # --- Step 4: Markdown Renderer ---
    async def step_04(self, request):
        """ Handles GET request for Step 4: Markdown Renderer. """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        step_id = "step_04"
        step_index = self.steps_indices[step_id]
        step = steps[step_index]
        next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'
        pipeline_id = db.get("pipeline_id", "unknown")
        state = pip.read_state(pipeline_id)
        step_data = pip.get_step_data(pipeline_id, step_id, {})
        user_val = step_data.get(step.done, "")
        
        # Check if workflow is finalized
        finalize_data = pip.get_step_data(pipeline_id, "finalize", {})
        if "finalized" in finalize_data:
            return Div(
                Card(f"üîí {step.show}: <content locked>"),
                Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load")
            )
            
        # Check if step is complete and not reverting
        if user_val and state.get("_revert_target") != step_id:
            # Create the markdown widget from the existing content
            try:
                widget_id = f"md-widget-{pipeline_id.split('-')[-1]}"
                md_widget = self.create_markdown_widget(user_val, widget_id)
                content_container = pip.widget_container(
                    step_id=step_id,
                    app_name=app_name,
                    message=f"{step.show} Configured",
                    widget=md_widget,
                    steps=steps
                )
                return Div(
                    content_container,
                    Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load")
                )
            except Exception as e:
                # If there's an error creating the widget, revert to input form
                logger.error(f"Error creating markdown widget: {str(e)}")
                state["_revert_target"] = step_id
                pip.write_state(pipeline_id, state)
        
        # Show input form
        display_value = user_val if step.refill and user_val else await self.get_suggestion(step_id, state)
        await self.message_queue.add(pip, self.step_messages[step_id]["input"], verbatim=True)
        
        return Div(
            Card(
                H4(f"{pip.fmt(step_id)}: Configure {step.show}"),
                P("Enter Markdown content for the widget. Example is pre-populated."),
                P("Supports standard Markdown syntax including tables, code blocks, and links.", 
                  style="font-size: 0.8em; font-style: italic;"),
                Form(
                    Div(
                        Textarea(
                            display_value,
                            name=step.done,
                            placeholder="Enter Markdown content",
                            required=True,
                            rows=15,
                            style="width: 100%; font-family: monospace;"
                        ),
                        Div(
                            Button("Submit", type="submit", cls="primary"),
                            style="margin-top: 1vh; text-align: right;"
                        ),
                        style="width: 100%;"
                    ),
                    hx_post=f"/{app_name}/{step_id}_submit",
                    hx_target=f"#{step_id}"
                )
            ),
            Div(id=next_step_id),
            id=step_id
        )

    async def step_04_submit(self, request):
        """ Process the submission for Step 4. """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        step_id = "step_04"
        step_index = self.steps_indices[step_id]
        step = steps[step_index]
        pipeline_id = db.get("pipeline_id", "unknown")
        next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'

        # Get form data
        form = await request.form()
        user_val = form.get(step.done, "")

        # Validate input
        is_valid, error_msg, error_component = pip.validate_step_input(user_val, step.show)
        if not is_valid:
            return error_component

        # Save the value to state
        await pip.update_step_state(pipeline_id, step_id, user_val, steps)
        
        # Generate unique widget ID for this step and pipeline
        widget_id = f"md-widget-{pipeline_id}-{step_id}".replace("-", "_")
        
        # Create the markdown widget
        md_widget = Div(
            Div(
                # Container to render the markdown
                H5("Rendered Markdown:"),
                Div(id=f"{widget_id}_output", style="padding: 1rem; background-color: #fff; border-radius: 4px; border: 1px solid #ddd;"),
                # Display the markdown source
                H5("Markdown Source:"),
                Pre(
                    user_val,
                    style="padding: 1rem; background-color: #f8f9fa; border-radius: 4px; overflow-x: auto; font-family: monospace;"
                )
            ),
            id=widget_id
        )
        
        # Create an HTMLResponse with the widget container
        response = HTMLResponse(
            to_xml(
                Div(
                    pip.widget_container(
                        step_id=step_id,
                        app_name=app_name,
                        message=f"{step.show}: Client-side markdown rendering",
                        widget=md_widget,
                        steps=steps
                    ),
                    Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
                    id=step_id
                )
            )
        )
        
        # Add HX-Trigger header to render the markdown
        response.headers["HX-Trigger"] = json.dumps({
            "renderMarkdown": {
                "targetId": f"{widget_id}_output",
                "markdown": user_val
            }
        })
        
        # Send confirmation message
        await self.message_queue.add(pip, f"{step.show} complete. Markdown rendered.", verbatim=True)
        
        return response 

    # --- Helper Methods (Widget Creation) ---
    
    def create_rich_table(self, data_str):
        """Create a Rich table from JSON string data."""
        try:
            # Try parsing as a list of lists first
            data = json.loads(data_str)
            
            # Create a Rich table
            table = Table(title="Data Table")
            
            # Check if data is a list of lists (like [["Name", "Age"], ["John", 30]])
            if isinstance(data, list) and all(isinstance(item, list) for item in data):
                # First row contains column headers
                headers = data[0]
                for header in headers:
                    table.add_column(str(header), style="blue")
                
                # Remaining rows contain data
                for row in data[1:]:
                    table.add_row(*[str(val) for val in row])
            
            # Check if data is a list of dicts (like [{"name": "John", "age": 30}])
            elif isinstance(data, list) and all(isinstance(item, dict) for item in data):
                # Get column names from the first dict
                columns = list(data[0].keys())
                for column in columns:
                    table.add_column(column, style="blue")
                
                # Add rows from the dicts
                for row in data:
                    table.add_row(*[str(row.get(col, "")) for col in columns])
            else:
                return Div(f"<div style='color: red;'>Unsupported data format</div>", _raw=True)
            
            # Capture the HTML using Rich's Console
            console = Console(record=True)
            console.print(table)
            html_output = console.export_html(inline_styles=True)
            
            # Wrap in a Div with raw HTML
            return Div(html_output, _raw=True)
        except Exception as e:
            logger.error(f"Error creating Rich table: {e}")
            return Div(f"<div style='color: red;'>Error creating table: {str(e)}</div>", _raw=True)

    def create_js_widget(self, code, widget_id):
        """Create a JavaScript widget with the provided code."""
        # Create a container for the widget
        container = Div(
            Div(
                # Container that will be manipulated by the JS code
                Div(id=f"{widget_id}_content", style="padding: 1rem; background-color: #f0f0f0; border-radius: 4px; min-height: 100px;"),
                # Display the code in a styled pre
                H5("JavaScript Code:"),
                Pre(
                    code,
                    style="padding: 1rem; background-color: #f8f9fa; border-radius: 4px; overflow-x: auto; font-family: monospace;"
                ),
                # Button to re-run the JavaScript
                Button(
                    "Re-run JavaScript", 
                    type="button", 
                    _onclick=f"const widget = document.getElementById('{widget_id}_content'); {code}",
                    style="margin-top: 1rem;"
                )
            ),
            id=widget_id
        )
        
        # Create an HTMLResponse so we can add HX-Trigger
        response = HTMLResponse(to_xml(container))
        
        # Add HX-Trigger header to execute the JS code
        response.headers["HX-Trigger"] = json.dumps({
            "runJavaScript": {
                "code": f"const widget = document.getElementById('{widget_id}_content'); {code}"
            }
        })
        
        return container

    def create_markdown_widget(self, md_content, widget_id):
        """Create a markdown widget container."""
        container = Div(
            Div(
                # Container to render the markdown
                H5("Rendered Markdown:"),
                Div(id=f"{widget_id}_output", style="padding: 1rem; background-color: #fff; border-radius: 4px; border: 1px solid #ddd; min-height: 100px;"),
                # Display the markdown source
                H5("Markdown Source:"),
                Pre(
                    md_content,
                    style="padding: 1rem; background-color: #f8f9fa; border-radius: 4px; overflow-x: auto; font-family: monospace;"
                )
            ),
            id=widget_id
        )
        
        # Create an HTMLResponse with the widget container
        response = HTMLResponse(to_xml(container))
        
        # Add HX-Trigger header to render the markdown
        response.headers["HX-Trigger"] = json.dumps({
            "renderMarkdown": {
                "targetId": f"{widget_id}_output",
                "markdown": md_content
            }
        })
        
        return container 