<?xml version="1.0" encoding="UTF-8"?>
<context schema="pipulate-context" version="1.0">
<manifest>
<files>
<file><path>server.py</path>
<description>server.py [loaded]</description>
<file_type>python</file_type>
<tokens>25744</tokens></file>
<file><path>flake.nix</path>
<description>flake.nix [loaded]</description>
<file_type>nix</file_type>
<tokens>3301</tokens></file>
<file><path>requirements.txt</path>
<description>requirements.txt [loaded]</description>
<file_type>text</file_type>
<tokens>105</tokens></file>
<file><path>README.md</path>
<description>README.md [loaded]</description>
<file_type>markdown</file_type>
<tokens>5959</tokens></file>
<file><path>.cursorrules</path>
<description>.cursorrules [loaded]</description>
<tokens>974</tokens></file>
<file><path>plugins/20_hello_workflow.py</path>
<description>20_hello_workflow.py [loaded]</description>
<file_type>python</file_type>
<tokens>6757</tokens></file>
<file><path>plugins/60_widget_examples.py</path>
<description>60_widget_examples.py [loaded]</description>
<file_type>python</file_type>
<tokens>19775</tokens></file>
<file><path>plugins/70_blank_workflow.py</path>
<description>70_blank_workflow.py [loaded]</description>
<file_type>python</file_type>
<tokens>3390</tokens></file>
<file><path>plugins/80_splice_workflow.py</path>
<description>80_splice_workflow.py [loaded]</description>
<file_type>python</file_type>
<tokens>6185</tokens></file>
<file><path>/home/mike/repos/.cursor/rules/htmx-chain-reactions.mdc</path>
<description>htmx-chain-reactions.mdc [loaded]</description>
<file_type>text</file_type>
<tokens>552</tokens></file>
<file><path>/home/mike/repos/.cursor/rules/nix-rules.mdc</path>
<description>nix-rules.mdc [loaded]</description>
<file_type>text</file_type>
<tokens>964</tokens></file>
<file><path>/home/mike/repos/.cursor/rules/placeholder-step-pattern.mdc</path>
<description>placeholder-step-pattern.mdc [loaded]</description>
<file_type>text</file_type>
<tokens>1311</tokens></file>
<file><path>/home/mike/repos/.cursor/rules/wet-workflows.mdc</path>
<description>wet-workflows.mdc [loaded]</description>
<file_type>text</file_type>
<tokens>2155</tokens></file>
<file><path>/home/mike/repos/pipulate/training/workflow_implementation_guide.md</path>
<description>workflow_implementation_guide.md [loaded]</description>
<file_type>markdown</file_type>
<tokens>7471</tokens></file>
<file><path>/home/mike/repos/pipulate/precursors/prompt.md</path>
<description>prompt.md [loaded]</description>
<file_type>markdown</file_type>
<tokens>4045</tokens></file>
</files>
<environment>
<setting><type>Runtime</type>
<details>Python 3.12 in a Nix-managed virtualenv (.venv)</details></setting>
<setting><type>Package Management</type>
<details>Hybrid approach using Nix flakes for system dependencies + pip for Python packages</details></setting>
</environment>
<conventions>
<convention><name>FastHTML Rendering</name>
<description>All FastHTML objects must be converted with to_xml() before being returned in HTTP responses</description></convention>
<convention><name>Environment Activation</name>
<description>Always run 'nix develop' in new terminals before any other commands</description></convention>
<convention><name>Dependency Management</name>
<description>System deps go in flake.nix, Python packages in requirements.txt</description></convention>
</conventions>
<critical_patterns>
<pattern><pattern>to_xml(ft_object)</pattern>
<explanation>Required to convert FastHTML objects to strings before HTTP responses</explanation></pattern>
<pattern><pattern>HTMLResponse(str(to_xml(rendered_item)))</pattern>
<explanation>Proper pattern for returning FastHTML content with HTMX triggers</explanation></pattern>
</critical_patterns>
<token_usage>
<files><metadata>273</metadata>
<content><file><path>server.py</path>
<tokens>25744</tokens></file>
<file><path>flake.nix</path>
<tokens>3301</tokens></file>
<file><path>requirements.txt</path>
<tokens>105</tokens></file>
<file><path>README.md</path>
<tokens>5959</tokens></file>
<file><path>.cursorrules</path>
<tokens>974</tokens></file>
<file><path>plugins/20_hello_workflow.py</path>
<tokens>6757</tokens></file>
<file><path>plugins/60_widget_examples.py</path>
<tokens>19775</tokens></file>
<file><path>plugins/70_blank_workflow.py</path>
<tokens>3390</tokens></file>
<file><path>plugins/80_splice_workflow.py</path>
<tokens>6185</tokens></file>
<file><path>/home/mike/repos/.cursor/rules/htmx-chain-reactions.mdc</path>
<tokens>552</tokens></file>
<file><path>/home/mike/repos/.cursor/rules/nix-rules.mdc</path>
<tokens>964</tokens></file>
<file><path>/home/mike/repos/.cursor/rules/placeholder-step-pattern.mdc</path>
<tokens>1311</tokens></file>
<file><path>/home/mike/repos/.cursor/rules/wet-workflows.mdc</path>
<tokens>2155</tokens></file>
<file><path>/home/mike/repos/pipulate/training/workflow_implementation_guide.md</path>
<tokens>7471</tokens></file>
<file><path>/home/mike/repos/pipulate/precursors/prompt.md</path>
<tokens>4045</tokens></file></content>
<total>88688</total></files>
</token_usage>
</manifest>
<pre_prompt><context><system_info>
You are about to review a codebase and related documentation. Please study and understand
the provided materials thoroughly before responding.
Key things to know about this codebase:
- It uses a hybrid approach with Nix for system dependencies and virtualenv for Python packages
- Always run `nix develop` before any commands in a new terminal
- FastHTML objects must be converted with to_xml() before returning responses
- The project is organized as a server with plugin-based workflows
</system_info>
<key_points><point>Focus on understanding the architecture and patterns in the codebase</point>
<point>Note how existing patterns could be leveraged in your response</point>
<point>Consider both technical and conceptual aspects in your analysis</point></key_points></context></pre_prompt>
<content>
<files>
<file><path>server.py</path>
<description>server.py [loaded]</description>
<file_type>python</file_type>
<tokens>25744</tokens></file>
<file><path>flake.nix</path>
<description>flake.nix [loaded]</description>
<file_type>nix</file_type>
<tokens>3301</tokens></file>
<file><path>requirements.txt</path>
<description>requirements.txt [loaded]</description>
<file_type>text</file_type>
<tokens>105</tokens></file>
<file><path>README.md</path>
<description>README.md [loaded]</description>
<file_type>markdown</file_type>
<tokens>5959</tokens></file>
<file><path>.cursorrules</path>
<description>.cursorrules [loaded]</description>
<tokens>974</tokens></file>
<file><path>plugins/20_hello_workflow.py</path>
<description>20_hello_workflow.py [loaded]</description>
<file_type>python</file_type>
<tokens>6757</tokens></file>
<file><path>plugins/60_widget_examples.py</path>
<description>60_widget_examples.py [loaded]</description>
<file_type>python</file_type>
<tokens>19775</tokens></file>
<file><path>plugins/70_blank_workflow.py</path>
<description>70_blank_workflow.py [loaded]</description>
<file_type>python</file_type>
<tokens>3390</tokens></file>
<file><path>plugins/80_splice_workflow.py</path>
<description>80_splice_workflow.py [loaded]</description>
<file_type>python</file_type>
<tokens>6185</tokens></file>
<file><path>/home/mike/repos/.cursor/rules/htmx-chain-reactions.mdc</path>
<description>htmx-chain-reactions.mdc [loaded]</description>
<file_type>text</file_type>
<tokens>552</tokens></file>
<file><path>/home/mike/repos/.cursor/rules/nix-rules.mdc</path>
<description>nix-rules.mdc [loaded]</description>
<file_type>text</file_type>
<tokens>964</tokens></file>
<file><path>/home/mike/repos/.cursor/rules/placeholder-step-pattern.mdc</path>
<description>placeholder-step-pattern.mdc [loaded]</description>
<file_type>text</file_type>
<tokens>1311</tokens></file>
<file><path>/home/mike/repos/.cursor/rules/wet-workflows.mdc</path>
<description>wet-workflows.mdc [loaded]</description>
<file_type>text</file_type>
<tokens>2155</tokens></file>
<file><path>/home/mike/repos/pipulate/training/workflow_implementation_guide.md</path>
<description>workflow_implementation_guide.md [loaded]</description>
<file_type>markdown</file_type>
<tokens>7471</tokens></file>
<file><path>/home/mike/repos/pipulate/precursors/prompt.md</path>
<description>prompt.md [loaded]</description>
<file_type>markdown</file_type>
<tokens>4045</tokens></file>
</files>
<environment>
<setting><type>Runtime</type>
<details>Python 3.12 in a Nix-managed virtualenv (.venv)</details></setting>
<setting><type>Package Management</type>
<details>Hybrid approach using Nix flakes for system dependencies + pip for Python packages</details></setting>
</environment>
<conventions>
<convention><name>FastHTML Rendering</name>
<description>All FastHTML objects must be converted with to_xml() before being returned in HTTP responses</description></convention>
<convention><name>Environment Activation</name>
<description>Always run 'nix develop' in new terminals before any other commands</description></convention>
<convention><name>Dependency Management</name>
<description>System deps go in flake.nix, Python packages in requirements.txt</description></convention>
</conventions>
<critical_patterns>
<pattern><pattern>to_xml(ft_object)</pattern>
<explanation>Required to convert FastHTML objects to strings before HTTP responses</explanation></pattern>
<pattern><pattern>HTMLResponse(str(to_xml(rendered_item)))</pattern>
<explanation>Proper pattern for returning FastHTML content with HTMX triggers</explanation></pattern>
</critical_patterns>
<token_usage>
<files><metadata>273</metadata>
<content><file><path>server.py</path>
<tokens>25744</tokens></file>
<file><path>flake.nix</path>
<tokens>3301</tokens></file>
<file><path>requirements.txt</path>
<tokens>105</tokens></file>
<file><path>README.md</path>
<tokens>5959</tokens></file>
<file><path>.cursorrules</path>
<tokens>974</tokens></file>
<file><path>plugins/20_hello_workflow.py</path>
<tokens>6757</tokens></file>
<file><path>plugins/60_widget_examples.py</path>
<tokens>19775</tokens></file>
<file><path>plugins/70_blank_workflow.py</path>
<tokens>3390</tokens></file>
<file><path>plugins/80_splice_workflow.py</path>
<tokens>6185</tokens></file>
<file><path>/home/mike/repos/.cursor/rules/htmx-chain-reactions.mdc</path>
<tokens>552</tokens></file>
<file><path>/home/mike/repos/.cursor/rules/nix-rules.mdc</path>
<tokens>964</tokens></file>
<file><path>/home/mike/repos/.cursor/rules/placeholder-step-pattern.mdc</path>
<tokens>1311</tokens></file>
<file><path>/home/mike/repos/.cursor/rules/wet-workflows.mdc</path>
<tokens>2155</tokens></file>
<file><path>/home/mike/repos/pipulate/training/workflow_implementation_guide.md</path>
<tokens>7471</tokens></file>
<file><path>/home/mike/repos/pipulate/precursors/prompt.md</path>
<tokens>4045</tokens></file></content>
<total>88688</total></files>
</token_usage>

<context><system_info>
You are about to review a codebase and related documentation. Please study and understand
the provided materials thoroughly before responding.
Key things to know about this codebase:
- It uses a hybrid approach with Nix for system dependencies and virtualenv for Python packages
- Always run `nix develop` before any commands in a new terminal
- FastHTML objects must be converted with to_xml() before returning responses
- The project is organized as a server with plugin-based workflows
</system_info>
<key_points><point>Focus on understanding the architecture and patterns in the codebase</point>
<point>Note how existing patterns could be leveraged in your response</point>
<point>Consider both technical and conceptual aspects in your analysis</point></key_points></context>
==================== START CONTEXT ====================
# <<< START FILE: /home/mike/repos/pipulate/server.py >>>
# Warning: This is an intentionally local-first app using server-side state and HTMX.
# Do not refactor the DictLikeDB or HTMX patterns - see README.md and .cursorrules
# for the design philosophy and contribution guidelines.
import ast
import asyncio
import functools
import importlib
import inspect
import json
import os
import random
import sys
import time
import traceback
from collections import Counter, deque
from datetime import datetime
from pathlib import Path
from typing import AsyncGenerator, Optional
import aiohttp
import uvicorn
from fasthtml.common import *
from loguru import logger
from pyfiglet import Figlet
from rich.console import Console
from rich.json import JSON
from rich.style import Style as RichStyle
from rich.table import Table, Text
from rich.theme import Theme
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.middleware.cors import CORSMiddleware
from starlette.routing import Route
from starlette.websockets import WebSocket, WebSocketDisconnect
from watchdog.events import FileSystemEventHandler
from watchdog.observers import Observer

def get_app_name(force_app_name=None):
    """Get the name of the app from the app_name.txt file, or the parent directory name."""
    name = force_app_name
    if not name:
        app_name_file = 'app_name.txt'
        if Path(app_name_file).exists():
            try:
                name = Path(app_name_file).read_text().strip()
            except:
                pass
        if not name:
            name = Path(__file__).parent.name
            name = name[:-5] if name.endswith('-main') else name
    return name.capitalize()

def fig(text, font='slant', color='cyan', width=200):
    figlet = Figlet(font=font, width=width)
    fig_text = figlet.renderText(str(text))
    colored_text = Text(fig_text, style=f"{color} on default")
    console.print(colored_text, style="on default")

APP_NAME = get_app_name()
TONE = "neutral"
MODEL = "gemma3"
MAX_LLM_RESPONSE_WORDS = 60
MAX_CONVERSATION_LENGTH = 10000
DB_FILENAME = f"data/{APP_NAME.lower()}.db"
PLACEHOLDER_ADDRESS = "www.site.com"
PLACEHOLDER_CODE = "CCode (us, uk, de, etc)"
GRID_LAYOUT = "65% 35%"
NAV_FILLER_WIDTH = "2%"
MIN_MENU_WIDTH = "18vw"
MAX_MENU_WIDTH = "22vw"
WEB_UI_WIDTH = "95%"
WEB_UI_PADDING = "1rem"
WEB_UI_MARGIN = "0 auto"
NOWRAP_STYLE = (
    "white-space: nowrap; "
    "overflow: hidden; "
    "text-overflow: ellipsis;"
)
LIST_SUFFIX = "List"

def setup_logging():
    logs_dir = Path('logs')
    logs_dir.mkdir(parents=True, exist_ok=True)
    app_log_path = logs_dir / f'{APP_NAME}.log'
    logger.remove()
    # Create a function to sanitize HTML tags for the logger
    def sanitize_for_log(record):
        if "message" in record and isinstance(record["message"], str):
            # Replace angle brackets with their HTML entities to prevent logger from parsing HTML tags
            record["message"] = record["message"].replace("<", "&lt;").replace(">", "&gt;")
        return record
    for p in [app_log_path]:
        if p.exists():
            p.unlink()
    logger.add(
        app_log_path,
        rotation="2 MB",
        level="DEBUG",
        format="{time:YYYY-MM-DD HH:mm:ss} | {level: <8} | {name: <15} | {message}",
        enqueue=True,
        filter=sanitize_for_log  # Add our sanitizer function
    )
    logger.add(
        sys.stderr,
        level="DEBUG",
        format=(
            "<green>{time:HH:mm:ss}</green> | "
            "<level>{level: <8}</level> | "
            "<cyan>{name: <15}</cyan> | "
            "<cyan>{message}</cyan>"
        ),
        colorize=True,
        filter=lambda record: (
            sanitize_for_log(record) and  # First sanitize
            (record["level"].name in ["ERROR", "WARNING"] or
             record["level"].name == "INFO" or
             (record["level"].name == "DEBUG" and
              ("HTTP Request:" in record["message"] or
               "Pipeline ID:" in record["message"] or
               "State changed:" in record["message"] or
               record["message"].startswith("Creating") or
               record["message"].startswith("Updated")) and
              not "Pipeline" in record["message"] and
              not record["message"].startswith("DB: __") and
              not "First record" in record["message"] and
              not "Records found" in record["message"] and
              not "dir:" in record["message"])
             )
        )
    )
    return logger.opt(colors=True)

logger = setup_logging()
custom_theme = Theme({
    "default": "white on black",
    "header": RichStyle(
        color="magenta",
        bold=True,
        bgcolor="black"
    ),
    "cyan": RichStyle(
        color="cyan",
        bgcolor="black"
    ),
    "green": RichStyle(
        color="green",
        bgcolor="black"
    ),
    "orange3": RichStyle(
        color="orange3",
        bgcolor="black"
    ),
    "white": RichStyle(
        color="white",
        bgcolor="black"
    ),
})

class DebugConsole(Console):
    def print(self, *args, **kwargs):
        super().print(*args, **kwargs)

console = DebugConsole(theme=custom_theme)

def title_name(word):
    return ' '.join(word.capitalize() for word in word.replace('.', ' ').split('_'))

def endpoint_name(endpoint: str) -> str:
    if endpoint in friendly_names:
        return friendly_names[endpoint]
    return title_name(endpoint)

def step_name(step: str, preserve: bool = False) -> str:
    _, number = step.split('_')
    return f"Step {number.lstrip('0')}"

def step_button(step: str, preserve: bool = False, revert_label: str = None) -> str:
    logger.debug(f"[format_step_button] Entry - step={step}, preserve={preserve}, revert_label={revert_label}")
    _, number = step.split('_')
    symbol = "⟲"if preserve else "↶"
    label = revert_label if revert_label else "Step"
    if revert_label:
        button_text = f"{symbol}\u00A0{label}"
    else:
        button_text = f"{symbol}\u00A0{label}\u00A0{number.lstrip('0')}"
    logger.debug(f"[format_step_button] Generated button text: {button_text}")
    return button_text

class SSEBroadcaster:
    def __init__(self):
        self.queue = asyncio.Queue()
        print("SSE Broadcaster initialized")
    async def generator(self):
        while True:
            try:
                message = await asyncio.wait_for(self.queue.get(), timeout=5.0)
                print(f"SSE sending: {message}")
                if message:
                    formatted = '\n'.join(f"data: {line}"for line in message.split('\n'))
                    yield f"{formatted}\n\n"
            except asyncio.TimeoutError:
                now = datetime.now()
                yield f"data: Test ping at {now}\n\n"
    async def send(self, message):
        print(f"Queueing message: {message}")
        await self.queue.put(message)

broadcaster = SSEBroadcaster()

def read_training(prompt_or_filename):
    if isinstance(prompt_or_filename, str) and prompt_or_filename.endswith('.md'):
        try:
            logger.debug(f"Loading prompt from training/{prompt_or_filename}")
            with open(f"training/{prompt_or_filename}", "r") as f:
                content = f.read()
                logger.debug(f"Successfully loaded prompt: {content[:100]}...")
                return content
        except FileNotFoundError:
            logger.warning(f"No training file found for {prompt_or_filename}")
            return f"No training content available for {prompt_or_filename.replace('.md', '')}"
    return prompt_or_filename

def hot_prompt_injection(prompt_or_filename):
    prompt = read_training(prompt_or_filename)
    append_to_conversation(prompt, role="system", quiet=True)
    return prompt

if MAX_LLM_RESPONSE_WORDS:
    limiter = f"in under {MAX_LLM_RESPONSE_WORDS} {TONE} words"
else:
    limiter = ""
global_conversation_history = deque(maxlen=MAX_CONVERSATION_LENGTH)
conversation = [{"role": "system", "content": read_training("system_prompt.md")}]

def append_to_conversation(message=None, role="user", quiet=False):
    logger.debug("Entering append_to_conversation function")
    if not quiet:
        preview = message[:50] + "..."if isinstance(message, str)else str(message)
        logger.debug(f"Appending to conversation. Role: {role}, Message: {preview}")
    if message is not None:
        if not global_conversation_history or global_conversation_history[0]['role'] != 'system':
            if not quiet:
                logger.debug("Adding system message to conversation history")
            global_conversation_history.appendleft(conversation[0])
        global_conversation_history.append({"role": role, "content": message})
        if not quiet:
            logger.debug(f"Message appended. New conversation history length: {len(global_conversation_history)}")
    logger.debug("Exiting Append to Conversation")
    return list(global_conversation_history)

def pipeline_operation(func):
    @functools.wraps(func)
    def wrapper(self, *args, **kwargs):
        url = args[0]if args else None
        if not url:
            return func(self, *args, **kwargs)
        old_state = self._get_clean_state(url)
        result = func(self, *args, **kwargs)
        new_state = self._get_clean_state(url)
        if old_state != new_state:
            changes = {k: new_state[k] for k in new_state if k not in old_state or old_state[k] != new_state[k]}
            if changes:
                logger.info(f"Pipeline '{url}' state updated: {changes}")
        return result
    return wrapper

class Pipulate:
    """Central coordinator for pipelines and chat functionality.
    This class serves as the main interface for plugins to access
    shared functionality without relying on globals.
    
    # --- Core Architectural Patterns ---
    ## Workflow Step Chain Reaction Pattern
    Pipulate uses a two-level approach to ensuring reliable workflow progression:
    1. Initial Setup (run_all_cells): Creates placeholders with event-based triggers
       - First step: hx_trigger="load"
       - Subsequent steps: hx_trigger="stepComplete-{previous_step.id} from:{previous_step.id}"
    2. Step Implementation (explicit override): Each step's handlers EXPLICITLY trigger
       the next step when completing
       - GET handler (completed state): Returns Div with explicit hx_trigger="load"
       - POST handler (submit): Returns Div with explicit hx_trigger="load"
    This dual approach provides reliability across browsers and complex DOM structures.
    The explicit triggering pattern in step handlers is REQUIRED and should not be
    removed or refactored to rely solely on HTMX event bubbling.
    See 80_splice_workflow.py for the canonical implementation of this pattern.
    """
    PRESERVE_REFILL = True
    # Style constants
    ERROR_STYLE = "color: red;"
    SUCCESS_STYLE = "color: green;"
    # Button styles using PicoCSS classes instead of custom styles
    WARNING_BUTTON_STYLE = None  # Now using cls="secondary outline" instead
    PRIMARY_BUTTON_STYLE = None  # Now using cls="primary" instead
    SECONDARY_BUTTON_STYLE = None  # Now using cls="secondary" instead
    
    # Content style constants
    CONTENT_STYLE = "margin-top: 1vh; border-top: 1px solid var(--pico-muted-border-color); padding-top: 1vh;"
    TREE_CONTENT_STYLE = "padding: 10px; white-space: pre; text-align: left; font-size: 1.5vh;"
    CARD_STYLE = "background-color: var(--pico-card-background-color); border-radius: var(--pico-border-radius); margin-bottom: 2vh;"
    FINALIZED_CONTENT_STYLE = "margin-top: 0.5vh; padding: 0.5vh 0;"
    # Button labels
    UNLOCK_BUTTON_LABEL = "Unlock 🔓"  # Global label for unlock/unfinalize buttons
    def __init__(self, pipeline_table, chat_instance=None):
        """Initialize Pipulate with required dependencies.
        Args:
            pipeline_table: The database table for storing pipeline state
            chat_instance: Optional chat coordinator instance
        """
        self.table = pipeline_table
        self.chat = chat_instance
        # Initialize the message queue
        self.message_queue = self.OrderedMessageQueue()
    class OrderedMessageQueue:
        """A lightweight queue to ensure messages are delivered in order.
        This class creates a simple message queue that ensures messages are delivered
        in the exact order they are added, without requiring explicit delays between
        messages. It's used to fix the message streaming order issues.
        """
        def __init__(self):
            self.queue = []
            self._processing = False
        async def add(self, pipulate, message, **kwargs):
            """Add a message to the queue and process if not already processing."""
            self.queue.append((pipulate, message, kwargs))
            if not self._processing:
                await self._process_queue()
        async def _process_queue(self):
            """Process all queued messages in order."""
            self._processing = True
            try:
                while self.queue:
                    pipulate, message, kwargs = self.queue.pop(0)
                    await pipulate.stream(message, **kwargs)
            finally:
                self._processing = False
    def make_singular(self, word):
        """Convert a potentially plural word to its singular form using simple rules.
        This uses basic suffix replacement rules to handle common English plurals.
        It's designed for the 80/20 rule - handling common cases without complexity.
        Args:
            word (str): The potentially plural word to convert
        Returns:
            str: The singular form of the word
        """
        word = word.strip()
        # Empty string case
        if not word:
            return word
        # Already singular cases
        if word.lower() in ('data', 'media', 'series', 'species', 'news'):
            return word
        # Common irregular plurals
        irregulars = {
            'children': 'child',
            'people': 'person',
            'men': 'man',
            'women': 'woman',
            'teeth': 'tooth',
            'feet': 'foot',
            'geese': 'goose',
            'mice': 'mouse',
            'criteria': 'criterion',
        }
        if word.lower() in irregulars:
            return irregulars[word.lower()]
        # Common suffix rules - ordered by specificity
        if word.lower().endswith('ies'):
            return word[:-3] + 'y'
        if word.lower().endswith('ves'):
            return word[:-3] + 'f'
        if word.lower().endswith('xes') or word.lower().endswith('sses') or word.lower().endswith('shes') or word.lower().endswith('ches'):
            return word[:-2]
        if word.lower().endswith('s') and not word.lower().endswith('ss'):
            return word[:-1]
        # Already singular
        return word
    def set_chat(self, chat_instance):
        """Set the chat instance after initialization."""
        self.chat = chat_instance
    def get_message_queue(self):
        """Return the message queue instance for ordered message delivery."""
        return self.message_queue
    def get_style(self, style_type):
        """Get a predefined style by type"""
        styles = {
            "error": self.ERROR_STYLE,
            "success": self.SUCCESS_STYLE,
            "warning_button": self.WARNING_BUTTON_STYLE,
            "primary_button": self.PRIMARY_BUTTON_STYLE,
            "secondary_button": self.SECONDARY_BUTTON_STYLE
        }
        return styles.get(style_type, "")
    def fmt(self, endpoint: str) -> str:
        """Format an endpoint string into a human-readable form."""
        if endpoint in friendly_names:
            return friendly_names[endpoint]
        # First replace periods with spaces, then hyphens with spaces
        formatted = endpoint.replace('.', ' ').replace('-', ' ')
        # Split by underscores and spaces
        words = []
        for part in formatted.split('_'):
            words.extend(part.split())
        # Capitalize each word and join with spaces
        return ' '.join(word.capitalize() for word in words)
    def _get_clean_state(self, pkey):
        try:
            record = self.table[pkey]
            state = json.loads(record.data)
            state.pop('created', None)
            state.pop('updated', None)
            return state
        except (NotFoundError, json.JSONDecodeError):
            return {}
    def get_timestamp(self) -> str:
        return datetime.now().isoformat()
    def get_plugin_context(self, plugin_instance=None):
        """
        Returns the context information about the current plugin and profile.
        Args:
            plugin_instance: Optional plugin instance to extract name from
        Returns:
            dict: Contains plugin_name, profile_id, and profile_name
        """
        # Get profile_id from the global function
        profile_id = get_current_profile_id()
        # Get profile name from the global function
        profile_name = get_profile_name()
        # Get plugin name from the instance if provided
        plugin_name = None
        display_name = None
        if plugin_instance:
            # Try to get the display name first
            if hasattr(plugin_instance, 'DISPLAY_NAME'):
                display_name = plugin_instance.DISPLAY_NAME
            # Get the internal name
            if hasattr(plugin_instance, 'name'):
                plugin_name = plugin_instance.name
            elif hasattr(plugin_instance, '__class__'):
                plugin_name = plugin_instance.__class__.__name__
            # If we have a plugin_name but no display_name, try to get it from friendly_names
            if plugin_name and not display_name:
                if plugin_name in friendly_names:
                    display_name = friendly_names[plugin_name]
                else:
                    # Fall back to a title-cased version of plugin_name
                    display_name = title_name(plugin_name)
        return {
            'plugin_name': display_name or plugin_name,  # Prefer display name
            'internal_name': plugin_name,  # Keep internal name for reference if needed
            'profile_id': profile_id,
            'profile_name': profile_name
        }
    @pipeline_operation
    def initialize_if_missing(self, pkey: str, initial_step_data: dict = None) -> tuple[Optional[dict], Optional[Card]]:
        try:
            state = self.read_state(pkey)
            if state:
                return state, None
            now = self.get_timestamp()
            state = {"created": now, "updated": now}
            if initial_step_data:
                app_name = None
                if "app_name" in initial_step_data:
                    app_name = initial_step_data.pop("app_name")
                state.update(initial_step_data)
            self.table.insert({"pkey": pkey, "app_name": app_name if app_name else None, "data": json.dumps(state), "created": now, "updated": now})
            return state, None
        except:
            error_card = Card(H3("ID Already In Use"), P(f"The ID '{pkey}' is already being used by another workflow. Please try a different ID."), style=self.id_conflict_style())
            return None, error_card
    def read_state(self, pkey: str) -> dict:
        logger.debug(f"Reading state for pipeline: {pkey}")
        try:
            self.table.xtra(pkey=pkey)
            records = self.table()
            logger.debug(f"Records found: {records}")
            if records:
                logger.debug(f"First record type: {type(records[0])}")
                logger.debug(f"First record dir: {dir(records[0])}")
            if records and hasattr(records[0], 'data'):
                state = json.loads(records[0].data)
                logger.debug(f"Found state: {json.dumps(state, indent=2)}")
                return state
            logger.debug("No valid state found")
            return {}
        except Exception as e:
            logger.debug(f"Error reading state: {str(e)}")
            return {}
    def write_state(self, pkey: str, state: dict) -> None:
        state["updated"] = datetime.now().isoformat()
        payload = {"pkey": pkey, "data": json.dumps(state), "updated": state["updated"]}
        logger.debug(f"Update payload:\n{json.dumps(payload, indent=2)}")
        self.table.update(payload)
        verification = self.read_state(pkey)
        logger.debug(f"Verification read:\n{json.dumps(verification, indent=2)}")
    def format_links_in_text(self, text):
        """
        Convert plain URLs in text to clickable HTML links.
        Safe for logging but renders as HTML in the UI.
        """
        import re
        url_pattern = r'https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+'
        def replace_url(match):
            url = match.group(0)
            return f'<a href="{url}" target="_blank">{url}</a>'
        return re.sub(url_pattern, replace_url, text)
    async def stream(self, message, verbatim=False, role="user",
                     spaces_before=None, spaces_after=1,
                     simulate_typing=True):
        """
        Stream a message to the chat interface.
        This method is now a direct passthrough to the streaming implementation.
        Using this method directly will bypass the OrderedMessageQueue - it's
        recommended to use message_queue.add() for proper message ordering in 
        complex async scenarios.
        Args:
            message: The message to stream
            verbatim: If True, send message as-is; if False, process with LLM
            role: The role for the message in the conversation history
            spaces_before: Number of line breaks to add before the message
            spaces_after: Number of line breaks to add after the message
            simulate_typing: Whether to simulate typing for verbatim messages
        Returns:
            The original message
        """
        try:
            conversation_history = append_to_conversation(message, role)
            if spaces_before:
                for _ in range(spaces_before):
                    await chat.broadcast(" <br>\n")
            if verbatim:
                if simulate_typing:
                    # Split into words and simulate typing for verbatim messages
                    words = message.split(' ')
                    for i, word in enumerate(words):
                        await chat.broadcast(word)
                        if i < len(words) - 1:  # Don't add space after last word
                            await chat.broadcast(' ')
                        await asyncio.sleep(0.005)  # Adjust timing as needed
                else:
                    await chat.broadcast(message)
                response_text = message
            else:
                response_text = ""
                async for chunk in chat_with_llm(MODEL, conversation_history):
                    await chat.broadcast(chunk)
                    response_text += chunk
            if spaces_after:
                for _ in range(spaces_after):
                    await chat.broadcast(" <br>\n")
            append_to_conversation(response_text, "assistant")
            logger.debug(f"Message streamed: {response_text}")
            return message
        except Exception as e:
            logger.error(f"Error in pipulate.stream: {e}")
            traceback.print_exc()
            raise
    def revert_control(
        self,
        step_id: str,
        app_name: str,
        steps: list,
        message: str = None,
        target_id: str = None,
        revert_label: str = None,
        remove_padding: bool = False  # New parameter to control article padding
    ):
        """
        Create a UI control for reverting to a previous workflow step.
        Args:
            step_id: The ID of the step to revert to
            app_name: The workflow app name
            steps: List of Step namedtuples defining the workflow
            message: Optional message to display (defaults to step_id)
            target_id: Optional target for HTMX updates (defaults to app container)
            revert_label: Optional custom label for the revert button
            remove_padding: Whether to remove padding from the article (for advanced layout)
        Returns:
            Card: A FastHTML Card component with revert functionality
        """
        pipeline_id = db.get("pipeline_id", "")
        finalize_step = steps[-1]
        if pipeline_id:
            final_data = self.get_step_data(pipeline_id, finalize_step.id, {})
            if finalize_step.done in final_data:
                return None
        step = next(s for s in steps if s.id == step_id)
        refill = getattr(step, 'refill', False)
        if not target_id:
            target_id = f"{app_name}-container"
        # These are very pretty revert buttons. Do not change them.
        default_style = (
            "background-color: var(--pico-del-color);"
            "display: inline-flex;"
            "padding: 0.5rem 0.5rem;"
            "border-radius: 4px;"
            "font-size: 0.85rem;"
            "cursor: pointer;"
            "margin: 0;"
            "line-height: 1;"
            "align-items: center;"
        )
        form = Form(
            Input(
                type="hidden",
                name="step_id",
                value=step_id
            ),
            Button(
                step_button(step_id, refill, revert_label),
                type="submit",
                style=default_style
            ),
            hx_post=f"/{app_name}/revert",
            hx_target=f"#{target_id}",
            hx_swap="outerHTML"
        )
        if not message:
            return form
        # Base style for the article
        article_style = (
            "display: flex; "
            "align-items: center; "
            "justify-content: space-between; "
            "background-color: var(--pico-card-background-color);"
        )
        
        # Add padding: 0 if remove_padding is True
        if remove_padding:
            article_style += " padding: 0;"
        return Card(
            Div(
                message,
                style="flex: 1;"
            ),
            Div(
                form,
                style="flex: 0;"
            ),
            style=article_style
        )
    def widget_container(
        self,
        step_id: str,
        app_name: str,
        steps: list,
        message: str = None,
        widget=None,
        target_id: str = None,
        revert_label: str = None,
        widget_style=None
    ):
        """
        Create a standardized container for widgets, visualizations, or any dynamic content.
        
        This is the core pattern for displaying rich content below workflow steps while
        maintaining consistent styling and proper DOM targeting for dynamic updates.
        
        The container provides:
        1. Consistent padding/spacing with the revert controls
        2. Unique DOM addressing for targeted updates
        3. Support for both function-based widgets and AnyWidget components
        4. Standard styling that can be overridden when needed
        
        Args:
            step_id: The ID of the step this widget belongs to
            app_name: The workflow app name
            steps: List of Step namedtuples defining the workflow
            message: Optional message to display in the revert control
            widget: The widget/visualization to display (function result or AnyWidget)
            target_id: Optional target for HTMX updates
            revert_label: Optional custom label for the revert button
            widget_style: Optional custom style for the widget container
            
        Returns:
            Div: A FastHTML container with revert control and widget content
        """
        # Get the revert control with padding removed for proper alignment
        revert_row = self.revert_control(
            step_id=step_id,
            app_name=app_name,
            steps=steps,
            message=message,
            target_id=target_id,
            revert_label=revert_label,
            remove_padding=True  # Remove padding for alignment
        )
        
        # If no widget or in finalized state, just return the standard control
        if widget is None or revert_row is None:
            return revert_row
        
        # Use the content style constant as the default
        applied_style = widget_style or self.CONTENT_STYLE
        
        # Create a container with the revert row and widget that looks like a single card
        return Div(
            revert_row,
            Div(
                widget,
                style=applied_style,
                # Unique ID for targeting dynamic updates
                id=f"{step_id}-widget-{hash(str(widget))}"
            ),
            id=f"{step_id}-content",
            style=(
                "background-color: var(--pico-card-background-color); "
                "border-radius: var(--pico-border-radius); "
                "margin-bottom: 2vh; "
                "padding: 1rem;"
            )
        )
    # Keep tree_display as a standard widget function that can be passed to widget_container
    def tree_display(self, content):
        """
        Create a styled display for file paths that can show either a tree or box format.
        
        This is an example of a standard widget function that can be passed to widget_container.
        It demonstrates the pattern for creating reusable, styled components that maintain
        consistent spacing and styling when displayed in the workflow.
        
        Args:
            content: The content to display (either tree-formatted or plain path)
            
        Returns:
            Pre: A Pre component with appropriate styling
        """
        # Check if content is tree-formatted (contains newlines and tree characters)
        is_tree = '\n' in content and ('└─' in content or '├─' in content)
        
        if is_tree:
            # Tree display - use monospace font and preserve whitespace
            return Pre(
                content,
                style=(
                    "font-family: monospace; "
                    "white-space: pre; "
                    "margin: 0; "  # Remove margin to let container control spacing
                    "padding: 0.5rem; "
                    "border-radius: 4px; "
                    "background-color: var(--pico-card-sectionning-background-color);"  # Use PicoCSS variable
                )
            )
        else:
            # Box display - use a blue box with the path
            return Pre(
                content,
                style=(
                    "font-family: system-ui; "
                    "white-space: pre-wrap; "
                    "margin: 0; "  # Remove margin to let container control spacing
                    "padding: 0.5rem 1rem; "
                    "border-radius: 4px; "
                    "background-color: #e3f2fd; "
                    "color: #1976d2; "
                    "border: 1px solid #bbdefb;"
                )
            )
    def finalized_content(
        self,
        message: str,
        content=None,
        heading_tag=H4,
        content_style=None
    ):
        """
        Create a finalized step display with optional additional content.
        
        This is the companion to revert_control_advanced for finalized workflows,
        providing consistent styling for both states.
        
        Args:
            message: Message to display (typically including a 🔒 lock icon)
            content: FastHTML component to display below the message
            heading_tag: The tag to use for the message (default: H4)
            content_style: Optional custom style for the content container
            
        Returns:
            Card: A FastHTML Card component for the finalized state
        """
        if content is None:
            return Card(message)
        
        # Use the finalized content style constant as the default
        applied_style = content_style or self.FINALIZED_CONTENT_STYLE
        
        return Card(
            heading_tag(message),
            Div(
                content,
                style=applied_style
            ),
            style=(
                "background-color: var(--pico-card-background-color); "
                "border-radius: var(--pico-border-radius); "
                "margin-bottom: 2vh; "
                "padding: 1rem;"  # Add consistent padding
            )
        )
    def wrap_with_inline_button(
        self,
        input_element: Input,
        button_label: str = "Next",
        button_class: str = "primary"
    ) -> Div:
        return Div(
            input_element,
            Button(
                button_label,
                type="submit",
                cls=button_class,
                style=(
                    "display: inline-block;"
                    "cursor: pointer;"
                    "width: auto !important;"
                    "white-space: nowrap;"
                )
            ),
            style="display: flex; align-items: center; gap: 0.5rem;"
        )
    async def get_state_message(self, pkey: str, steps: list, messages: dict) -> str:
        state = self.read_state(pkey)
        logger.debug(f"\nDEBUG [{pkey}] State Check:")
        logger.debug(json.dumps(state, indent=2))
        for step in reversed(steps):
            if step.id not in state:
                continue
            if step.done == "finalized":
                if step.done in state[step.id]:
                    return self._log_message("finalized", messages["finalize"]["complete"])
                return self._log_message("ready to finalize", messages["finalize"]["ready"])
            step_data = state[step.id]
            step_value = step_data.get(step.done)
            if step_value:
                msg = messages[step.id]["complete"]
                msg = msg.format(step_value)if "{}" in msg else msg
                return self._log_message(f"{step.id} complete ({step_value})", msg)
        return self._log_message("new pipeline", messages["new"])
    def _log_message(self, state_desc: str, message: str) -> str:
        safe_state = state_desc.replace("<", "\\<").replace(">", "\\>")
        safe_message = message.replace("<", "\\<").replace(">", "\\>")
        logger.debug(f"State: {safe_state}, Message: {safe_message}")
        append_to_conversation(message, role="system", quiet=True)
        return message
    @pipeline_operation
    def get_step_data(self, pkey: str, step_id: str, default=None) -> dict:
        state = self.read_state(pkey)
        return state.get(step_id, default or {})
    async def clear_steps_from(self, pipeline_id: str, step_id: str, steps: list) -> dict:
        state = self.read_state(pipeline_id)
        start_idx = next((i for i, step in enumerate(steps)if step.id == step_id), -1)
        if start_idx == -1:
            logger.error(f"[clear_steps_from] Step {step_id} not found in steps list")
            return state
        for step in steps[start_idx + 1:]:
            if (not self.PRESERVE_REFILL or not step.refill) and step.id in state:
                logger.debug(f"[clear_steps_from] Removing step {step.id}")
                del state[step.id]
        self.write_state(pipeline_id, state)
        return state
    # Add this method to the Pipulate class
    def id_conflict_style(self):
        """Return style for ID conflict error messages"""
        return "background-color: #ffdddd; color: #990000; padding: 10px; border-left: 5px solid #990000;"
    def generate_pipeline_key(self, plugin_instance, user_input=None):
        """Generate a standardized pipeline key using the current profile and plugin.
        Creates a composite key in the format: profile_name-plugin_name-user_id
        If user_input is numeric and less than 100, it will be formatted with leading zeros.
        Args:
            plugin_instance: The plugin instance requesting the key
            user_input: Optional user-provided ID part (defaults to auto-incrementing number)
        Returns:
            tuple: (full_key, prefix, user_part) where:
                full_key: The complete pipeline key
                prefix: The profile-plugin prefix
                user_part: The user-specific part of the key
        """
        # Get context for the key parts
        context = self.get_plugin_context(plugin_instance)
        # Use the display name (plugin_name) instead of internal_name for more user-friendly keys
        plugin_name = context['plugin_name'] or getattr(plugin_instance, 'DISPLAY_NAME', None) or getattr(plugin_instance, 'app_name', 'unknown')
        profile_name = context['profile_name'] or "default"
        # Get the app_name for the database query - this is crucial for proper filtering
        app_name = getattr(plugin_instance, 'app_name', None)
        # Format the prefix parts - replace spaces with underscores but preserve case
        profile_part = profile_name.replace(" ", "_")
        plugin_part = plugin_name.replace(" ", "_")
        prefix = f"{profile_part}-{plugin_part}-"
        # If no user input is provided, generate an auto-incrementing number
        if user_input is None:
            # First, reset any lingering filters
            self.table.xtra()
            # Then filter by app_name to ensure each workflow has its own number sequence
            self.table.xtra(app_name=app_name)
            # Get records for this specific app (workflow type)
            app_records = list(self.table())
            # Find records with the current prefix
            matching_records = [record.pkey for record in app_records
                                if record.pkey.startswith(prefix)]
            # Extract numeric values from the third part of the key
            numeric_suffixes = []
            for record_key in matching_records:
                # Extract the user part (everything after the prefix)
                rec_user_part = record_key.replace(prefix, "")
                # Check if it's purely numeric
                if rec_user_part.isdigit():
                    numeric_suffixes.append(int(rec_user_part))
            # Determine the next number (max + 1, or 1 if none exist)
            next_number = 1
            if numeric_suffixes:
                next_number = max(numeric_suffixes) + 1
            # Format with leading zeros for numbers less than 100
            if next_number < 100:
                user_part = f"{next_number:02d}"
            else:
                user_part = str(next_number)
        else:
            # Use the provided input, with potential formatting
            if isinstance(user_input, int) or (isinstance(user_input, str) and user_input.isdigit()):
                # It's a number, so format it if needed
                number = int(user_input)
                if number < 100:
                    user_part = f"{number:02d}"
                else:
                    user_part = str(number)
            else:
                # Not a number, use as is
                user_part = str(user_input)
        # Create the full key
        full_key = f"{prefix}{user_part}"
        return (full_key, prefix, user_part)
    def parse_pipeline_key(self, pipeline_key):
        """Parse a pipeline key into its component parts.
        Args:
            pipeline_key: The full pipeline key to parse
        Returns:
            dict: Contains profile_part, plugin_part, and user_part components
        """
        parts = pipeline_key.split('-', 2)  # Split into max 3 parts
        if len(parts) < 3:
            # Not enough parts for a valid key
            return {
                'profile_part': parts[0] if len(parts) > 0 else "",
                'plugin_part': parts[1] if len(parts) > 1 else "",
                'user_part': ""
            }
        return {
            'profile_part': parts[0],
            'plugin_part': parts[1],
            'user_part': parts[2]
        }
    def update_datalist(self, datalist_id, options=None, clear=False):
        """Create a datalist with out-of-band swap for updating dropdown options.
        This helper method allows easy updates to datalist options using HTMX's
        out-of-band swap feature. It can either update with new options or clear all options.
        Args:
            datalist_id: The ID of the datalist to update
            options: List of option values to include, or None to clear
            clear: If True, force clear all options regardless of options parameter
        Returns:
            Datalist: A FastHTML Datalist object with out-of-band swap attribute
        """
        if clear or options is None:
            # Return an empty datalist to clear all options
            return Datalist(
                id=datalist_id,
                _hx_swap_oob="true"  # Out-of-band swap to update the dropdown
            )
        else:
            # Create a datalist with the provided options
            return Datalist(
                *[Option(value=opt) for opt in options],
                id=datalist_id,
                _hx_swap_oob="true"  # Out-of-band swap to update the dropdown
            )
    def run_all_cells(self, app_name, steps):
        """
        Create a series of HTMX divs that will trigger a chain reaction of loading all steps.
        
        This method sets up the initial placeholders with event-based triggering, where:
        
        1. The first step loads immediately on trigger="load"
        2. Subsequent steps are configured to wait for 'stepComplete-{previous_step_id}' events
        
        IMPORTANT IMPLEMENTATION NOTE: 
        While this method establishes event-based triggers, the standard workflow pattern in 
        this codebase (see 80_splice_workflow.py) explicitly overrides this with 
        direct 'hx_trigger="load"' attributes in completed step views. This explicit 
        triggering pattern is preferred for reliability over event bubbling in complex workflows.
        
        This dual approach (event-based setup + explicit triggers in steps) ensures the chain
        reaction works consistently across browsers and in complex DOM structures.
        Args:
            app_name: The name of the workflow app
            steps: List of Step namedtuples defining the workflow
        Returns:
            list: List of Div elements configured with HTMX attributes for sequential loading
        """        
        cells = []
        for i, step in enumerate(steps):
            # First step loads immediately, subsequent steps wait for previous to complete
            trigger = ("load" if i == 0 else f"stepComplete-{steps[i - 1].id} from:{steps[i - 1].id}")
            cells.append(
                Div(
                    id=step.id,
                    hx_get=f"/{app_name}/{step.id}",
                    hx_trigger=trigger,
                    hx_swap="outerHTML"
                )
            )
        return cells
    def rebuild(self, app_name, steps):
        """
        Rebuild the entire workflow UI from scratch.
        This is used after state changes that require the entire workflow to be regenerated,
        such as reverting to a previous step or jumping to a specific step. It's a core
        helper method commonly used in workflow methods like finalize, unfinalize, and
        handle_revert.
        The method creates a fresh container with all step placeholders, allowing
        the workflow to reload from the current state.
        Args:
            app_name: The name of the workflow app
            steps: List of Step namedtuples defining the workflow
        Returns:
            Div: Container with all steps ready to be displayed
        """
        # Get the placeholders for all steps
        placeholders = self.run_all_cells(app_name, steps)
        # Return a container with all placeholders
        return Div(
            *placeholders,
            id=f"{app_name}-container"
        )
    def validate_step_input(self, value, step_show, custom_validator=None):
        """
        Validate step input with default and optional custom validation.
        This helper ensures consistent validation across all workflow steps:
        1. Basic validation: Ensures the input is not empty
        2. Custom validation: Applies workflow-specific validation logic if provided
        When validation fails, it returns an error component ready for direct
        display in the UI, helping maintain consistent error handling.
        Args:
            value: The user input value to validate
            step_show: Display name of the step (for error messages)
            custom_validator: Optional function(value) -> (is_valid, error_msg)
        Returns:
            tuple: (is_valid, error_message, P_component_or_None)
        """
        is_valid = True
        error_msg = ""
        # Default validation (non-empty)
        if not value.strip():
            is_valid = False
            error_msg = f"{step_show} cannot be empty"
        # Custom validation if provided
        if is_valid and custom_validator:
            custom_valid, custom_error = custom_validator(value)
            if not custom_valid:
                is_valid = False
                error_msg = custom_error
        if not is_valid:
            return False, error_msg, P(error_msg, style=self.get_style("error"))
        return True, "", None
    async def update_step_state(self, pipeline_id, step_id, step_value, steps, clear_previous=True):
        """
        Update the state for a step and handle reverting.
        This core helper manages workflow state updates, ensuring consistent state 
        management across all workflows. It handles several important tasks:
        1. Clearing subsequent steps when a step is updated (optional)
        2. Storing the new step value in the correct format
        3. Removing any revert target flags that are no longer needed
        4. Persisting the updated state to storage
        Used by workflow step_xx_submit methods to maintain state after form submissions.
        Args:
            pipeline_id: The pipeline key
            step_id: The current step ID
            step_value: The value to store for this step
            steps: The steps list
            clear_previous: Whether to clear steps after this one
        Returns:
            str: The processed step value (for confirmation messages)
        """
        if clear_previous:
            await self.clear_steps_from(pipeline_id, step_id, steps)
        state = self.read_state(pipeline_id)
        step = next((s for s in steps if s.id == step_id), None)
        if step:
            state[step_id] = {step.done: step_value}
            if "_revert_target" in state:
                del state["_revert_target"]
            self.write_state(pipeline_id, state)
        # Return the step value for confirmation message
        return step_value
    def check_finalize_needed(self, step_index, steps):
        """
        Check if we're on the final step before finalization.
        This helper determines if the workflow is ready for finalization by checking
        if the next step in the sequence is the "finalize" step. Workflows use this
        to decide whether to prompt the user to finalize after completing a step.
        Used in step_xx_submit methods to show appropriate finalization prompts
        after the user completes the last regular step in the workflow.
        Args:
            step_index: Index of current step in steps list
            steps: The steps list
        Returns:
            bool: True if the next step is the finalize step
        """
        next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else None
        return next_step_id == "finalize"
    def create_step_navigation(self, step_id, step_index, steps, app_name, processed_val):
        """
        Create the standard navigation controls after a step submission.
        This helper generates a consistent UI pattern for step navigation that includes:
        1. A revert control showing the current step's value
        2. An HTMX-enabled div that EXPLICITLY triggers loading the next step using
           hx_trigger="load" (preferred over relying on HTMX event bubbling)
        
        IMPLEMENTATION NOTE: This explicit triggering pattern is critical for
        reliable workflow progression and should be maintained in all workflow steps.
        Args:
            step_id: The current step ID
            step_index: Index of current step in steps list
            steps: The steps list
            app_name: The workflow app name
            processed_val: The processed value to display
        Returns:
            Div: A FastHTML Div component with revert control and next step trigger
        """
        step = steps[step_index]
        next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else None
        return Div(
            self.revert_control(
                step_id=step_id,
                app_name=app_name,
                message=f"{step.show}: {processed_val}",
                steps=steps
            ),
            Div(
                id=next_step_id,
                hx_get=f"/{app_name}/{next_step_id}",
                hx_trigger="load"  # CRITICAL: Explicit trigger for reliable chain reaction
            ) if next_step_id else Div()
        )
    async def handle_finalized_step(self, pipeline_id, step_id, steps, app_name, plugin_instance=None):
        """
        Handle the case when a step is submitted in finalized state.
        Args:
            pipeline_id: The pipeline key
            step_id: The current step ID
            steps: The steps list
            app_name: The workflow app name
            plugin_instance: Optional plugin instance (for accessing step_messages)
        Returns:
            Div: The rebuilt workflow UI
        """
        state = self.read_state(pipeline_id)
        state[step_id] = {"finalized": True}
        self.write_state(pipeline_id, state)
        # Get step_messages from the plugin instance if provided
        step_messages = {}
        if plugin_instance and hasattr(plugin_instance, 'step_messages'):
            step_messages = plugin_instance.step_messages
        message = await self.get_state_message(pipeline_id, steps, step_messages)
        await self.stream(message, verbatim=True)
        return self.rebuild(app_name, steps)
    async def finalize_workflow(self, pipeline_id, state_update=None):
        """
        Finalize a workflow by marking it as complete and updating its state.
        Args:
            pipeline_id: The pipeline key
            state_update: Optional additional state to update (beyond finalized flag)
        Returns:
            dict: The updated state
        """
        state = self.read_state(pipeline_id)
        # Mark as finalized
        if "finalize" not in state:
            state["finalize"] = {}
        state["finalize"]["finalized"] = True
        state["updated"] = datetime.now().isoformat()
        # Apply additional updates if provided
        if state_update:
            state.update(state_update)
        # Save state
        self.write_state(pipeline_id, state)
        return state
    async def unfinalize_workflow(self, pipeline_id):
        """
        Unfinalize a workflow by removing the finalized flag.
        Args:
            pipeline_id: The pipeline key
        Returns:
            dict: The updated state
        """
        state = self.read_state(pipeline_id)
        # Remove finalization
        if "finalize" in state:
            del state["finalize"]
        state["updated"] = datetime.now().isoformat()
        # Save state
        self.write_state(pipeline_id, state)
        return state

async def chat_with_llm(MODEL: str, messages: list, base_app=None) -> AsyncGenerator[str, None]:
    url = "http://localhost:11434/api/chat"
    payload = {"MODEL": MODEL, "messages": messages, "stream": True}
    accumulated_response = []
    table = Table(title="User Input")
    table.add_column("Role", style="cyan")
    table.add_column("Content", style="orange3")
    if messages:
        last_message = messages[-1]
        role = last_message.get("role", "unknown")
        content = last_message.get("content", "")
        if isinstance(content, dict):
            content = json.dumps(content, indent=2, ensure_ascii=False)
        table.add_row(role, content)
    console.print(table)
    try:
        async with aiohttp.ClientSession()as session:
            async with session.post(url, json=payload)as response:
                if response.status != 200:
                    error_text = await response.text()
                    error_msg = f"Ollama server error: {error_text}"
                    accumulated_response.append(error_msg)
                    yield error_msg
                    return
                yield "\n"
                async for line in response.content:
                    if not line:
                        continue
                    try:
                        chunk = json.loads(line)
                        if chunk.get("done", False):
                            print("\n", end='', flush=True)
                            final_response = "".join(accumulated_response)
                            table = Table(title="Chat Response")
                            table.add_column("Accumulated Response")
                            table.add_row(final_response, style="green")
                            console.print(table)
                            break
                        if content := chunk.get("message", {}).get("content", ""):
                            if content.startswith('\n') and accumulated_response and accumulated_response[-1].endswith('\n'):
                                content = '\n' + content.lstrip('\n')
                            else:
                                content = re.sub(r'\n\s*\n\s*', '\n\n', content)
                                content = re.sub(r'([.!?])\n', r'\1 ', content)
                                content = re.sub(r'\n ([^\s])', r'\n\1', content)
                            print(content, end='', flush=True)
                            accumulated_response.append(content)
                            yield content
                    except json.JSONDecodeError:
                        continue
    except aiohttp.ClientConnectorError as e:
        error_msg = "Unable to connect to Ollama server. Please ensure Ollama is running."
        accumulated_response.append(error_msg)
        yield error_msg
    except Exception as e:
        error_msg = f"Error: {str(e)}"
        accumulated_response.append(error_msg)
        yield error_msg

def get_button_style(button_type="default"):
    """Return button style string based on type."""
    if button_type == "warning":
        return "background-color: var(--pico-primary-background); color: #f66;"
    elif button_type == "primary":
        return "background-color: var(--pico-primary-background); color: #4CAF50;"
    # etc.

def get_current_profile_id():
    """Get the current profile ID, defaulting to the first profile if none is selected."""
    profile_id = db.get("last_profile_id")
    if profile_id is None:
        logger.debug("No last_profile_id found. Finding first available profile.")
        first_profiles = profiles(order_by='id', limit=1)
        if first_profiles:
            profile_id = first_profiles[0].id
            db["last_profile_id"] = profile_id
            logger.debug(f"Set default profile ID to {profile_id}")
        else:
            logger.warning("No profiles found in the database")
    return profile_id

def create_chat_scripts(sortable_selector='.sortable', ghost_class='blue-background-class'):
    # Instead of embedding the script, return a script tag that loads an external file
    # and initializes with the parameters
    init_script = f"""
    document.addEventListener('DOMContentLoaded', (event) => {{
        // Initialize with parameters
        if (window.initializeChatScripts) {{
            window.initializeChatScripts({{
                sortableSelector: '{sortable_selector}',
                ghostClass: '{ghost_class}'
            }});
        }}
    }});
    """
    return Script(src='/static/chat-scripts.js'), Script(init_script), Link(rel='stylesheet', href='/static/chat-styles.css')

class BaseCrud:
    """
    CRUD base class for all Apps. The CRUD is DRY and the Workflows are WET!
    """
    def __init__(self, name, table, toggle_field=None, sort_field=None, sort_dict=None, pipulate_instance=None, chat_function=None):
        self.name = name
        self.table = table
        self.toggle_field = toggle_field
        self.sort_field = sort_field
        self.item_name_field = 'name'
        self.sort_dict = sort_dict or {'id': 'id', sort_field: sort_field}
        self.pipulate_instance = pipulate_instance
        # Create a safer version of send_message
        import asyncio
        import inspect
        
        def safe_send_message(message, verbatim=True):
            if not self.pipulate_instance:
                return
                
            try:
                stream_method = self.pipulate_instance.stream
                if inspect.iscoroutinefunction(stream_method):
                    return asyncio.create_task(
                        stream_method(message, verbatim=verbatim, spaces_after=1)
                    )
                else:
                    # Not async, but needs to be called directly
                    return stream_method(message, verbatim=verbatim, spaces_after=1)
            except Exception as e:
                import logging
                logger = logging.getLogger(__name__)
                logger.error(f"Error in send_message: {e}")
                return None
                
        self.send_message = safe_send_message
    def register_routes(self, rt):
        rt(f'/{self.name}', methods=['POST'])(self.insert_item)
        rt(f'/{self.name}/{{item_id}}', methods=['POST'])(self.update_item)
        rt(f'/{self.name}/delete/{{item_id}}', methods=['DELETE'])(self.delete_item)
        rt(f'/{self.name}/toggle/{{item_id}}', methods=['POST'])(self.toggle_item)
        rt(f'/{self.name}_sort', methods=['POST'])(self.sort_items)
    def get_action_url(self, action, item_id):
        return f"/{self.name}/{action}/{item_id}"
    def render_item(self, item):
        return Li(
            A(
                "🗑",
                href="#",
                hx_swap="outerHTML",
                hx_delete=f"/task/delete/{item.id}",
                hx_target=f"#todo-{item.id}",
                _class="delete-icon",
                style="cursor: pointer; display: inline;"
            ),
            Input(
                type="checkbox",
                checked="1" if item.done else "0",
                hx_post=f"/task/toggle/{item.id}",
                hx_swap="outerHTML",
                hx_target=f"#todo-{item.id}"
            ),
            A(
                item.name,
                href="#",
                _class="todo-title",
                style="text-decoration: none; color: inherit;"
            ),
            data_id=item.id,
            data_priority=item.priority,
            id=f"todo-{item.id}",
            style="list-style-type: none;"
        )
    async def delete_item(self, request, item_id: int):
        try:
            item = self.table[item_id]
            item_name = getattr(item, self.item_name_field, 'Item')
            self.table.delete(item_id)
            logger.debug(f"Deleted item ID: {item_id}")
            action_details = f"The {self.name} item '{item_name}' was removed."
            prompt = action_details
            self.send_message(prompt, verbatim=True)
            # Add a trigger to refresh the profile menu
            response = HTMLResponse("")
            response.headers["HX-Trigger"] = json.dumps({"refreshProfileMenu": {}})
            return response
        except Exception as e:
            error_msg = f"Error deleting item: {str(e)}"
            logger.error(error_msg)
            action_details = f"An error occurred while deleting {self.name} (ID: {item_id}): {error_msg}"
            prompt = action_details
            self.send_message(prompt, verbatim=True)
            return str(e), 500
    async def toggle_item(self, request, item_id: int):
        """Override the BaseCrud toggle_item to handle FastHTML objects properly"""
        try:
            item = self.table[item_id]
            current_status = getattr(item, self.toggle_field)
            new_status = not current_status
            setattr(item, self.toggle_field, new_status)
            updated_item = self.table.update(item)
            item_name = getattr(updated_item, self.item_name_field, 'Item')
            status_text = 'checked' if new_status else 'unchecked'
            action_details = f"The {self.name} item '{item_name}' is now {status_text}."
            self.send_message(action_details, verbatim=True)
            # Get the profile HTML representation
            rendered_profile = self.render_item(updated_item)
            logger.debug(f"[DEBUG] Rendered profile type: {type(rendered_profile)}")
            # Convert FT object to HTML string using to_xml
            html_content = to_xml(rendered_profile)
            logger.debug(f"[DEBUG] HTML content: {html_content[:100]}...")
            return HTMLResponse(html_content)
        except Exception as e:
            error_msg = f"Error toggling item: {str(e)}"
            logger.error(error_msg)
            action_details = f"an error occurred while toggling {self.name} (ID: {item_id}): {error_msg}"
            return str(e), 500
    async def sort_items(self, request):
        """Override the BaseCrud sort_items to also refresh the profile menu"""
        try:
            logger.debug(f"Received request to sort {self.name}.")
            values = await request.form()
            items = json.loads(values.get('items', '[]'))
            logger.debug(f"Parsed items: {items}")
            changes = []
            sort_dict = {}
            for item in items:
                item_id = int(item['id'])
                priority = int(item['priority'])
                self.table.update(id=item_id, **{self.sort_field: priority})
                item_name = getattr(self.table[item_id], self.item_name_field, 'Item')
                sort_dict[item_id] = priority
                changes.append(f"'{item_name}' moved to position {priority}")
            changes_str = '; '.join(changes)
            action_details = f"The {self.name} items were reordered: {changes_str}"
            prompt = action_details
            self.send_message(prompt, verbatim=True)
            logger.debug(f"{self.name.capitalize()} order updated successfully")
            # Add a trigger to refresh the profile menu
            response = HTMLResponse("")
            response.headers["HX-Trigger"] = json.dumps({"refreshProfileMenu": {}})
            return response
        except json.JSONDecodeError as e:
            error_msg = f"Invalid data format: {str(e)}"
            logger.error(error_msg)
            action_details = f"An error occurred while sorting {self.name} items: {error_msg}"
            prompt = action_details
            self.send_message(prompt, verbatim=True)
            return "Invalid data format", 400
        except Exception as e:
            error_msg = f"Error updating {self.name} order: {str(e)}"
            logger.error(error_msg)
            action_details = f"An error occurred while sorting {self.name} items: {error_msg}"
            prompt = action_details
            self.send_message(prompt, verbatim=True)
            return str(e), 500
    async def insert_item(self, request):
        try:
            logger.debug(f"[DEBUG] Starting insert_item for {self.name}")
            form = await request.form()
            logger.debug(f"[DEBUG] Form data: {dict(form)}")
            new_item_data = self.prepare_insert_data(form)
            if not new_item_data:
                logger.debug("[DEBUG] No new_item_data, returning empty")
                return ''
            new_item = await self.create_item(**new_item_data)
            logger.debug(f"[DEBUG] Created new item: {new_item}")
            item_name = getattr(new_item, self.item_name_field, 'Item')
            action_details = f"A new {self.name} item '{item_name}' was added."
            prompt = action_details
            self.send_message(prompt, verbatim=True)
            rendered = self.render_item(new_item)
            logger.debug(f"[DEBUG] Rendered item type: {type(rendered)}")
            logger.debug(f"[DEBUG] Rendered item content: {rendered}")
            return rendered
        except Exception as e:
            error_msg = f"Error inserting {self.name}: {str(e)}"
            logger.error(error_msg)
            action_details = f"An error occurred while adding a new {self.name}: {error_msg}"
            prompt = action_details
            self.send_message(prompt, verbatim=True)
            return str(e), 500
    async def update_item(self, request, item_id: int):
        """Override the BaseCrud update_item to handle FastHTML objects properly"""
        try:
            form = await request.form()
            update_data = self.prepare_update_data(form)
            if not update_data:
                return ''
            item = self.table[item_id]
            before_state = item.__dict__.copy()
            for key, value in update_data.items():
                setattr(item, key, value)
            updated_item = self.table.update(item)
            after_state = updated_item.__dict__
            change_dict = {}
            for key in update_data.keys():
                if before_state.get(key) != after_state.get(key):
                    change_dict[key] = after_state.get(key)
            changes = [f"{key} changed from '{before_state.get(key)}' to '{after_state.get(key)}'"for key in update_data.keys()if before_state.get(key) != after_state.get(key)]
            changes_str = '; '.join(changes)
            item_name = getattr(updated_item, self.item_name_field, 'Item')
            action_details = f"The {self.name} item '{item_name}' was updated. Changes: {self.pipulate_instance.fmt(changes_str)}"
            prompt = action_details
            self.send_message(prompt, verbatim=True)
            logger.debug(f"Updated {self.name} item {item_id}")
            # Get the profile HTML representation
            rendered_profile = self.render_item(updated_item)
            logger.debug(f"[DEBUG] Rendered profile type: {type(rendered_profile)}")
            # Convert FT object to HTML string using to_xml
            html_content = to_xml(rendered_profile)
            logger.debug(f"[DEBUG] HTML content: {html_content[:100]}...")
            return HTMLResponse(html_content)
        except Exception as e:
            error_msg = f"Error updating {self.name} {item_id}: {str(e)}"
            logger.error(error_msg)
            action_details = f"An error occurred while updating {self.name} (ID: {item_id}): {error_msg}"
            prompt = action_details
            self.send_message(prompt, verbatim=True)
            return str(e), 500
    async def create_item(self, **kwargs):
        try:
            logger.debug(f"Creating new {self.name} with data: {kwargs}")
            new_item = self.table.insert(kwargs)
            logger.debug(f"Created new {self.name}: {new_item}")
            return new_item
        except Exception as e:
            logger.error(f"Error creating {self.name}: {str(e)}")
            raise e
    def prepare_insert_data(self, form):
        raise NotImplementedError("Subclasses must implement prepare_insert_data")
    def prepare_update_data(self, form):
        raise NotImplementedError("Subclasses must implement prepare_update_data")

class ProfileApp(BaseCrud):
    def __init__(self, table, pipulate_instance=None):
        super().__init__(
            name=table.name,
            table=table,
            toggle_field='active',
            sort_field='priority',
            pipulate_instance=pipulate_instance
        )
        self.item_name_field = 'name'
        logger.debug(f"Initialized ProfileApp with name={table.name}")
    def render_item(self, profile):
        return render_profile(profile)
    async def insert_item(self, request):
        """Override the BaseCrud insert_item to also refresh the profile menu"""
        try:
            logger.debug(f"[DEBUG] Starting ProfileApp insert_item")
            form = await request.form()
            logger.debug(f"[DEBUG] Form data: {dict(form)}")
            new_item_data = self.prepare_insert_data(form)
            if not new_item_data:
                logger.debug("[DEBUG] No new_item_data, returning empty")
                return ''
            # Create the new profile
            new_profile = await self.create_item(**new_item_data)
            logger.debug(f"[DEBUG] Created new profile: {new_profile}")
            profile_name = getattr(new_profile, self.item_name_field, 'Profile')
            # Log the action
            action_details = f"A new {self.name} '{profile_name}' was added."
            prompt = action_details
            self.send_message(prompt, verbatim=True)
            # Render the new profile item
            rendered_profile = self.render_item(new_profile)
            logger.debug(f"[DEBUG] Rendered profile: {rendered_profile}")
            # Combine the rendered profile with an HTMX trigger to refresh the menu
            response = HTMLResponse(str(to_xml(rendered_profile)))
            response.headers["HX-Trigger"] = json.dumps({"refreshProfileMenu": {}})
            return response
        except Exception as e:
            error_msg = f"Error inserting {self.name}: {str(e)}"
            logger.error(error_msg)
            action_details = f"An error occurred while adding a new {self.name}: {error_msg}"
            prompt = action_details
            self.send_message(prompt, verbatim=True)
            return str(e), 500
    async def toggle_item(self, request, item_id: int):
        """Override the BaseCrud toggle_item to properly handle FastHTML objects"""
        try:
            item = self.table[item_id]
            current_status = getattr(item, self.toggle_field)
            new_status = not current_status
            setattr(item, self.toggle_field, new_status)
            updated_item = self.table.update(item)
            item_name = getattr(updated_item, self.item_name_field, 'Item')
            status_text = 'checked' if new_status else 'unchecked'
            action_details = f"The {self.name} item '{item_name}' is now {status_text}."
            self.send_message(action_details, verbatim=True)
            # Get the profile HTML representation
            rendered_profile = self.render_item(updated_item)
            logger.debug(f"[DEBUG] Rendered profile type: {type(rendered_profile)}")
            # Add a trigger to refresh the profile menu
            response = HTMLResponse(str(to_xml(rendered_profile)))
            response.headers["HX-Trigger"] = json.dumps({"refreshProfileMenu": {}})
            return response
        except Exception as e:
            error_msg = f"Error toggling item: {str(e)}"
            logger.error(error_msg)
            action_details = f"an error occurred while toggling {self.name} (ID: {item_id}): {error_msg}"
            return str(e), 500
    async def update_item(self, request, item_id: int):
        """Override the BaseCrud update_item to properly handle FastHTML objects"""
        try:
            form = await request.form()
            update_data = self.prepare_update_data(form)
            if not update_data:
                return ''
            item = self.table[item_id]
            before_state = item.__dict__.copy()
            for key, value in update_data.items():
                setattr(item, key, value)
            updated_item = self.table.update(item)
            after_state = updated_item.__dict__
            change_dict = {}
            for key in update_data.keys():
                if before_state.get(key) != after_state.get(key):
                    change_dict[key] = after_state.get(key)
            changes = [f"{key} changed from '{before_state.get(key)}' to '{after_state.get(key)}'"for key in update_data.keys()if before_state.get(key) != after_state.get(key)]
            changes_str = '; '.join(changes)
            item_name = getattr(updated_item, self.item_name_field, 'Item')
            action_details = f"The {self.name} item '{item_name}' was updated. Changes: {self.pipulate_instance.fmt(changes_str)}"
            prompt = action_details
            self.send_message(prompt, verbatim=True)
            logger.debug(f"Updated {self.name} item {item_id}")
            # Get the profile HTML representation
            rendered_profile = self.render_item(updated_item)
            logger.debug(f"[DEBUG] Rendered profile type: {type(rendered_profile)}")
            # Add a trigger to refresh the profile menu if the name field was updated
            response = HTMLResponse(str(to_xml(rendered_profile)))
            if 'name' in change_dict:
                response.headers["HX-Trigger"] = json.dumps({"refreshProfileMenu": {}})
            return response
        except Exception as e:
            error_msg = f"Error updating {self.name} {item_id}: {str(e)}"
            logger.error(error_msg)
            action_details = f"An error occurred while updating {self.name} (ID: {item_id}): {error_msg}"
            prompt = action_details
            self.send_message(prompt, verbatim=True)
            return str(e), 500
    def prepare_insert_data(self, form):
        profile_name = form.get('profile_name', '').strip()
        if not profile_name:
            return ''
        max_priority = max(
            (p.priority or 0 for p in self.table()),
            default=-1
        ) + 1
        return {
            "name": profile_name,
            "real_name": form.get('profile_real_name', '').strip(),
            "address": form.get('profile_address', '').strip(),
            "code": form.get('profile_code', '').strip(),
            "active": True,
            "priority": max_priority,
        }
    def prepare_update_data(self, form):
        profile_name = form.get('profile_name', '').strip()
        if not profile_name:
            return ''
        return {
            "name": profile_name,
            "real_name": form.get('profile_real_name', '').strip(),
            "address": form.get('profile_address', '').strip(),
            "code": form.get('profile_code', '').strip(),
        }

def render_profile(profile):
    def count_records_with_xtra(table_handle, xtra_field, xtra_value):
        table_handle.xtra(**{xtra_field: xtra_value})
        count = len(table_handle())
        logger.debug(f"Counted {count} records in table for {xtra_field} = {xtra_value}")
        return count
    delete_icon_visibility = 'inline'
    delete_url = profile_app.get_action_url('delete', profile.id)
    toggle_url = profile_app.get_action_url('toggle', profile.id)
    delete_icon = A(
        '🗑',
        hx_delete=delete_url,
        hx_target=f'#profile-{profile.id}',
        hx_swap='outerHTML',
        style=f"cursor: pointer; display: {delete_icon_visibility}; text-decoration: none; margin-left: 10px;",
        cls="delete-icon"
    )
    active_checkbox = Input(
        type="checkbox",
        name="active" if profile.active else None,
        checked=profile.active,
        hx_post=toggle_url,
        hx_target=f'#profile-{profile.id}',
        hx_swap="outerHTML",
        style="margin-right: 5px;"
    )
    update_form = Form(
        Group(
            Input(
                type="text",
                name="profile_name",
                value=profile.name,
                placeholder="Name",
                id=f"name-{profile.id}"
            ),
            Input(
                type="text",
                name="profile_real_name",
                value=profile.real_name,
                placeholder="Real Name",
                id=f"real_name-{profile.id}"
            ),
            Input(
                type="text",
                name="profile_address",
                value=profile.address,
                placeholder=PLACEHOLDER_ADDRESS,
                id=f"address-{profile.id}"
            ),
            Input(
                type="text",
                name="profile_code",
                value=profile.code,
                placeholder=PLACEHOLDER_CODE,
                id=f"code-{profile.id}"
            ),
            Button("Update", type="submit"),
        ),
        hx_post=f"/{profile_app.name}/{profile.id}",
        hx_target=f'#profile-{profile.id}',
        hx_swap='outerHTML',
        style="display: none;",
        id=f'update-form-{profile.id}'
    )
    title_link = Span(
        f"{profile.name}",
        id=f"profile-text-display-{profile.id}",
        style="margin-left: 5px; cursor: pointer;",
        onclick=(
            "let li = this.closest('li'); "
            "let updateForm = document.getElementById('update-form-" + str(profile.id) + "'); "
            "if (updateForm.style.display === 'none' || updateForm.style.display === '') { "
            "    updateForm.style.display = 'block'; "
            "    li.querySelectorAll('input[type=checkbox], .delete-icon, span, a').forEach(el => el.style.display = 'none'); "
            "} else { "
            "    updateForm.style.display = 'none'; "
            "    li.querySelectorAll('input[type=checkbox], .delete-icon, span, a').forEach(el => el.style.display = 'inline'); "
            "}"
        )
    )
    contact_info = []
    if profile.address:
        contact_info.append(profile.address)
    if profile.code:
        contact_info.append(profile.code)
    contact_info_span = (
        Span(f" ({', '.join(contact_info)})", style="margin-left: 10px;")
        if contact_info else Span()
    )
    return Li(
        Div(
            active_checkbox,
            title_link,
            contact_info_span,
            delete_icon,
            update_form,
            style="display: flex; align-items: center;"
        ),
        id=f'profile-{profile.id}',
        data_id=profile.id,
        data_priority=profile.priority,
        style="list-style-type: none;"
    )
# The following is the default theme and plugins for Prism.js
# https://prismjs.com/download.html#themes=prism-okaidia&languages=markup+css+clike+javascript+markdown+python&plugins=line-numbers+toolbar+copy-to-clipboard
app, rt, (store, Store), (profiles, Profile), (pipeline, Pipeline) = fast_app(
    DB_FILENAME,
    exts='ws',
    live=True,
    default_hdrs=False,
    hdrs=(
        Meta(charset='utf-8'),
        Link(rel='stylesheet', href='/static/pico.css'),
        Link(rel='stylesheet', href='/static/prism.css'),
        Script(src='/static/htmx.js'),
        Script(src='/static/fasthtml.js'),
        Script(src='/static/surreal.js'),
        Script(src='/static/script.js'),
        Script(src='/static/Sortable.js'),
        Script(src='/static/mermaid.min.js'),
        Script(src='/static/marked.min.js'),
        Script(src='/static/prism.js'),
        Script(src='/static/widget-scripts.js'),
        create_chat_scripts('.sortable'),
        Script(type='module')
    ),
    store={
        "key": str,
        "value": str,
        "pk": "key"
    },
    profile={
        "id": int,
        "name": str,
        "real_name": str,
        "address": str,
        "code": str,
        "active": bool,
        "priority": int,
        "pk": "id"
    },
    pipeline={
        "pkey": str,
        "app_name": str,
        "data": str,
        "created": str,
        "updated": str,
        "pk": "pkey"
    }
)

class Chat:
    def __init__(self, app, id_suffix=""):
        self.app = app
        self.id_suffix = id_suffix
        self.logger = logger.bind(name=f"Chat{id_suffix}")
        self.active_websockets = set()
        self.app.websocket_route("/ws")(self.handle_websocket)
        self.logger.debug("Registered WebSocket route: /ws")
    async def broadcast(self, message: str):
        try:
            if isinstance(message, dict):
                if message.get("type") == "htmx":
                    htmx_response = message
                    content = to_xml(htmx_response['content'])
                    formatted_response = f"""<div id="todo-{htmx_response.get('id')}" hx-swap-oob="beforeend:#todo-list">
                        {content}
                    </div>"""
                    for ws in self.active_websockets:
                        await ws.send_text(formatted_response)
                    return
            formatted_msg = message.replace('\n', '<br>')if isinstance(message, str)else str(message)
            for ws in self.active_websockets:
                await ws.send_text(formatted_msg)
        except Exception as e:
            self.logger.error(f"Error in broadcast: {e}")
    async def handle_chat_message(self, websocket: WebSocket, message: str):
        try:
            append_to_conversation(message, "user")
            parts = message.split('|')
            msg = parts[0]
            verbatim = len(parts) > 1 and parts[1] == 'verbatim'
            raw_response = await pipulate.stream(msg, verbatim=verbatim)
            append_to_conversation(raw_response, "assistant")
        except Exception as e:
            self.logger.error(f"Error in handle_chat_message: {e}")
            traceback.print_exc()
    def create_progress_card(self):
        return Card(
            Header("Chat Playground"),
            Form(
                Div(
                    TextArea(
                        id="chat-input",
                        placeholder="Type your message here...",
                        rows="3"
                    ),
                    Button(
                        "Send",
                        type="submit"
                    ),
                    id="chat-form"
                ),
                onsubmit="sendMessage(event)"
            ),
            Div(id="chat-messages"),
            Script("""
                const ws = new WebSocket(`${window.location.protocol === 'https:' ? 'wss:' : 'ws'}://${window.location.host}/ws`);
                
                ws.onmessage = function(event) {
                    const messages = document.getElementById('chat-messages');
                    messages.innerHTML += event.data + '<br>';
                    messages.scrollTop = messages.scrollHeight;
                };
                
                function sendMessage(event) {
                    event.preventDefault();
                    const input = document.getElementById('chat-input');
                    const message = input.value;
                    if (message.trim()) {
                        ws.send(message);
                        input.value = '';
                    }
                }
            """)
        )
    async def handle_websocket(self, websocket: WebSocket):
        try:
            await websocket.accept()
            self.active_websockets.add(websocket)
            self.logger.debug("Chat WebSocket connected")
            while True:
                message = await websocket.receive_text()
                self.logger.debug(f"Received message: {message}")
                await self.handle_chat_message(websocket, message)
        except WebSocketDisconnect:
            self.logger.info("WebSocket disconnected")
        except Exception as e:
            self.logger.error(f"Error in WebSocket connection: {str(e)}")
            self.logger.error(traceback.format_exc())
        finally:
            self.active_websockets.discard(websocket)
            self.logger.debug("WebSocket connection closed")

chat = Chat(app, id_suffix="")
app.add_middleware(CORSMiddleware, allow_origins=["*"], allow_methods=["*"], allow_headers=["*"], allow_credentials=True,)

# Create the Pipulate instance first (needed for plugin initialization)
pipulate = Pipulate(pipeline)
profile_app = ProfileApp(table=profiles, pipulate_instance=pipulate)
profile_app.register_routes(rt)
# Ensure plugins directory exists
if not os.path.exists("plugins"):
    os.makedirs("plugins")
    logger.debug("Created plugins directory")

def build_endpoint_messages(endpoint):
    # Base dictionary for standard endpoints
    endpoint_messages = {
        "": f"Welcome to {APP_NAME}. You are on the home page. Select an app from the menu to get started.",
        "profile": ("This is where you add, edit, and delete profiles (aka clients). "
                    "The Nickname field is the only name shown on the menu so it is safe to use in front of clients. They only see each other's Nicknames."),
    }
    # Add messages for all workflows in our registry
    for plugin_name, plugin_instance in plugin_instances.items():
        if plugin_name not in endpoint_messages:
            # First check for get_endpoint_message method (prioritize dynamic messages)
            if hasattr(plugin_instance, 'get_endpoint_message') and callable(getattr(plugin_instance, 'get_endpoint_message')):
                endpoint_messages[plugin_name] = plugin_instance.get_endpoint_message()
            # Then fall back to static ENDPOINT_MESSAGE attribute
            elif hasattr(plugin_instance, 'ENDPOINT_MESSAGE'):
                endpoint_messages[plugin_name] = plugin_instance.ENDPOINT_MESSAGE
            else:
                class_name = plugin_instance.__class__.__name__
                endpoint_messages[plugin_name] = f"{class_name} app is where you manage your {plugin_name}."
    # These debug logs should be outside the loop or use the endpoint parameter
    if endpoint in plugin_instances:
        plugin_instance = plugin_instances[endpoint]
        logger.debug(f"Checking if {endpoint} has get_endpoint_message: {hasattr(plugin_instance, 'get_endpoint_message')}")
        logger.debug(f"Checking if get_endpoint_message is callable: {callable(getattr(plugin_instance, 'get_endpoint_message', None))}")
        logger.debug(f"Checking if {endpoint} has ENDPOINT_MESSAGE: {hasattr(plugin_instance, 'ENDPOINT_MESSAGE')}")
    return endpoint_messages.get(endpoint, None)

def build_endpoint_training(endpoint):
    # Base dictionary for standard endpoints
    endpoint_training = {
        "": ("You were just switched to the home page."),
        "profile": ("You were just switched to the profile app."),
    }
    # Add training for all workflows in our registry
    for workflow_name, workflow_instance in plugin_instances.items():
        if workflow_name not in endpoint_training:
            # Check for TRAINING_PROMPT attribute
            if hasattr(workflow_instance, 'TRAINING_PROMPT'):
                prompt = workflow_instance.TRAINING_PROMPT
                endpoint_training[workflow_name] = read_training(prompt)
            else:
                class_name = workflow_instance.__class__.__name__
                endpoint_training[workflow_name] = f"{class_name} app is where you manage your workflows."
    # Add the prompt to chat history as a system message
    append_to_conversation(endpoint_training.get(endpoint, ""), "system")
    return

COLOR_MAP = {"key": "yellow", "value": "white", "error": "red", "warning": "yellow", "success": "green", "debug": "blue"}

def db_operation(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        try:
            result = func(*args, **kwargs)
            if func.__name__ == '__setitem__':
                key, value = args[1], args[2]
                if not key.startswith('_') and not key.endswith('_temp'):
                    logger.debug(f"DB: {key} = {str(value)[:50]}...")
            return result
        except Exception as e:
            logger.error(f"DB Error: {e}")
            raise
    return wrapper

class DictLikeDB:
    def __init__(self, store, Store):
        self.store = store
        self.Store = Store
        logger.debug("DictLikeDB initialized.")
    @db_operation
    def __getitem__(self, key):
        try:
            value = self.store[key].value
            logger.debug(f"Retrieved from DB: <{COLOR_MAP['key']}>{key}</{COLOR_MAP['key']}> = <{COLOR_MAP['value']}>{value}</{COLOR_MAP['value']}>")
            return value
        except NotFoundError:
            logger.error(f"Key not found: <{COLOR_MAP['key']}>{key}</{COLOR_MAP['key']}>")
            raise KeyError(key)
    @db_operation
    def __setitem__(self, key, value):
        try:
            self.store.update({"key": key, "value": value})
            logger.debug(f"Updated persistence store: <{COLOR_MAP['key']}>{key}</{COLOR_MAP['key']}> = <{COLOR_MAP['value']}>{value}</{COLOR_MAP['value']}>")
        except NotFoundError:
            self.store.insert({"key": key, "value": value})
            logger.debug(f"Inserted new item in persistence store: <{COLOR_MAP['key']}>{key}</{COLOR_MAP['key']}> = <{COLOR_MAP['value']}>{value}</{COLOR_MAP['value']}>")
    @db_operation
    def __delitem__(self, key):
        try:
            self.store.delete(key)
            logger.warning(f"Deleted key from persistence store: <{COLOR_MAP['key']}>{key}</{COLOR_MAP['key']}>")
        except NotFoundError:
            logger.error(f"Attempted to delete non-existent key: <{COLOR_MAP['key']}>{key}</{COLOR_MAP['key']}>")
            raise KeyError(key)
    @db_operation
    def __contains__(self, key):
        exists = key in self.store
        logger.debug(f"Key '<{COLOR_MAP['key']}>{key}</{COLOR_MAP['key']}>' exists: <{COLOR_MAP['value']}>{exists}</{COLOR_MAP['value']}>")
        return exists
    @db_operation
    def __iter__(self):
        for item in self.store():
            yield item.key
    @db_operation
    def items(self):
        for item in self.store():
            yield item.key, item.value
    @db_operation
    def keys(self):
        return list(self)
    @db_operation
    def values(self):
        for item in self.store():
            yield item.value
    @db_operation
    def get(self, key, default=None):
        try:
            return self[key]
        except KeyError:
            logger.debug(f"Key '<{COLOR_MAP['key']}>{key}</{COLOR_MAP['key']}>' not found. Returning default: <{COLOR_MAP['value']}>{default}</{COLOR_MAP['value']}>")
            return default
    @db_operation
    def set(self, key, value):
        self[key] = value
        return value

db = DictLikeDB(store, Store)
logger.debug("Database wrapper initialized.")

def populate_initial_data():
    logger.debug("Populating initial data.")
    allowed_keys = {'last_app_choice', 'last_visited_url', 'last_profile_id'}
    for key in list(db.keys()):
        if key not in allowed_keys:
            try:
                del db[key]
                logger.debug(f"Deleted non-essential persistent key: {key}")
            except KeyError:
                pass
    if not profiles():
        default_profile = profiles.insert({"name": f"Default {profile_app.name.capitalize()}", "address": "", "code": "", "active": True, "priority": 0, })
        logger.debug(f"Inserted default profile: {default_profile}")
    else:
        default_profile = profiles()[0]

populate_initial_data()

def discover_plugin_files():
    """Discover and import all Python files in the plugins directory.
    This function scans the 'plugins' directory and imports each .py file
    as a module. It skips files:
    - Starting with '__' (like __init__.py)
    - Starting with 'xx_' or 'XX_' (indicating experimental/in-progress plugins)
    - Containing parentheses (like "tasks (Copy).py")
    Returns:
        dict: Mapping of module names to imported module objects
    """
    plugin_modules = {}
    plugins_dir = os.path.join(os.path.dirname(__file__), 'plugins')
    logger.debug(f"Looking for plugins in: {plugins_dir}")
    # Skip if the directory doesn't exist
    if not os.path.isdir(plugins_dir):
        logger.warning(f"Plugins directory not found: {plugins_dir}")
        return plugin_modules
    # Custom sorting function to handle numeric prefixes correctly
    def numeric_prefix_sort(filename):
        import re
        match = re.match(r'^(\d+)_', filename)
        if match:
            return int(match.group(1))  # Return numeric value for sorting
        return float('inf')  # Non-prefixed files come last
    # Find all Python files in the plugins directory
    sorted_files = sorted(os.listdir(plugins_dir), key=numeric_prefix_sort)
    for filename in sorted_files:
        logger.debug(f"Checking file: {filename}")
        # Skip files with parentheses (like "tasks (Copy).py")
        if '(' in filename or ')' in filename:
            logger.debug(f"Skipping file with parentheses: {filename}")
            continue
        # Skip files prefixed with xx_ or XX_ (experimental plugins)
        if filename.lower().startswith('xx_'):
            logger.debug(f"Skipping experimental plugin: {filename}")
            continue
        if filename.endswith('.py') and not filename.startswith('__'):
            # Extract the module name, removing numeric prefix if present
            base_name = filename[:-3]  # Remove .py extension
            # Store both the clean name (for the module) and original name (for imports)
            # Pattern: match digits and underscore at the beginning (like "01_tasks")
            import re
            clean_name = re.sub(r'^\d+_', '', base_name)
            original_name = base_name
            logger.debug(f"Module name: {clean_name} (from {original_name})")
            try:
                # Import using the original filename
                module = importlib.import_module(f'plugins.{original_name}')
                # But store it using the clean name (without numeric prefix)
                plugin_modules[clean_name] = module
                # Attach the original name to the module for reference if needed
                module._original_filename = original_name
                logger.debug(f"Successfully imported module: {clean_name} from {original_name}")
            except ImportError as e:
                logger.error(f"Error importing plugin module {original_name}: {str(e)}")
    logger.debug(f"Discovered plugin modules: {list(plugin_modules.keys())}")
    return plugin_modules

def find_plugin_classes(plugin_modules):
    """Find plugin-compatible classes within imported modules.
    Identifies plugin classes that have a 'landing' method
    and the required attributes or properties. Supports:
    - Workflow plugins with NAME/APP_NAME and DISPLAY_NAME attributes
    - CRUD UI plugins with name/DISPLAY_NAME properties
    Args:
        plugin_modules (dict): Mapping of module names to module objects
    Returns:
        list: List of tuples (module_name, class_name, class_object) for each plugin class
    """
    plugin_classes = []
    for module_name, module in plugin_modules.items():
        logger.debug(f"Examining module: {module_name}")
        for name, obj in inspect.getmembers(module):
            logger.debug(f"Found member in {module_name}: {name}, type: {type(obj)}")
            # Check if it's a class
            if inspect.isclass(obj):
                logger.debug(f"Class found: {module_name}.{name}")
                # Check if the class has a landing method
                if hasattr(obj, 'landing') and callable(getattr(obj, 'landing')):
                    # Check for direct attributes (workflow plugins)
                    has_name_attribute = (
                        hasattr(obj, 'NAME') or
                        hasattr(obj, 'APP_NAME')  # Some plugins use APP_NAME instead
                    )
                    has_display_name = hasattr(obj, 'DISPLAY_NAME')
                    has_attributes = has_name_attribute and has_display_name
                    # Check for properties via class dictionary (CRUD UI plugins)
                    has_properties = False
                    if 'DISPLAY_NAME' in dir(obj) and not has_attributes:
                        # For classes that use property decorators like CrudUI
                        has_properties = True
                    if has_attributes or has_properties:
                        plugin_classes.append((module_name, name, obj))
                        plugin_type = 'property-based' if has_properties else 'attribute-based'
                        name_attr = 'APP_NAME' if hasattr(obj, 'APP_NAME') else 'NAME'
                        logger.debug(f"Found plugin: {module_name}.{name} ({plugin_type}, using {name_attr})")
    logger.debug(f"Discovered plugin classes: {[(m, c) for m, c, _ in plugin_classes]}")
    return plugin_classes

# Dictionary to store instantiated plugin objects
plugin_instances = {}
# Discover plugin files and classes
discovered_modules = discover_plugin_files()
discovered_classes = find_plugin_classes(discovered_modules)
# Ensure these dictionaries are initialized
friendly_names = {"": "Home"}
endpoint_training = {}

def get_display_name(workflow_name):
    instance = plugin_instances.get(workflow_name)
    if instance and hasattr(instance, 'DISPLAY_NAME'):
        return instance.DISPLAY_NAME
    return workflow_name.replace('_', ' ').title()  # Default display name

def get_endpoint_message(workflow_name):
    instance = plugin_instances.get(workflow_name)
    if instance and hasattr(instance, 'ENDPOINT_MESSAGE'):
        # Use our new helper to format links
        message = instance.ENDPOINT_MESSAGE
        if hasattr(pipulate, 'format_links_in_text'):
            try:
                # Check if it's an async method and handle appropriately
                import inspect
                if inspect.iscoroutinefunction(pipulate.format_links_in_text):
                    import asyncio
                    # Create a non-blocking task
                    asyncio.create_task(pipulate.format_links_in_text(message))
                    return message
                else:
                    # Call directly if it's a regular function
                    return pipulate.format_links_in_text(message)
            except Exception as e:
                logger.warning(f"Error formatting links in message: {e}")
                return message
        return message
    return f"{workflow_name.replace('_', ' ').title()} app is where you manage your workflows."  # Default message

# Register workflows
for module_name, class_name, workflow_class in discovered_classes:
    if module_name not in plugin_instances:
        try:
            instance = workflow_class(app, pipulate, pipeline, db)
            plugin_instances[module_name] = instance
            logger.debug(f"Auto-registered workflow: {module_name}")
            # Retrieve and log the endpoint message using the new method
            endpoint_message = get_endpoint_message(module_name)
            logger.debug(f"Endpoint message for {module_name}: {endpoint_message}")
        except Exception as e:
            logger.warning(f"Issue with workflow {module_name}.{class_name} - continuing anyway")
            # Optional: Log error type separately if needed
            logger.debug(f"Error type: {e.__class__.__name__}")
            
            # If it's a coroutine that wasn't awaited, create a task for it
            import inspect
            if inspect.iscoroutine(e):
                import asyncio
                asyncio.create_task(e)
# Use the registry to set friendly names and endpoint messages
for workflow_name, workflow_instance in plugin_instances.items():
    if workflow_name not in friendly_names:
        display_name = get_display_name(workflow_name)
        logger.debug(f"Setting friendly name for {workflow_name}: {display_name}")
        friendly_names[workflow_name] = display_name
    if workflow_name not in endpoint_training:
        endpoint_message = get_endpoint_message(workflow_name)
        logger.debug(f"Setting endpoint message for {workflow_name}")
        endpoint_training[workflow_name] = endpoint_message
base_menu_items = ['']  # Remove 'profile' from here
additional_menu_items = []  # Remove 'mobile_chat' from here
# Get discovered plugins in the order they were discovered (based on numeric prefix)
ordered_plugins = []
for module_name, class_name, workflow_class in discovered_classes:
    if module_name not in ordered_plugins and module_name in plugin_instances:
        ordered_plugins.append(module_name)
MENU_ITEMS = base_menu_items + ordered_plugins + additional_menu_items
logger.debug(f"Dynamic MENU_ITEMS: {MENU_ITEMS}")

@rt('/clear-db', methods=['POST'])
async def clear_db(request):
    # Get the current workflow name and display name
    menux = db.get("last_app_choice", "App")
    workflow_display_name = "Pipeline"
    # Get the display name for the current workflow if available
    if menux and menux in plugin_instances:
        instance = plugin_instances.get(menux)
        if instance and hasattr(instance, 'DISPLAY_NAME'):
            workflow_display_name = instance.DISPLAY_NAME
        else:
            workflow_display_name = friendly_names.get(menux, menux.replace('_', ' ').title())
    # Clear all standard database keys except for navigation state
    last_app_choice = db.get("last_app_choice")
    last_visited_url = db.get("last_visited_url")
    keys = list(db.keys())
    for key in keys:
        del db[key]
    logger.debug(f"{workflow_display_name} DictLikeDB cleared")
    # Restore navigation state
    if last_app_choice:
        db["last_app_choice"] = last_app_choice
    if last_visited_url:
        db["last_visited_url"] = last_visited_url
    # Clear ALL pipeline records - reset any filters first
    # This is crucial to ensure we're not filtering records when fetching to delete
    if hasattr(pipulate.table, 'xtra'):
        # Reset any filters by passing an empty dict to xtra
        pipulate.table.xtra()
    records = list(pipulate.table())
    logger.debug(f"Found {len(records)} records to delete")
    for record in records:
        pipulate.table.delete(record.pkey)
    logger.debug(f"{workflow_display_name} table cleared")
    db["temp_message"] = f"{workflow_display_name} cleared. Next ID will be 01."
    logger.debug(f"{workflow_display_name} DictLikeDB cleared for debugging")
    # Create a response with an empty datalist and a refresh header
    response = Div(
        # Empty datalist with out-of-band swap to clear all options
        pipulate.update_datalist("pipeline-ids", clear=True),
        # Normal message displayed to the user
        P(f"{workflow_display_name} cleared."),
        cls="clear-message"
    )
    # Convert to HTTPResponse to add the refresh header
    html_response = HTMLResponse(str(response))
    html_response.headers["HX-Refresh"] = "true"
    return html_response

def get_profile_name():
    profile_id = get_current_profile_id()
    logger.debug(f"Retrieving profile name for ID: {profile_id}")
    try:
        profile = profiles.get(profile_id)
        if profile:
            logger.debug(f"Found profile: {profile.name}")
            return profile.name
    except NotFoundError:
        logger.warning(f"No profile found for ID: {profile_id}")
        return "Unknown Profile"

async def home(request):
    path = request.url.path.strip('/')
    logger.debug(f"Received request for path: {path}")
    menux = normalize_menu_path(path)
    logger.debug(f"Selected explore item: {menux}")
    db["last_app_choice"] = menux
    db["last_visited_url"] = request.url.path
    # Replace this block with the helper function
    current_profile_id = get_current_profile_id()
    menux = db.get("last_app_choice", "App")
    response = await create_outer_container(current_profile_id, menux)
    logger.debug("Returning response for main GET request.")
    last_profile_name = get_profile_name()
    return Titled(
        f"{APP_NAME} / {title_name(last_profile_name)} / {endpoint_name(menux)}",
        response,
        data_theme="dark",
        style=(
            f"width: {WEB_UI_WIDTH}; "
            f"max-width: none; "
            f"padding: {WEB_UI_PADDING}; "
            f"margin: {WEB_UI_MARGIN};"
        ),
    )

def create_nav_group():
    # Create the initial nav menu
    nav = create_nav_menu()
    # Add a hidden event listener to refresh the profile dropdown
    refresh_listener = Div(
        id="profile-menu-refresh-listener",
        hx_get="/refresh-profile-menu",
        hx_trigger="refreshProfileMenu from:body",
        hx_target="#profile-dropdown-menu",
        hx_swap="outerHTML",
        style="display: none;"
    )
    nav_group_style = ("display: flex; ""align-items: center; ""position: relative;")
    return Group(nav, refresh_listener, style=nav_group_style)

def create_nav_menu():
    logger.debug("Creating navigation menu.")
    menux = db.get("last_app_choice", "App")
    # Use our helper functions for profile id and name
    selected_profile_id = get_current_profile_id()
    selected_profile_name = get_profile_name()
    nav_items = [create_filler_item(), create_profile_menu(selected_profile_id, selected_profile_name), create_app_menu(menux)]
    nav = Div(*nav_items, style="display: flex; gap: 20px;")
    logger.debug("Navigation menu created.")
    return nav

def create_filler_item():
    return Li(Span(" "), style=("display: flex; ""flex-grow: 1; ""justify-content: center; ""list-style-type: none; "f"min-width: {NAV_FILLER_WIDTH}; "),)

def create_profile_menu(selected_profile_id, selected_profile_name):
    # Use our helper instead of passing in selected_profile_id
    selected_profile_id = get_current_profile_id()
    def get_selected_item_style(is_selected):
        return "background-color: var(--pico-primary-background); "if is_selected else ""
    menu_items = []
    menu_items.append(Li(A(f"Edit {endpoint_name(profile_app.name)}s", href=f"/redirect/{profile_app.name}", cls="dropdown-item", style=(f"{NOWRAP_STYLE} ""font-weight: bold; ""border-bottom: 1px solid var(--pico-muted-border-color);""display: block; ""text-align: center; ")), style=("display: block; ""text-align: center; ")))
    active_profiles = profiles("active=?", (True,), order_by='priority')
    for profile in active_profiles:
        is_selected = str(profile.id) == str(selected_profile_id)
        item_style = get_selected_item_style(is_selected)
        menu_items.append(Li(Label(Input(type="radio", name="profile", value=str(profile.id), checked=is_selected, hx_post=f"/select_profile", hx_vals=f'js:{{profile_id: "{profile.id}"}}', hx_target="body", hx_swap="outerHTML",), profile.name, style="display: flex; align-items: center;"), style=f"text-align: left; {item_style}"))
    return Details(
        Summary(f"{profile_app.name.upper()}: {selected_profile_name}",
                id="profile-id"),
        Ul(*menu_items, style="padding-left: 0;"),
        cls="dropdown",
        id="profile-dropdown-menu"  # Add this ID to target for refresh
    )

def normalize_menu_path(path):
    """Convert empty paths to 'home' and return the path otherwise."""
    return "home" if path == "" else path

def create_app_menu(menux):
    menu_items = []
    for item in MENU_ITEMS:
        # Skip profile app in Apps menu
        if item == profile_app.name:
            continue
        # Normalize both the current selection and menu item for comparison
        norm_menux = normalize_menu_path(menux)
        norm_item = normalize_menu_path(item)
        is_selected = norm_item == norm_menux
        item_style = "background-color: var(--pico-primary-background); "if is_selected else ""
        menu_items.append(Li(A(endpoint_name(item), href=f"/redirect/{item}", cls="dropdown-item", style=f"{NOWRAP_STYLE} {item_style}"), style="display: block;"))
    return Details(Summary(f"APP: {endpoint_name(menux)}", id="app-id",), Ul(*menu_items, cls="dropdown-menu",), cls="dropdown",)

async def create_outer_container(current_profile_id, menux):
    nav_group = create_nav_group()
    # Default layout
    return Container(
        nav_group,
        Grid(
            await create_grid_left(menux),
            create_chat_interface(),
            cls="grid",
            style=(
                "display: grid; "
                "gap: 20px; "
                f"grid-template-columns: {GRID_LAYOUT}; "
            ),
        ),
        create_poke_button(),
        style=(
            f"width: {WEB_UI_WIDTH}; "
            f"max-width: none; "
            f"padding: {WEB_UI_PADDING}; "
            f"margin: {WEB_UI_MARGIN};"
        ),
    )

async def create_grid_left(menux, render_items=None):
    if menux == profile_app.name:
        return await profile_render()
    elif menux in plugin_instances:
        workflow_instance = plugin_instances[menux]
        if hasattr(workflow_instance, 'render'):
            return await workflow_instance.render()
        return await workflow_instance.landing()
    else:
        # Default to a simple welcome page if no specific menu is selected
        return Div(
            H2(f"Welcome to {APP_NAME}"),
            P("Please select an option from the menu to get started."),
            id="welcome-content"
        )

def create_chat_interface(autofocus=False):
    msg_list_height = 'height: calc(70vh - 200px);'
    temp_message = None
    if "temp_message" in db:
        temp_message = db["temp_message"]
        del db["temp_message"]
    # Small inline script to set the temp_message variable
    init_script = f"""
    // Set global variables for the external script
    window.PIPULATE_CONFIG = {{
        tempMessage: {json.dumps(temp_message)}
    }};
    """
    return Div(
        Card(
            H3(f"{APP_NAME} Chatbot"),
            Div(
                id='msg-list',
                cls='overflow-auto',
                style=(msg_list_height),
            ),
            Form(
                mk_chat_input_group(value="", autofocus=autofocus),
                onsubmit="sendSidebarMessage(event)",
            ),
            # First load the initialization script with the dynamic variables
            Script(init_script),
            # Then load the external script
            Script(src='/static/chat-interface.js'),
        ),
        id="chat-interface",
        style=(
            "position: sticky; " +
            "top: 20px; " +
            "margin: 0; " +
            "padding: 0; " +
            "overflow: hidden; "
        ),
    )

def mk_chat_input_group(disabled=False, value='', autofocus=True):
    return Group(
        Input(
            id='msg',
            name='msg',
            placeholder='Chat...',
            value=value,
            disabled=disabled,
            autofocus='autofocus' if autofocus else None,
        ),
        Button(
            "Send",
            type='submit',
            id='send-btn',
            disabled=disabled,
        ),
        id='input-group'
    )

def create_poke_button():
    # Get current workflow name from the app choice
    menux = db.get("last_app_choice", "App")
    workflow_display_name = "Pipeline"
    # Get the display name for the current workflow if available
    if menux and menux in plugin_instances:
        instance = plugin_instances.get(menux)
        if instance and hasattr(instance, 'DISPLAY_NAME'):
            workflow_display_name = instance.DISPLAY_NAME
        else:
            workflow_display_name = friendly_names.get(menux, menux.replace('_', ' ').title())
    return Div(
        A(
            f"Clear {workflow_display_name}",
            hx_post="/clear-db",
            hx_swap="none",
            cls="button",
            style="margin-right: 10px;"
        ),
        A(
            f"Poke {MODEL}",
            hx_post="/poke",
            hx_target="#msg-list",
            hx_swap="innerHTML",
            cls="button",
            style="margin-right: 10px;"
        ),
        style=(
            "bottom: 20px; "
            "position: fixed; "
            "right: 20px; "
            "z-index: 1000; "
            "display: flex; "
            "align-items: center; "
        )
    )

async def profile_render():
    all_profiles = profiles()
    logger.debug("Initial profile state:")
    for profile in all_profiles:
        logger.debug(f"Profile {profile.id}: name = {profile.name}, priority = {profile.priority}")
    ordered_profiles = sorted(
        all_profiles,
        key=lambda p: p.priority if p.priority is not None else float('inf')
    )
    logger.debug("Ordered profile list:")
    for profile in ordered_profiles:
        logger.debug(f"Profile {profile.id}: name = {profile.name}, priority = {profile.priority}")
    return Container(
        Grid(
            Div(
                Card(
                    H2(f"{profile_app.name.capitalize()} {LIST_SUFFIX}"),
                    Ul(
                        *[render_profile(profile) for profile in ordered_profiles],
                        id='profile-list',
                        cls='sortable',
                        style="padding-left: 0;"
                    ),
                    footer=Form(
                        Group(
                            Input(
                                placeholder="Nickname",
                                name="profile_name",
                                id="profile-name-input"
                            ),
                            Input(
                                placeholder=f"Real Name",
                                name="profile_menu_name",
                                id="profile-menu-name-input"
                            ),
                            Input(
                                placeholder=PLACEHOLDER_ADDRESS,
                                name="profile_address",
                                id="profile-address-input"
                            ),
                            Input(
                                placeholder=PLACEHOLDER_CODE,
                                name="profile_code",
                                id="profile-code-input"
                            ),
                            Button(
                                "Add",
                                type="submit",
                                id="add-profile-button"
                            ),
                        ),
                        hx_post=f"/{profile_app.name}",
                        hx_target="#profile-list",
                        hx_swap="beforeend",
                        hx_swap_oob="true",
                    ),
                ),
                id="content-container",
            ),
        ),
        Script("""
            document.addEventListener('htmx:afterSwap', function(event) {
                if (event.target.id === 'profile-list' && event.detail.successful) {
                    const form = document.getElementById('add-profile-button').closest('form');
                    form.reset();
                }
            });
        """),
    )

@rt("/sse")
async def sse_endpoint(request):
    return EventStream(broadcaster.generator())

@app.post("/chat")
async def chat_endpoint(request, message: str):
    await pipulate.stream(f"Let the user know {limiter} {message}")
    return ""

@rt('/redirect/{path:path}')
def redirect_handler(request):
    path = request.path_params['path']
    logger.debug(f"Redirecting to: {path}")
    message = build_endpoint_messages(path)
    hot_prompt_injection(message)
    build_endpoint_training(path)
    db["temp_message"] = message
    return Redirect(f"/{path}")

@rt('/poke', methods=['POST'])
async def poke_chatbot():
    logger.debug("Chatbot poke received.")
    poke_message = (f"The user poked the {APP_NAME} Chatbot. ""Respond with a brief, funny comment about being poked.")
    asyncio.create_task(pipulate.stream(poke_message))
    return "Poke received. Countdown to local LLM MODEL..."

@rt('/select_profile', methods=['POST'])
async def select_profile(request):
    logger.debug("Entering select_profile function")
    form = await request.form()
    logger.debug(f"Received form data: {form}")
    profile_id = form.get('profile_id')
    logger.debug(f"Extracted profile_id: {profile_id}")
    if profile_id:
        profile_id = int(profile_id)
        logger.debug(f"Converted profile_id to int: {profile_id}")
        db["last_profile_id"] = profile_id
        logger.debug(f"Updated last_profile_id in db to: {profile_id}")
        profile = profiles[profile_id]
        logger.debug(f"Retrieved profile: {profile}")
        profile_name = getattr(profile, 'name', 'Unknown Profile')
        logger.debug(f"Profile name: {profile_name}")
        prompt = f"You have switched to the '{profile_name}' profile."
        db["temp_message"] = prompt
        logger.debug(f"Stored temp_message in db: {db['temp_message']}")
    redirect_url = db.get("last_visited_url", "/")
    logger.debug(f"Redirecting to: {redirect_url}")
    return Redirect(redirect_url)

class DOMSkeletonMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request, call_next):
        endpoint = request.url.path
        method = request.method
        logger.debug(f"HTTP Request: {method} {endpoint}")
        response = await call_next(request)
        cookie_table = Table(title="Stored Cookie States")
        cookie_table.add_column("Key", style="cyan")
        cookie_table.add_column("Value", style="magenta")
        for key, value in db.items():
            json_value = JSON.from_data(value, indent=2)
            cookie_table.add_row(key, json_value)
        console.print(cookie_table)
        pipeline_table = Table(title="Pipeline States")
        pipeline_table.add_column("Key", style="yellow")
        pipeline_table.add_column("Created", style="magenta")
        pipeline_table.add_column("Updated", style="cyan")
        pipeline_table.add_column("Steps", style="white")
        for record in pipulate.table():
            try:
                state = json.loads(record.data)
                pre_state = json.loads(record.data)
                pipeline_table.add_row(record.pkey, str(state.get('created', '')), str(state.get('updated', '')), str(len(pre_state) - 2))
            except (json.JSONDecodeError, AttributeError)as e:
                logger.error(f"Error parsing pipeline state for {record.pkey}: {e}")
                pipeline_table.add_row(record.pkey, "ERROR", "Invalid State")
        console.print(pipeline_table)
        return response

def print_routes():
    logger.debug('Route Table')
    table = Table(title="Application Routes")
    table.add_column("Type", style="cyan", no_wrap=True)
    table.add_column("Methods", style="yellow on black")
    table.add_column("Path", style="white")
    table.add_column("Duplicate", style="green")
    route_entries = []
    seen_routes = set()
    for app_route in app.routes:
        if isinstance(app_route, Route):
            methods = ", ".join(app_route.methods)
            route_key = (app_route.path, methods)
            if route_key in seen_routes:
                path_style = "red"
                duplicate_status = Text("Yes", style="red")
            else:
                path_style = "white"
                duplicate_status = Text("No", style="green")
                seen_routes.add(route_key)
            route_entries.append(("Route", methods, app_route.path, path_style, duplicate_status))
        elif isinstance(app_route, WebSocketRoute):
            route_key = (app_route.path, "WebSocket")
            if route_key in seen_routes:
                path_style = "red"
                duplicate_status = Text("Yes", style="red")
            else:
                path_style = "white"
                duplicate_status = Text("No", style="green")
                seen_routes.add(route_key)
            route_entries.append(("WebSocket", "WebSocket", app_route.path, path_style, duplicate_status))
        elif isinstance(app_route, Mount):
            route_entries.append(("Mount", "Mounted App", app_route.path, "white", Text("N/A", style="green")))
        else:
            route_entries.append((str(type(app_route)), "Unknown", getattr(app_route, 'path', 'N/A'), "white", Text("N/A", style="green")))
    route_entries.sort(key=lambda x: x[2])
    for entry in route_entries:
        table.add_row(entry[0], entry[1], Text(entry[2], style=f"{entry[3]} on black"), entry[4])
    console.print(table)

@rt('/refresh-profile-menu')
async def refresh_profile_menu(request):
    """Endpoint to refresh just the profile dropdown menu without reloading the whole page."""
    logger.debug("Refreshing profile menu")
    selected_profile_id = get_current_profile_id()
    selected_profile_name = get_profile_name()
    return create_profile_menu(selected_profile_id, selected_profile_name)
ALL_ROUTES = list(set(['', profile_app.name] + MENU_ITEMS))
for item in ALL_ROUTES:
    path = f'/{item}'if item else '/'
    @app.route(path)
    async def home_route(request):
        return await home(request)
app.add_middleware(DOMSkeletonMiddleware)
logger.debug("Application setup completed with DOMSkeletonMiddleware.")
logger.debug(f"Using MODEL: {MODEL}")
print_routes()

def check_syntax(filename):
    with open(filename, 'r')as file:
        source = file.read()
    try:
        ast.parse(source)
        return True
    except SyntaxError as e:
        print(f"Syntax error in {filename}:")
        print(f"  Line {e.lineno}: {e.text}")
        print(f"  {' ' * (e.offset - 1)}^")
        print(f"Error: {e}")
        return False

def restart_server():
    if not check_syntax(Path(__file__)):
        print("Syntax error detected. Please fix the error and save the file again.")
        return
    max_retries = 3
    for attempt in range(max_retries):
        try:
            os.execv(sys.executable, ['python'] + sys.argv)
        except Exception as e:
            print(f"Error restarting server (attempt {attempt + 1}/{max_retries}): {e}")
            if attempt < max_retries - 1:
                print("Waiting 5 seconds before retrying...")
                time.sleep(5)
            else:
                print("Max retries reached. Please restart the server manually.")

class ServerRestartHandler(FileSystemEventHandler):
    def on_modified(self, event):
        path = Path(event.src_path)
        if path.suffix == '.py':  # Check if any Python file is modified
            print(f"{path} has been modified. Checking syntax and restarting...")
            restart_server()

def run_server_with_watchdog():
    fig("SERVER RESTART")
    # print("\n" * 30)
    # Insert Alice
    with open('static/alice.txt', 'r') as file:
        print(file.read())
    # print("\n" * 30)
    event_handler = ServerRestartHandler()
    observer = Observer()
    observer.schedule(event_handler, path='.', recursive=True)
    observer.start()
    try:
        uvicorn.run(app, host="0.0.0.0", port=5001)
    except KeyboardInterrupt:
        observer.stop()
    except Exception as e:
        print(f"Error running server: {e}")
        print("Attempting to restart...")
        restart_server()
    finally:
        observer.join()

if __name__ == "__main__":
    run_server_with_watchdog()

# autopep8 --ignore E501,F405,F403,F541 --in-place server.py
# isort server.py
# vulture server.py
# pylint --disable=all --enable=redefined-outer-name server.py
# File token count: 25,744 tokens
# <<< END FILE: /home/mike/repos/pipulate/server.py >>>
# <<< START FILE: /home/mike/repos/pipulate/flake.nix >>>
#       ____                      _       _                        .--.      ___________
#      |  _ \  __ _ _ ____      _(_)_ __ (_)_  __    ,--./,-.     |o_o |    |     |     |
#      | | | |/ _` | '__\ \ /\ / / | '_ \| \ \/ /   / #      \    |:_/ |    |     |     |
#      | |_| | (_| | |   \ V  V /| | | | | |>  <   |          |  //   \ \   |_____|_____|
#      |____/ \__,_|_|    \_/\_/ |_|_| |_|_/_/\_\   \        /  (|     | )  |     |     |
#                                                    `._,._,'  /'\_   _/`\  |     |     |
#      Solving the "Not on my machine" problem well.           \___)=(___/  |_____|_____|
# Most modern development is done on Linux, but Macs are Unix. If you think Homebrew and Docker
# are the solution, you're wrong. Welcome to the world of Nix Flakes! This file defines a complete,
# reproducible development environment. It's like a recipe for your perfect workspace, ensuring
# everyone on your team has the exact same setup, every time. As a bonus, you can use Nix flakes on
# Windows under WSL. Plus, whatever you make will be deployable to the cloud.
{
  # This description helps others understand the purpose of this Flake
  description = "A flake that reports the OS using separate scripts with optional CUDA support and unfree packages allowed.";
  
  # Inputs are the dependencies for our Flake
  # They're pinned to specific versions to ensure reproducibility
  inputs = {
    # nixpkgs is the main repository of Nix packages
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    # flake-utils provides helpful functions for working with Flakes
    flake-utils.url = "github:numtide/flake-utils";
  };
  # Outputs define what our Flake produces
  # In this case, it's a development shell that works across different systems
  outputs = { self, nixpkgs, flake-utils }:
    flake-utils.lib.eachDefaultSystem (system:
      let
        # We're creating a custom instance of nixpkgs
        # This allows us to enable unfree packages like CUDA
        pkgs = import nixpkgs {
          inherit system;
          config = {
            allowUnfree = true;  # This is necessary for CUDA support
          };
        };
        # These helpers let us adjust our setup based on the OS
        isDarwin = pkgs.stdenv.isDarwin;
        isLinux = pkgs.stdenv.isLinux;
        # Common packages that we want available in our environment
        # regardless of the operating system
        commonPackages = with pkgs; [
          python3Full                  # Python 3.x interpreter (highest stable?)
          figlet                       # For creating ASCII art welcome messages
          tmux                         # Terminal multiplexer for managing sessions
          zlib                         # Compression library for data compression
          git                          # Version control system for tracking changes
          curl                         # Command-line tool for transferring data with URLs
          wget                         # Utility for non-interactive download of files from the web
          cmake                        # Cross-platform build system generator
          htop                         # Interactive process viewer for Unix systems
        ] ++ (with pkgs; pkgs.lib.optionals isLinux [
          virtualenv
          gcc                          # GNU Compiler Collection for compiling C/C++ code
          stdenv.cc.cc.lib             # Standard C library for Linux systems
        ]);
        # This script sets up our Python environment and project
        runScript = pkgs.writeShellScriptBin "run-script" ''
          #!/usr/bin/env bash
          
          # Activate the virtual environment
          source .venv/bin/activate
          # Create a fancy welcome message
          if [ ! -f app_name.txt ]; then
            APP_NAME=$(basename "$PWD")
            if [[ "$APP_NAME" == *"botify"* ]]; then
              APP_NAME="$APP_NAME"
            else
              APP_NAME="Pipulate"
            fi
            echo "$APP_NAME" > app_name.txt
          fi
          APP_NAME=$(cat app_name.txt)
          PROPER_APP_NAME=$(echo "$APP_NAME" | awk '{print toupper(substr($0,1,1)) tolower(substr($0,2))}')
          figlet "$PROPER_APP_NAME"
          echo "Welcome to the $PROPER_APP_NAME development environment on ${system}!"
          echo 
          # Install Python packages from requirements.txt
          # This allows flexibility to use the latest PyPI packages
          # Note: This makes the environment less deterministic
          echo "- Confirming pip packages..."
          if pip install --upgrade pip --quiet && \
            pip install -r requirements.txt --quiet; then
              package_count=$(pip list --format=freeze | wc -l)
              echo "- Done. $package_count pip packages present."
          else
              echo "Warning: An error occurred during pip setup."
          fi
          # Check if numpy is properly installed
          if python -c "import numpy" 2>/dev/null; then
            echo "- numpy is importable (good to go!)"
            echo
            echo "Starting JupyterLab and $APP_NAME server automatically..."
            echo "Both will open in your browser..."
            echo
            echo "To view server logs: tmux attach -t server"
            echo "To view JupyterLab logs: tmux attach -t jupyter"
            echo "To stop all services: pkill tmux"
            echo "To restart all services: run-all"
            echo "To start only server: run-server"
            echo "To start only JupyterLab: run-jupyter"
          else
            echo "Error: numpy could not be imported. Check your installation."
          fi
          # Create convenience scripts for managing JupyterLab
          # Note: We've disabled token and password for easier access, especially in WSL environments
          cat << EOF > .venv/bin/start
          #!/bin/sh
          echo "A JupyterLab tab will open in your default browser."
          tmux kill-session -t jupyter 2>/dev/null || echo "No tmux session named 'jupyter' is running."
          tmux new-session -d -s jupyter "source .venv/bin/activate && jupyter lab --NotebookApp.token=\"\" --NotebookApp.password=\"\" --NotebookApp.disable_check_xsrf=True"
          echo "If no tab opens, visit http://localhost:8888/lab"
          echo "To view JupyterLab server: tmux attach -t jupyter"
          echo "To stop JupyterLab server: stop"
          EOF
          chmod +x .venv/bin/start
          cat << EOF > .venv/bin/stop
          #!/bin/sh
          echo "Stopping tmux session 'jupyter'..."
          tmux kill-session -t jupyter 2>/dev/null || echo "No tmux session named 'jupyter' is running."
          echo "The tmux session 'jupyter' has been stopped."
          EOF
          chmod +x .venv/bin/stop
          
          # Create a run-server script
          cat << EOF > .venv/bin/run-server
          #!/bin/sh
          echo "Starting $APP_NAME server..."
          # Kill any running server instances first
          pkill -f "python server.py" || true
          python server.py
          EOF
          chmod +x .venv/bin/run-server
          
          # Create a run-jupyter script
          cat << EOF > .venv/bin/run-jupyter
          #!/bin/sh
          echo "Starting JupyterLab..."
          
          # Kill existing jupyter tmux session
          tmux kill-session -t jupyter 2>/dev/null || true
          
          # Start JupyterLab
          tmux new-session -d -s jupyter "source .venv/bin/activate && jupyter lab --NotebookApp.token=\"\" --NotebookApp.password=\"\" --NotebookApp.disable_check_xsrf=True"
          
          # Wait for JupyterLab to start
          echo "JupyterLab is starting..."
          for i in {1..30}; do
            if curl -s http://localhost:8888 > /dev/null; then
              echo "JupyterLab is ready!"
              break
            fi
            sleep 1
            echo -n "."
          done
          
          echo "JupyterLab started! View logs with: tmux attach -t jupyter"
          EOF
          chmod +x .venv/bin/run-jupyter
          
          # Create a run-all script to restart both servers
          cat << EOF > .venv/bin/run-all
          #!/bin/sh
          echo "JupyterLab will start in the background."
          
          # Kill existing tmux sessions
          tmux kill-session -t jupyter 2>/dev/null || true
          
          # Kill any running server instances
          pkill -f "python server.py" || true
          
          # Start JupyterLab
          echo "Starting JupyterLab..."
          tmux new-session -d -s jupyter "source .venv/bin/activate && jupyter lab --NotebookApp.token=\"\" --NotebookApp.password=\"\" --NotebookApp.disable_check_xsrf=True"
          
          # Wait for JupyterLab to start
          echo "JupyterLab is starting..."
          for i in {1..30}; do
            if curl -s http://localhost:8888 > /dev/null; then
              echo "JupyterLab is ready!"
              break
            fi
            sleep 1
            echo -n "."
          done
          
          echo "JupyterLab started in the background. View logs with: tmux attach -t jupyter"
          echo "Starting $APP_NAME server in the foreground..."
          
          # Open FastHTML in the browser
          (
            # Wait a brief moment to ensure browser doesn't get confused with multiple tabs
            sleep 7
            if command -v xdg-open >/dev/null 2>&1; then
              xdg-open http://localhost:5001 >/dev/null 2>&1 &
            elif command -v open >/dev/null 2>&1; then
              open http://localhost:5001 >/dev/null 2>&1 &
            fi
          ) &
          
          # Run server in foreground
          python server.py
          EOF
          chmod +x .venv/bin/run-all
          
          # Add convenience scripts to PATH
          export PATH="$VIRTUAL_ENV/bin:$PATH"
          
          # Automatically start JupyterLab in background and server in foreground
          # Start JupyterLab in a tmux session
          tmux kill-session -t jupyter 2>/dev/null || true
          tmux new-session -d -s jupyter "source .venv/bin/activate && jupyter lab --NotebookApp.token=\"\" --NotebookApp.password=\"\" --NotebookApp.disable_check_xsrf=True"
          
          # Wait for JupyterLab to start
          echo "JupyterLab is starting..."
          for i in {1..30}; do
            if curl -s http://localhost:8888 > /dev/null; then
              echo "JupyterLab is ready!"
              break
            fi
            sleep 1
            echo -n "."
          done
          
          # Kill any running server instances
          pkill -f "python server.py" || true
          
          # Start the server in foreground
          echo "Starting $APP_NAME server in the foreground..."
          echo "Press Ctrl+C to stop the server."
          
          # Open FastHTML in the browser
          (
            # Wait a brief moment to ensure browser doesn't get confused with multiple tabs
            sleep 7
            if command -v xdg-open >/dev/null 2>&1; then
              xdg-open http://localhost:5001 >/dev/null 2>&1 &
            elif command -v open >/dev/null 2>&1; then
              open http://localhost:5001 >/dev/null 2>&1 &
            fi
          ) &
          
          # Run server in foreground
          python server.py
        '';
        # Base shell hook that just sets up the environment without any output
        baseEnvSetup = pkgs: ''
          # Auto-update: Perform a git pull if this is a git repository
          if [ -d .git ]; then
            echo "Checking for updates..."
            git fetch origin
            LOCAL=$(git rev-parse HEAD)
            REMOTE=$(git rev-parse @{u})
            
            if [ "$LOCAL" != "$REMOTE" ]; then
              echo "Updates found. Pulling latest changes..."
              git pull --ff-only
              echo "Update complete!"
            else
              echo "Already up to date."
            fi
          fi
          
          # Set up the Python virtual environment
          test -d .venv || ${pkgs.python3}/bin/python -m venv .venv
          export VIRTUAL_ENV="$(pwd)/.venv"
          export PATH="$VIRTUAL_ENV/bin:$PATH"
          export LD_LIBRARY_PATH=${pkgs.lib.makeLibraryPath commonPackages}:$LD_LIBRARY_PATH
          # Set up CUDA env vars if available (no output)
          if command -v nvidia-smi &> /dev/null; then
            export CUDA_HOME=${pkgs.cudatoolkit}
            export PATH=$CUDA_HOME/bin:$PATH
            export LD_LIBRARY_PATH=$CUDA_HOME/lib64:$LD_LIBRARY_PATH
          fi
        '';
        # Function to create shells for each OS
        mkShells = pkgs: {
          # Default shell with the full interactive setup
          default = pkgs.mkShell {
            buildInputs = commonPackages ++ (with pkgs; pkgs.lib.optionals (builtins.pathExists "/usr/bin/nvidia-smi") cudaPackages);
            shellHook = ''
              # Kill any running server instances first
              pkill -f "python server.py" || true
              
              ${baseEnvSetup pkgs}
              
              # Set up CUDA if available (with output)
              if command -v nvidia-smi &> /dev/null; then
                echo "CUDA hardware detected."
              else
                echo "No CUDA hardware detected."
              fi
              
              # Run the full interactive script
              ${runScript}/bin/run-script
            '';
          };
          
          # Quiet shell for AI assistants and scripting
          quiet = pkgs.mkShell {
            buildInputs = commonPackages ++ (with pkgs; pkgs.lib.optionals (builtins.pathExists "/usr/bin/nvidia-smi") cudaPackages);
            shellHook = ''
              # Kill any running server instances first
              pkill -f "python server.py" || true
              
              ${baseEnvSetup pkgs}
              # Minimal confirmation, can be removed for zero output
              echo "Quiet Nix environment activated."
            '';
          };
        };
        # Get the shells for the current OS
        shells = mkShells pkgs;
      in {
        # Multiple devShells for different use cases
        devShells = shells;
        
        # The default devShell (when just running 'nix develop')
        devShell = shells.default;
      });
}
# File token count: 3,301 tokens
# <<< END FILE: /home/mike/repos/pipulate/flake.nix >>>
# <<< START FILE: /home/mike/repos/pipulate/requirements.txt >>>
autopep8
isort
pylint
python-minimizer
strip-docs
tiktoken
vulture
aiohttp
beautifulsoup4
dominate
httpx
itables
jupyter-ai[all]
jupyterlab
jupyterlab-spellchecker
jupytext
loguru
matplotlib
nbstripout
pandas
pyfiglet
python_fasthtml
requests
rich
watchdog
google-api-python-client
google-auth
scikit-learn
# File token count: 105 tokens
# <<< END FILE: /home/mike/repos/pipulate/requirements.txt >>>
# <<< START FILE: /home/mike/repos/pipulate/README.md >>>
# Pipulate: Free & Open Source Local-First SEO *with & for* LLMs
![Pipulate Free & Open Source SEO with & for LLMs](/static/pipulate.svg)
> Workflows are WET (explicit & step-by-step). CRUD is DRY (uses BaseApp).  
> You do not need the Cloud because *no lock-in need apply!*  
## What is Pipulate?
Pipulate is a **local-first, single-tenant desktop app framework** featuring AI-assisted, step-by-step workflows. Designed to feel like an Electron app, it uniquely runs a full, reproducible Linux environment within a project folder using Nix, ensuring consistency across macOS, Linux, and Windows (via WSL).
Its primary goals are:
1.  **Empower End-Users (e.g., SEO Practitioners):** Enable non-programmers to run powerful, AI-guided workflows (often ported from Jupyter Notebooks) without needing to interact with Python code directly.
2.  **Serve Developers:** Provide a simple, reproducible environment for building these workflows, leveraging integrated tooling like Jupyter, local LLMs, and a streamlined web framework.
## Core Philosophy & Design
Pipulate is built on a distinct set of principles prioritizing user control, simplicity, and long-term viability:
* **Local-First & Single-Tenant:** Your data, your code, your hardware. The application runs entirely locally, ensuring privacy, maximizing performance by using local resources (CPU/GPU for LLMs, scraping), and eliminating cloud costs or vendor lock-in.
* **Simplicity & Observability ("Know EVERYTHING!"):** We intentionally avoid complex enterprise patterns (heavy ORMs, message queues, client-side state management like Redux/JWT, build steps). State is managed server-side via simple SQLite tables (using MiniDataAPI) and JSON blobs for workflows (using DictLikeDB). This transparency makes debugging intuitive – aiming for that "old-school webmaster feeling" on a modern stack.
* **Reproducibility:** Nix Flakes guarantee identical development and runtime environments across macOS, Linux, and Windows (WSL), solving the "works on my machine" problem.
* **Future-Proofing:** Relies on durable technologies: standard HTTP/HTML (via HTMX), Python (supercharged by AI), Nix (for universal environments), and local AI (Ollama). It aims to connect these "love-worthy" technologies.
* **WET Workflows, DRY CRUD:** Workflows often benefit from explicit, step-by-step code (**W**rite **E**verything **T**wice/Explicit), making them easy to port from notebooks and debug. Standard CRUD operations leverage a reusable `BaseCrud` class for efficiency (**D**on't **R**epeat **Y**ourself).
## Key Technologies Used
Pipulate integrates a carefully selected set of tools aligned with its philosophy:
* **FastHTML:** A Python web framework prioritizing simplicity. It generates HTML directly from Python objects (no template language like Jinja2) and minimizes JavaScript by design, working closely with HTMX. It's distinct from API-focused frameworks like FastAPI.
* **HTMX:** Enables dynamic, interactive UIs directly in HTML via attributes, minimizing the need for custom JavaScript. Pipulate uses it for server-rendered HTML updates.
* **MiniDataAPI:** A lightweight layer for interacting with SQLite. Uses Python dictionaries for schema definition, promoting type safety without the complexity of traditional ORMs.
* **Ollama:** Facilitates running LLMs locally, enabling in-app chat, workflow guidance, and future automation capabilities while ensuring privacy and avoiding API costs.
* **Nix Flakes:** Manages dependencies and creates reproducible environments, ensuring consistency across developers and operating systems, with optional CUDA support.
* **SQLite & Jupyter Notebooks:** Foundational tools for data persistence and the workflow development process (porting from notebooks to Pipulate workflows).
## Target Audience
* **End-Users (e.g., SEO Practitioners):** Individuals who want to use AI-assisted, structured workflows (derived from Python/Jupyter) without needing to write or see the underlying code.
* **Developers:** Those building these workflows, likely porting them from Jupyter Notebooks into the Pipulate framework. They benefit from the simple architecture, reproducibility, and integrated tooling.
---
*by [Mike Levin](https://mikelev.in/)*
---
## How to Install Pipulate
This guide shows you how to install Pipulate using two commands in your terminal. This works on macOS or on Windows using WSL (Windows Subsystem for Linux) with an Ubuntu terminal.
1.  **Install Nix:**
    * Open your Terminal.
    * Copy and paste this command, then press Enter:
        ```shell
        curl --proto '=https' --tlsv1.2 -sSf -L https://install.determinate.systems/nix | sh -s -- install
        ```
    * Follow any instructions on the screen (you might need to type "Yes").
    * **Important:** After the installation finishes, **close your Terminal window completely and open a new one.**
2.  **Install Pipulate:**
    * In the **new** Terminal window you just opened, copy and paste this command, then press Enter:
        ```shell
        curl -L https://pipulate.com/install.sh | sh
        ```
    * This command downloads Pipulate, sets it up in a directory (usually `~/pipulate`), configures automatic updates, and starts the necessary services (like JupyterLab and the Pipulate server). This might take some time the first time you run it. It should automatically open browser tabs when ready.
**That's it! Pipulate is installed.**
**How to Run Pipulate After Installation**
1.  Open a Terminal.
2.  Go to the Pipulate directory. Type:
    ```shell
    cd ~/pipulate
    ```
    *(If it was installed elsewhere, change `~/pipulate` to the correct path)*
3.  Start Pipulate by typing:
    ```shell
    nix develop
    ```
    This command will check for updates automatically, start the Pipulate server and JupyterLab, and should open them in your web browser.
---
## Architecture & Key Concepts
Pipulate features a distinct architecture designed for its local-first, simple, and observable nature.
### Architecture Overview Diagram
This diagram illustrates the high-level components and their interactions:
```
                 ┌─────────────┐ Like Electron, but full Linux subsystem 
                 │   Browser   │ in a folder for macOS and Windows (WSL)
                 └─────┬───────┘
                       │ HTTP/WS
                       ▼
    ┌───────────────────────────────────────┐
    │           Nix Flake Shell             │ - In-app LLM (where it belongs)
    │  ┌───────────────┐  ┌──────────────┐  │ - 100% reproducible
    │  │   FastHTML    │  │    Ollama    │  │ - 100% local
    │  │   HTMX App    │  │  Local LLM   │  │ - 100% multi-OS    
    │  └───────┬───────┘  └──────────────┘  │
    │          │                            │
    │    ┌─────▼─────┐     ┌────────────┐   │
    │    │MiniDataAPI│◄───►│ SQLite DB  │   │
    │    └───────────┘     └────────────┘   │
    └───────────────────────────────────────┘
```
### Integrated Data Science Environment
Jupyter Notebooks run alongside the FastHTML server, allowing developers to prototype workflows in a familiar environment before porting them to Pipulate's step-based interface for end-users. The same Python virtual environment (`.venv`) is shared, and ad-hoc package installation is supported.
```
      ┌──────────────────┐    ┌──────────────────┐
      │   Jupyter Lab    │    │    FastHTML      │
      │   Notebooks      │    │     Server       │
      │ ┌──────────┐     │    │  ┌──────────┐    │
      │ │ Cell 1   │     │    │  │ Step 1   │    │
      │ │          │     │--->│  │          │    │
      │ └──────────┘     │    │  └──────────┘    │
      │ ┌──────────┐     │    │  ┌──────────┐    │
      │ │ Cell 2   │     │    │  │ Step 2   │    │
      │ │          │     │--->│  │          │    │
      │ └──────────┘     │    │  └──────────┘    │
      │  localhost:8888  │    │  localhost:5001  │
      └──────────────────┘    └──────────────────┘
```
### Local-First & Single-Tenant Details
Pipulate manages all state server-side within the local environment, avoiding cloud dependencies. This approach offers:
* **Privacy & Control:** Data never leaves the user's machine.
* **Full Resource Access:** Utilize local CPU/GPU freely for intensive tasks (scraping, 24/7 AI processing) at minimal cost.
* **Simplicity:** Eliminates complexities associated with multi-tenancy, cloud deployment, and distributed state.
* **Observability:** State changes (via DictLikeDB/JSON) are transparent and easily logged.
```
      ┌───────────────────────────────┐ # Benefits of Local-First Simplicity
      │          Web Browser          │
      │                               │ - No mysterious client-side state
      │    ┌────────────────────┐     │ - No full-stack framework churn
      │    │   Server Console   │     │ - No complex ORM or SQL layers
      │    │     & Web Logs     │     │ - No external message queues
      │    └─────────┬──────────┘     │ - No build step required
      │              ▼                │ - Direct, observable state changes
      │    ┌─────────────────────┐    │
      │    │  Server-Side State  │    │ 
      │    │  DictLikeDB + JSON  │ ◄─── (Conceptually like server-side cookies)
      │    └─────────────────────┘    │ - Enables the "Know EVERYTHING!" philosophy
      └───────────────────────────────┘
```
### Server-Rendered UI (HTMX)
The UI is constructed primarily with server-rendered HTML fragments delivered via HTMX. This minimizes client-side JavaScript complexity.
* FastHTML generates HTML components directly from Python.
* HTMX handles partial page updates based on user interactions, requesting new HTML snippets from the server.
* WebSockets and Server-Sent Events (SSE) provide real-time updates (e.g., for chat, live development reloading).
```
                    HTMX+Python enables a world-class
                   Python front-end Web Development environment.
                             ┌─────────────────────┐
                             │    Navigation Bar   │  - No template language (like Jinja2)
                             ├─────────┬───────────┤  - HTML elements are Python functions
  Simple Python back-end     │  Main   │   Chat    │  - Minimal custom JavaScript
  HTMX "paints" HTML into    │  Area   │ Interface │  - No React/Vue/Angular overhead
  the DOM on demand──────►   │         │           │  - No virtual DOM, JSX, Redux, etc.
                             └─────────┴───────────┘
```
### Pipeline Workflows
Designed for porting notebook-style processes, workflows are sequences of steps where the state is managed explicitly at each stage and stored persistently (typically as a JSON blob in the `pipeline` table).
* **Resumable & Interrupt-Safe:** Because each step's completion is recorded, workflows can be stopped and resumed.
* **Explicit State Flow:** Data typically passes from one step's output (`done` field) to the next via the `transform` function, simplifying debugging.
* **Good Training Data:** The structured input/output of each step creates valuable data for potentially fine-tuning models.
```
  ┌─────────┐        ┌─────────┐        ┌─────────┐   - Fully customizable steps
  │ Step 01 │─piped─►│ Step 02 │─piped─►│ Step 03 │   - Interruption-safe & resumable
  └─────────┘        └─────────┘        └─────────┘   - Easily ported from Notebooks
       │                  │                  │        - One DB record per workflow run
       ▼                  ▼                  ▼
    State Saved        State Saved        Finalized?
```
### LLM Integration (Ollama)
Integration with a local Ollama instance provides AI capabilities without external API calls:
* **Privacy:** Prompts and responses stay local.
* **Cost-Effective:** No per-token charges; run continuously using local resources.
* **Streaming Support:** Real-time interaction via WebSockets.
* **Bounded Context:** Manages conversation history effectively.
* **Tool Calling:** Can interpret structured JSON from the LLM to execute functions.
```
                   ┌──────────────────┐
                   │   Local Ollama   │ - No API keys needed
                   │      Server      │ - Completely private processing
                   └────────┬─────────┘
                            │ Streaming via WebSocket
                            ▼
                   ┌──────────────────┐
                   │   Pipulate App   │ - Monitors WS for JSON/commands
                   │(WebSocket Client)│ - Parses responses in real-time
                   └────────┬─────────┘
                            │ In-memory or DB backed
                            ▼
                   ┌──────────────────┐
                   │     Bounded      │ - Manages context window (~128k)
                   │   Chat History   │ - Enables RAG / tool integration
                   └──────────────────┘
```
### Multi-OS & CUDA Support (Nix)
Nix Flakes ensure a consistent environment across Linux, macOS, and Windows (via WSL), optionally leveraging CUDA GPUs if detected.
```
                   ┌──────────────────┐
                   │  Linux / macOS   │ - Write code once, run anywhere
                   │  Windows (WSL)   │ - Consistent dev environment via Nix
                   └────────┬─────────┘
                            │ Nix manages dependencies
                            ▼
                   ┌──────────────────┐
                   │   CUDA Support   │ - Auto-detects NVIDIA GPU w/ CUDA
                   │   (if present)   │ - Uses GPU for LLM acceleration
                   └──────────────────┘   - Falls back to CPU if no CUDA
```
### UI Layout
The application interface is organized into distinct areas:
```
    ┌─────────────────────────────┐
    │        Navigation           │ (Profiles, Apps, Search)
    ├───────────────┬─────────────┤
    │               │             │
    │    Main Area  │    Chat     │ (Workflow/App UI)
    │   (Pipeline)  │  Interface  │ (LLM Interaction)
    │               │             │
    ├───────────────┴─────────────┤
    │        Poke Button          │ (Quick Action)
    └─────────────────────────────┘
```
<details>
<summary>UI Component Hierarchy (Click to Expand)</summary>
```
home (Root Component)
    |
    +-- create_outer_container
        |
        +-- create_nav_group
        |   |
        |   +-- create_nav_menu
        |       |
        |       +-- create_profile_menu
        |       +-- create_app_menu
        |
        +-- create_grid_left
            |
        +-- create_notebook_interface (Displays steps/cells)
                |
                +-- render_notebook_cells()
                    |
                    +-- render_notebook_cell(step_01)
                    +-- render_notebook_cell(step_02)
                    +-- ...
        |
        +-- create_chat_interface
            |
            +-- mk_chat_input_group
        |
        +-- create_poke_button
```
</details>
### Communication Channels
Pipulate uses standard web technologies for real-time updates:
* **WebSockets:** Bidirectional communication, primarily used for streaming LLM interactions (user-to-LLM prompts, LLM-to-user responses, potential tool calls).
* **Server-Sent Events (SSE):** Unidirectional (server-to-client) communication used for pushing UI updates triggered by server-side state changes or live reloading during development.
### File Structure
The project aims for a flat, understandable structure:
```plaintext
    .
    ├── .venv/                # Virtual environment (shared by server & Jupyter)
    ├── apps/                 # CRUD application plugins (e.g., profiles_app.py)
    ├── data/
    │   └── data.db           # SQLite database
    ├── downloads/            # Default location for workflow outputs (e.g., CSVs)
    ├── logs/
    │   └── server.log        # Server logs (useful for debugging / AI context)
    ├── static/               # JS, CSS, images
    ├── training/             # Markdown files for AI context/prompts
    ├── workflows/            # Workflow plugins (e.g., hello_flow.py)
    ├── .cursorrules          # Guidelines for AI code editing (if using Cursor)
    ├── flake.nix             # Nix flake definition for reproducibility
    ├── LICENSE
    ├── README.md             # This file
    ├── requirements.txt      # Python dependencies (managed by Nix)
    ├── server.py             # Main application entry point
    └── start/stop            # Scripts for managing Jupyter (if used)
```
-----
## Key Design Guidelines & Patterns
These "speedbumps" reinforce Pipulate's core philosophy:
  * **Local vs. Enterprise Mindset:** Embrace local-first simplicity. Avoid patterns designed for distributed, multi-tenant systems.
  * **JSON State Management (Workflows):** Keep workflow state in self-contained steps within a single JSON blob per run. Avoid complex state machines or external step tracking.
  * **Database (MiniDataAPI):** Use the simple schema definition and access patterns provided. Avoid heavy ORMs.
  * **Workflow Pattern:** Ensure workflows are linear and state is explicitly passed or saved at each step. Avoid complex async task chaining that obscures state.
  * **UI Rendering Pattern:** Generate HTML directly from Python components via FastHTML. Avoid template engines.
  * **WebSocket Pattern:** Use the dedicated `Chat` class for managing LLM interactions. Avoid raw WebSocket handling elsewhere.
  * **Workflow Progression Pattern:** Workflows use an explicit chain reaction pattern with `hx_trigger="load"` to manage step progression. This pattern must be preserved exactly as implemented. See the workflow documentation for details.
-----
## Core Concepts & Internal Components
Pipulate uses two main patterns for adding functionality:
1.  **CRUD Apps (`BaseCrud`):** For standard data management tasks (Create, Read, Update, Delete). Inherit from `BaseCrud` provided by the framework. Examples: `profiles_app.py`, `todo_app.py`.
2.  **Workflows (No Superclass):** For linear, step-by-step processes, often ported from Jupyter Notebooks. These are plain Python classes following a specific convention (steps list, `step_XX` / `step_XX_submit` methods). Example: `hello_flow.py`, `botify_export.py`.
New apps/workflows placed in the `apps/` or `workflows/` directories are automatically discovered and added to the UI navigation.
-----
## Understanding FastHTML & MiniDataAPI
These are key libraries underpinning Pipulate.
### FastHTML vs. FastAPI
FastHTML is chosen for its radical simplicity in building server-rendered UIs with HTMX, *not* for building high-performance JSON APIs like FastAPI. If your goal is a traditional API, FastAPI is likely a better choice. If your goal is a highly interactive, server-rendered UI with minimal JavaScript, FastHTML excels.
\<details\>
\<summary\>FastHTML Code Examples (Click to Expand)\</summary\>
*(Include the minimal, HTMX, and MiniDataAPI examples from the original document here)*
\</details\>
### MiniDataAPI Spec
MiniDataAPI provides simple, dictionary-based interaction with SQLite tables.
  * **Philosophy:** Avoids ORM complexity.
  * **Operations:** `insert()`, `update()`, `delete()`, `.xtra()` (for filtering/ordering), `()` (for fetching).
  * **Type Safety:** Uses paired dataclasses (like `Task` for the `tasks` table object) generated by `fast_app`.
### The `fast_app` Helper
The `fast_app` function in FastHTML is a powerful (and unconventional) helper for setting up the application, router, and database connections.
```python
# Example unpacking from server.py
app, rt, (store, Store), (tasks, Task), (profiles, Profile), (pipeline, Pipeline) = fast_app(
    "data/data.db",  # DB file path
    # Other config like hdrs, live, exts...
    # Schema definitions as keyword arguments:
    store={'key': str, 'value': str, 'pk': 'key'},
    task={'id': int, 'name': str, 'done': bool, 'pk': 'id'},
    profile={'id': int, 'name': str, 'pk': 'id'},
    pipeline={'url': str, 'app_name': str, 'data': str, 'pk': 'url'}
)
```
**Unpacking Explained:**
`fast_app` returns a tuple. We use Python's tuple unpacking:
1.  `app`: The core application instance (like Flask/Starlette/FastAPI).
2.  `rt`: The route decorator (`@rt('/path')`).
3.  `(table_obj, TableClass)` pairs: For each keyword argument defining a table schema (like `task={...}`), `fast_app` returns a tuple containing:
      * The **table object** (e.g., `tasks`) for DB operations (`tasks.insert(...)`).
      * The **dataclass** (e.g., `Task`) representing a row (`Task(...)`).
The order of these pairs in the returned tuple matches the order of the keyword arguments defining the schemas. See the [FastHTML source for `fast_app`](https://github.com/AnswerDotAI/fasthtml/blob/main/fasthtml/fastapp.py) and [this blog post on unpacking](https://mikelev.in/futureproof/unpacking-fasthtml-databases/) for deeper dives.
-----
## Persistence & Monitoring
  * **Persistence:** State for workflows is stored in the `pipeline` table (managed by DictLikeDB), while CRUD apps use tables defined via MiniDataAPI (like `profile`, `task`). All data resides in the local `data/data.db` SQLite file.
  * **Monitoring:** A file system watchdog monitors code changes. Valid changes trigger an automatic, monitored server restart via Uvicorn, facilitating live development.
<!-- end list -->
```
        ┌─────────────┐         ┌──────────────┐
        │ File System │ Changes │  AST Syntax  │ Checks Code
        │  Watchdog   │ Detects │   Checker    │ Validity
        └──────┬──────┘         └───────┬──────┘
               │ Valid Change           │
               ▼                        ▼
 ┌───────────────────────────┐     ┌──────────┐
 │    Uvicorn Server         │◄─── │  Reload  │ Triggers Restart
 │ (Handles HTTP, WS, SSE)   │     │ Process  │
 └───────────────────────────┘     └──────────┘
```
-----
## Final Thoughts
Pipulate offers a unique approach to building local, AI-assisted applications, prioritizing simplicity, user control, and reproducibility over conventional scaling patterns. By understanding its core concepts and embracing its philosophy, developers can create powerful workflows, and end-users can benefit from AI guidance without cloud dependencies.
Remember the guiding principles:
1.  **Keep it simple.**
2.  **Stay local and single-user.**
3.  **Embrace the unconventional.**
-----
## Developer's Notes
### The Pipulate Workshop
The repository includes not only polished plugins but also experimental scripts and notebooks under development (e.g., in the root directory or marked with `xx_` prefix in plugin directories). These represent ongoing work and exploration.
### Plugin Development Conventions
#### Auto-Registration Behavior
  * **Numeric Prefixes:** Files like `workflows/10_hello_flow.py` are registered as `hello_flow` (number stripped for internal name, used for menu order).
  * **Parentheses Skip:** Files with `()` in the name (e.g., `hello_flow (Copy).py`) are skipped – useful for temporary copies during development.
  * **`xx_` Prefix Skip:** Files prefixed with `xx_` (e.g., `xx_experimental_flow.py`) are skipped – useful for keeping unfinished work in the plugin directories without activating it.
#### Workflow for Creating New Plugins
1.  **Copy:** Copy a template (e.g., `starter_flow.py`) to `my_flow (Copy).py`.
2.  **Modify:** Develop your workflow. It won't auto-register yet.
3.  **Test:** Rename to `xx_my_flow.py`. The server should auto-reload. Test thoroughly.
4.  **Deploy:** Rename to `##_my_flow.py` (e.g., `30_my_flow.py`) to assign menu order and activate.
#### Git History Considerations
Use `git mv` for simple renames (like `xx_` to numbered prefix) to preserve history. Document more complex renames in commit messages.
```bash
git mv workflows/xx_my_flow.py workflows/30_my_flow.py
git commit -m "Feat: Promote workflow xx_my_flow.py to 30_my_flow.py"
```
-----
## Roadmap
**Core & Workflow Enhancements:**
  * Dev, Test, and Prod database switching
  * Saving source HTML and rendered DOM of any URL
  * Botify data export CSV save (incorporating robust polling)
  * Full web form field support (textarea, dropdown, checkboxes, radio buttons)
  * Generic support for Anywidgets
  * Utility for deleting garbage tables from plugin experimentation
**AI / LLM Integration:**
  * LLM inspection of any local data object (RAG-style functionality)
  * Various memory types for LLM context (vector embedding, graph, key/val-store)
  * Enabling the local LLM to be an MCP Client
**Automation & External Interaction:**
  * MCP Server for automated web browsing and similar tasks
-----
## Contributing
Contributions are welcome\! Please adhere to the project's core philosophy:
  * Maintain Local-First Simplicity (No multi-tenant patterns, complex ORMs, heavy client-side state).
  * Respect Server-Side State (Use DictLikeDB/JSON for workflows, MiniDataAPI for CRUD).
  * Preserve the Workflow Pipeline Pattern (Keep steps linear, state explicit).
  * Honor Integrated Features (Don't disrupt core LLM/Jupyter integration unless enhancing local goals).
-----
## License
This project is licensed under the MIT License. See the [LICENSE](LICENSE) file for details.

# File token count: 5,959 tokens
# <<< END FILE: /home/mike/repos/pipulate/README.md >>>
# <<< START FILE: /home/mike/repos/pipulate/.cursorrules >>>
# .cursorrules – Local-First Minimalist FastHTML/MiniDataAPI Guidelines
## Core Philosophy
1. **Local-First, Single-Tenant Only:**  
   This code is a stripped-down, single-user, local app—more like an Electron app than an enterprise system. All state is observable server-side through DictLikeDB and JSON blobs.
2. **Server-Side State Only:**  
   No client-side state management (React, Redux) or ORM complexity. Everything lives server-side in a simple, observable data store.
3. **Everything is a DIV:**  
   UI is built entirely from DIVs with HTMX for dynamic updates. No templating engines, component libraries, or client-heavy frameworks.
4. **Pipeline Workflow Pattern:**  
   Workflows are linear JSON blobs with self-contained steps. State flows forward only, with each step's output feeding the next. Perfect for porting WET code from Jupyter Notebooks.
5. **CRUD App Pattern:**  
   Apps are CRUD apps that follow the FastHTML/MiniDataAPI pattern with a single table that inherit from BaseApp. The CRUD is DRY and the Workflows are WET!
6. **Local LLM Integration:**  
   Integrated with Ollama for local, streaming LLM support. Bounded conversation history (128k tokens) with real-time response parsing and tool calling.
## What to Avoid
- **Enterprise/Multi-Tenant Architectures:**  
  No multi-tenancy, ORMs, or heavy abstractions that break the local-first simplicity.
  
- **Over-Engineering:**  
  Avoid unnecessary abstractions that undermine intentional minimalism.
  
- **Client-Side Frameworks:**  
  No React, Angular, or similar. UI remains server-generated with HTMX updates.
## Specific Patterns
1. **State Management:**  
   - *Do:* Use DictLikeDB + JSON for transparent, observable state
   - *Don't:* Add session management or distributed state
2. **UI Construction:**  
   - *Do:* Server-side HTML generation with HTMX updates
   - *Don't:* Add build steps or client-side frameworks
3. **Workflow Pipelines:**  
   - *Do:* Linear, forward-only state flow in JSON blobs
   - *Don't:* Add virtual state or backtracking
4. **LLM Integration:**  
   - *Do:* Local Ollama with bounded history and streaming
   - *Don't:* Add distributed chat or complex memory systems
5. **Development Environment:**  
   - *Do:* Use Nix Flakes for reproducible builds
   - *Don't:* Add environment-specific dependencies
## AI Assistant Integration
- Ollama provides local, streaming LLM support
- JSON command structures for AI operations
- Bounded conversation history (128k tokens)
- Real-time response parsing and tool calling
- Training data generated from workflow pipelines
## SSE & WebSocket Patterns
- Server-Sent Events for real-time updates
- WebSockets for bi-directional communication
- No build step development workflow
- HTMX handles all DOM updates
## Final Reminder
Every design choice prioritizes local control, observability, and radical simplicity. The power comes from combining local LLMs, server-side state, and modern UI patterns into a cohesive, reproducible development environment.
## Important Note on Workflow Identity
Pipulate workflows have two separate identities:
- The **filename** (`110_parameter_buster_workflow.py`) determines the URL/endpoint users access
- The **APP_NAME** (`"parameter_buster"`) identifies the workflow in the database
Keeping these different (as in the example above) allows you to improve user-facing URLs without breaking existing workflow data. Always maintain a consistent APP_NAME when you want to preserve existing workflow state data.
## Workflow Filename vs APP_NAME Pattern
- **Filename** determines user-facing URL/endpoint (`110_parameter_buster_workflow.py` → `/parameter_buster_workflow`)
- **APP_NAME** determines database storage keys (`APP_NAME = "parameter_buster"` for DB records)
- Keep them different to enable URL improvements without breaking stored data
- When changing a workflow's URL (filename), maintain its APP_NAME to preserve existing data
- Create new file versions while keeping same APP_NAME for data continuity during upgrades
## Critical Implementation Patterns
1. **HTMX Chain Reaction:**  
   - The pattern `Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load")` must be preserved exactly
   - Never remove the `hx_trigger="load"` attribute even if it seems redundant
   - This explicit approach is the reliable standard for the application and alternative implicit approaches are not supported
---
# File token count: 974 tokens
# <<< END FILE: /home/mike/repos/pipulate/.cursorrules >>>
# <<< START FILE: /home/mike/repos/pipulate/plugins/20_hello_workflow.py >>>
import asyncio
from collections import namedtuple
from datetime import datetime
from fasthtml.common import * # type: ignore
from loguru import logger
"""
Pipulate Workflow Template (Hello World Example)
This file serves as a starting point for creating linear, step-by-step Pipulate Workflows.
It includes essential boilerplate and demonstrates core concepts.
--- Basic Workflow Pattern ---
1. Define steps sequentially using the `Step` namedtuple.
2. Implement GET (`step_XX`) and POST (`step_XX_submit`) handlers for each step.
3. Data typically flows from the `done` field of one step to the next via the
   `transform` function and `get_suggestion` method.
4. Use helper methods from `self.pipulate` (aliased as `pip`) for common tasks
   like state management, UI generation, and validation.
5. Workflows can be reverted to previous steps or finalized to lock them.
--- Adapting This Template ---
1.  **Copy & Rename:** Copy this file. Rename the class (e.g., `MyWorkflow`),
    `APP_NAME` (must be unique), `DISPLAY_NAME`, and `ENDPOINT_MESSAGE`.
2.  **Training Prompt:** Create a `your_workflow_name.md` file in the `/training`
    directory (or provide plain text) and update `TRAINING_PROMPT`.
3.  **Define Steps:** Modify the `steps` list in `__init__` to define your workflow's
    sequence, fields, and data transformations.
4.  **Implement Handlers:** Create `step_XX` and `step_XX_submit` methods for each
    step ID you defined. Use the examples below as a guide. Add your custom
    validation, data processing (API calls, calculations, Playwright, etc.),
    and UI logic within these handlers.
--- Pipulate App Types ---
1. Workflows (like this one): Linear, step-based apps. Code is often explicit (WET).
2. Apps (inheriting from `BaseApp`): CRUD-style apps for managing data in a
   single table. More abstracted (DRY).
Get ready to get WET with Workflows!
"""
# Model for a workflow step (Do not change)
Step = namedtuple('Step', ['id', 'done', 'show', 'refill', 'transform'], defaults=(None,))

class HelloFlow:
    """
    Hello World Workflow Example
    Demonstrates a simple two-step workflow asking for a name and generating a greeting.
    --- Key Concepts for Building Workflows ---
    * **Steps Definition (`steps` list in `__init__`)**
        * `id`: Unique identifier ('step_XX' format recommended).
        * `done`: The key in the step's state data that marks it complete (usually the primary input field name).
        * `show`: User-friendly label for the step/field.
        * `refill`: If `True`, the input field will be pre-filled with the existing value when reverting to this step.
        * `transform`: A `lambda` function that takes the `done` value from the *previous* step and processes it. The result is used by `get_suggestion` to potentially pre-fill the *current* step's input.
    * **Inter-Step Data Flow**
        1.  **`transform` & `get_suggestion`:** Simple way to pass and modify data sequentially. The `transform` lambda on `step_02` processes `step_01`'s output. `get_suggestion` uses this for `step_02`'s input placeholder.
        2.  **Direct State Access:** In any handler (`step_XX` or `step_XX_submit`), you can read data from *any* previous step:
            ```python
            pip = self.pipulate
            pipeline_id = self.db.get("pipeline_id")
            # Get all data stored for step_01
            step_01_data = pip.get_step_data(pipeline_id, "step_01", {})
            # Get the specific 'done' value from step_01
            previous_name = step_01_data.get('name')
            ```
    * **State Management (`pipulate` helpers)**
        * `pip.read_state(pipeline_id)`: Reads the entire workflow state dictionary.
        * `pip.get_step_data(pipeline_id, step_id, default={})`: Reads the dictionary for a specific step.
        * `await pip.update_step_state(pipeline_id, step_id, value, steps)`: *Recommended way* to save the primary `done` value for a step. Also updates internal step tracking.
        * `pip.write_state(pipeline_id, state)`: Saves the entire state dictionary (use carefully).
        * `_revert_target`: A key automatically added to the state by `handle_revert` indicating which step the user reverted to. Check `state.get('_revert_target') == step_id` in `step_XX` handlers to decide whether to show the input form or the completed view.
        * `_preserve_completed`: You can manually set `state[step_id]['_preserve_completed'] = True` (e.g., in `unfinalize` or `handle_revert`) if you want a specific step (like one involving a download) to remain in its "completed" view even after unfinalizing or reverting *past* it.
    * **Core Methods vs. Custom Handlers:**
        * Core methods (`landing`, `init`, `finalize`, `unfinalize`, `handle_revert`, `jump_to_step`, `get_suggestion`, `run_all_cells`) provide the workflow engine. Avoid deleting or significantly modifying them.
        * Custom Handlers (`step_XX`, `step_XX_submit`) contain your specific workflow logic for each step. Modify these extensively.
    """
    # --- Workflow Configuration (CHANGE THESE) ---
    APP_NAME = "hello"              # Unique identifier for this workflow's routes and data
    DISPLAY_NAME = "Hello World"    # User-friendly name shown in the UI
    ENDPOINT_MESSAGE = (            # Message shown on the workflow's landing page
        "This simple workflow demonstrates a basic Hello World example. "
        "Enter an ID to start or resume your workflow."
    )
    TRAINING_PROMPT = "hello_workflow.md" # Filename (in /training) or text for AI context
    PRESERVE_REFILL = True          # Whether to keep input values when reverting
    # --- Initialization (Framework Setup - Generally Do Not Modify Core Logic) ---
    def __init__(self, app, pipulate, pipeline, db, app_name=APP_NAME):
        """
        Initialize the workflow, define steps, and register routes.
        """
        self.app = app
        self.app_name = app_name
        self.pipulate = pipulate
        self.pipeline = pipeline
        self.steps_indices = {}
        self.db = db
        pip = self.pipulate
        self.message_queue = pip.message_queue # For ordered UI messages
        # ---> USER CUSTOMIZATION START <---
        # Define the ordered sequence of workflow steps.
        steps = [
            Step(
                id='step_01',          # HTML ID and part of URL path
                done='name',           # State key indicating step completion (usually input name)
                show='Step 1 Your Name',      # Label shown in UI for this step/data
                refill=True,           # Refill input with this value on revert?
                # transform=None       # Step 1 usually doesn't transform previous data
            ),
            Step(
                id='step_02',
                done='greeting',
                show='Step 2 Hello Message',
                refill=False,          # Usually False if value is generated/transformed
                transform=lambda name_from_step_01: f"Hello {name_from_step_01}!" # Example: Generate greeting
            ),
            # Add more steps here following the pattern
        ]
        # ---> USER CUSTOMIZATION END <---
        # --- Route Registration (Framework Plumbing - Do Not Modify) ---
        # Standard workflow routes
        routes = [
            (f"/{app_name}", self.landing),                             # GET landing page
            (f"/{app_name}/init", self.init, ["POST"]),                 # POST init workflow
            (f"/{app_name}/jump_to_step", self.jump_to_step, ["POST"]), # POST jump to step
            (f"/{app_name}/revert", self.handle_revert, ["POST"]),      # POST revert step
            (f"/{app_name}/finalize", self.finalize, ["GET", "POST"]),  # GET/POST finalize
            (f"/{app_name}/unfinalize", self.unfinalize, ["POST"]),      # POST unfinalize
        ]
        # Routes for each custom step defined above
        self.steps = steps # Store steps instance variable
        for step in steps:
            step_id = step.id
            # Add GET route for displaying the step UI
            routes.append((f"/{app_name}/{step_id}", getattr(self, step_id)))
            # Add POST route for submitting the step data
            routes.append((f"/{app_name}/{step_id}_submit", getattr(self, f"{step_id}_submit"), ["POST"]))
        # Register all routes with the FastHTML app
        for path, handler, *methods in routes:
            method_list = methods[0] if methods else ["GET"]
            app.route(path, methods=method_list)(handler)
        # --- End Route Registration ---
        # ---> USER CUSTOMIZATION START <---
        # Define messages used in UI feedback (especially for finalize)
        self.step_messages = {
            "finalize": {
                "ready": "All steps complete. Ready to finalize workflow.",
                "complete": f"Workflow finalized. Use {pip.UNLOCK_BUTTON_LABEL} to make changes."
            }
        }
        # Creates default input/complete messages for each step (can be overridden)
        for step in steps:
            self.step_messages[step.id] = {
                "input": f"{pip.fmt(step.id)}: Please enter {step.show}.",
                "complete": f"{step.show} complete. Continue to next step."
            }
        # ---> USER CUSTOMIZATION END <---
        # Add the mandatory 'finalize' step internally (Do not change)
        steps.append(Step(id='finalize', done='finalized', show='Finalize', refill=False))
        self.steps_indices = {step.id: i for i, step in enumerate(steps)} # Map step IDs to indices

    # --- Core Workflow Engine Methods (Usually Do Not Modify) ---
    async def landing(self):
        """ Renders the initial landing page with the key input form. """
        pip, pipeline, steps, app_name = self.pipulate, self.pipeline, self.steps, self.app_name
        context = pip.get_plugin_context(self)
        title = f"{self.DISPLAY_NAME or app_name.title()}"
        full_key, prefix, user_part = pip.generate_pipeline_key(self)
        default_value = full_key
        pipeline.xtra(app_name=app_name)
        matching_records = [record.pkey for record in pipeline() if record.pkey.startswith(prefix)]
        datalist_options = [f"{prefix}{record_key.replace(prefix, '')}" for record_key in matching_records]
        return Container(
            Card(
                H2(title),
                P(self.ENDPOINT_MESSAGE, style="font-size: 0.9em; color: #666;"),
                Form(
                    pip.wrap_with_inline_button(
                        Input(
                            placeholder="Existing or new 🗝 here (Enter for auto)", name="pipeline_id",
                            list="pipeline-ids", type="search", required=False, autofocus=True,
                            value=default_value, _onfocus="this.setSelectionRange(this.value.length, this.value.length)",
                            cls="contrast"
                        ),
                        button_label=f"Enter 🔑", button_class="secondary"
                    ),
                    pip.update_datalist("pipeline-ids", options=datalist_options if datalist_options else None),
                    hx_post=f"/{app_name}/init", hx_target=f"#{app_name}-container"
                )
            ),
            Div(id=f"{app_name}-container") # Target for HTMX updates
        )
    async def init(self, request):
        """ Handles the key submission, initializes state, and renders the step UI placeholders. """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        form = await request.form()
        user_input = form.get("pipeline_id", "").strip()
        if not user_input: # Refresh if submitted blank (e.g., user wants auto-key)
            from starlette.responses import Response
            response = Response("")
            response.headers["HX-Refresh"] = "true"
            return response
        # Generate or parse the unique pipeline ID
        context = pip.get_plugin_context(self)
        plugin_name = context['plugin_name'] or app_name
        profile_name = context['profile_name'] or "default"
        profile_part = profile_name.replace(" ", "_")
        plugin_part = plugin_name.replace(" ", "_")
        expected_prefix = f"{profile_part}-{plugin_part}-"
        if user_input.startswith(expected_prefix):
            pipeline_id = user_input
        else:
            _, prefix, user_provided_id = pip.generate_pipeline_key(self, user_input)
            pipeline_id = f"{prefix}{user_provided_id}"
        db["pipeline_id"] = pipeline_id # Store in request-scoped DB
        logger.debug(f"Using pipeline ID: {pipeline_id}")
        # Initialize state if missing, check completion/finalization status
        state, error = pip.initialize_if_missing(pipeline_id, {"app_name": app_name})
        if error: return error
        all_steps_complete = all( step.id in state and step.done in state[step.id] for step in steps[:-1] )
        is_finalized = "finalize" in state and "finalized" in state["finalize"]
        # Add initial status messages to the UI queue
        await self.message_queue.add(pip, f"Workflow ID: {pipeline_id}", verbatim=True, spaces_before=0)
        await self.message_queue.add(pip, f"Return later by selecting '{pipeline_id}' from the dropdown.", verbatim=True, spaces_before=0)
        if all_steps_complete:
            status_msg = f"Workflow is complete and finalized. Use {pip.UNLOCK_BUTTON_LABEL} to make changes." if is_finalized \
                    else "Workflow is complete but not finalized. Press Finalize to lock your data."
            await self.message_queue.add(pip, status_msg, verbatim=True)
        elif not any(step.id in state for step in self.steps): # If brand new
             await self.message_queue.add(pip, "Please complete each step in sequence. Your progress will be saved automatically.", verbatim=True)
        # Update the datalist in the UI with the current key
        parsed = pip.parse_pipeline_key(pipeline_id)
        prefix = f"{parsed['profile_part']}-{parsed['plugin_part']}-"
        self.pipeline.xtra(app_name=app_name)
        matching_records = [record.pkey for record in self.pipeline() if record.pkey.startswith(prefix)]
        if pipeline_id not in matching_records: matching_records.append(pipeline_id)
        updated_datalist = pip.update_datalist("pipeline-ids", options=matching_records)
        # Rebuild the UI, triggering the first step load via HTMX
        return pip.rebuild(app_name, steps)
    async def finalize(self, request):
        """ Handles GET request to show Finalize button and POST request to lock the workflow. """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        pipeline_id = db.get("pipeline_id", "unknown")
        finalize_step = steps[-1] # The internally added Step(id='finalize',...)
        finalize_data = pip.get_step_data(pipeline_id, finalize_step.id, {})
        if request.method == "GET":
            # Show locked view or finalize button
            if finalize_step.done in finalize_data:
                return Card(H3("Workflow is locked."),
                    P("You can unlock the workflow to make changes.", style="font-size: 0.9em; color: #666;"),
                    Form( Button(pip.UNLOCK_BUTTON_LABEL, type="submit", cls="secondary outline"),
                        hx_post=f"/{app_name}/unfinalize", hx_target=f"#{app_name}-container", hx_swap="outerHTML"
                    ), id=finalize_step.id )
            else:
                # Check if all *custom* steps are complete before offering finalize
                all_steps_complete = all( pip.get_step_data(pipeline_id, step.id, {}).get(step.done) for step in steps[:-1] )
                if all_steps_complete:
                    return Card(H3("All steps complete. Finalize?"),
                        P("You can revert to any step and make changes.", style="font-size: 0.9em; color: #666;"),
                        Form( Button("Finalize", type="submit", cls="primary"),
                            hx_post=f"/{app_name}/finalize", hx_target=f"#{app_name}-container", hx_swap="outerHTML"
                        ), id=finalize_step.id )
                else:
                    # Render an empty Div with the step ID if not ready to finalize, prevents breaking HTMX chain
                    return Div(id=finalize_step.id)
        else: # POST request
            await pip.finalize_workflow(pipeline_id)
            await self.message_queue.add(pip, self.step_messages["finalize"]["complete"], verbatim=True)
            # Rebuild the entire UI to show locked state
            return pip.rebuild(app_name, steps)
    async def unfinalize(self, request):
        """ Handles POST request to unlock the workflow. """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        pipeline_id = db.get("pipeline_id", "unknown")
        await pip.unfinalize_workflow(pipeline_id)
        await self.message_queue.add(pip, "Workflow unfinalized! You can now revert to any step and make changes.", verbatim=True)
        # Rebuild the entire UI to show unlocked state
        return pip.rebuild(app_name, steps)
    async def jump_to_step(self, request):
        """ Handles POST request from breadcrumb navigation to jump to a specific step. """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        form = await request.form()
        step_id = form.get("step_id")
        db["step_id"] = step_id # Update current step context
        # Rebuild UI from the jumped-to step
        return pip.rebuild(app_name, steps)
    async def get_suggestion(self, step_id, state):
        """ Gets a suggested input value for a step, often using the previous step's transformed output. """
        pip, db, steps = self.pipulate, self.db, self.steps
        step = next((s for s in steps if s.id == step_id), None)
        # Only provide suggestion if step has a transform function
        if not step or not step.transform: return ""
        prev_index = self.steps_indices[step_id] - 1
        if prev_index < 0: return "" # No previous step for step_01
        prev_step = steps[prev_index]
        # Get the 'done' value from the previous step's saved data
        prev_data = pip.get_step_data(db["pipeline_id"], prev_step.id, {})
        prev_word = prev_data.get(prev_step.done, "")
        # Apply the current step's transform function to the previous step's value
        return step.transform(prev_word) if prev_word else ""
    async def handle_revert(self, request):
        """ Handles POST request to revert to a previous step, clearing subsequent step data. """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        form = await request.form()
        step_id = form.get("step_id")
        pipeline_id = db.get("pipeline_id", "unknown")
        if not step_id: return P("Error: No step specified", style=pip.get_style("error"))
        # Clear state from the target step onwards
        await pip.clear_steps_from(pipeline_id, step_id, steps)
        # Mark the target step for revert logic in GET handlers
        state = pip.read_state(pipeline_id)
        state["_revert_target"] = step_id
        pip.write_state(pipeline_id, state)
        # Add message and rebuild UI
        message = await pip.get_state_message(pipeline_id, steps, self.step_messages)
        await self.message_queue.add(pip, message, verbatim=True)
        return pip.rebuild(app_name, steps)
    # --- Custom Workflow Step Handlers (Modify And Add Yours Here) ---
    # --- Step 1: Your Name ---
    async def step_01(self, request):
        """ Handles GET request for Step 1: Displays input form or completed value. """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        step_id = "step_01"
        step_index = self.steps_indices[step_id]
        step = steps[step_index]
        next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize' # Next is finalize if last step
        pipeline_id = db.get("pipeline_id", "unknown")
        state = pip.read_state(pipeline_id)
        step_data = pip.get_step_data(pipeline_id, step_id, {})
        user_val = step_data.get(step.done, "") # Get the saved value for 'name' if it exists
        # Boilerplate: Check if workflow is finalized
        finalize_data = pip.get_step_data(pipeline_id, "finalize", {})
        if "finalized" in finalize_data:
            # Show locked view
            return Div(
                Card(
                    H3(f"🔒 {step.show}: {user_val}")
                ),
                # Trigger loading the next step's locked view
                Div(id=next_step_id, hx_get=f"/{self.app_name}/{next_step_id}", hx_trigger="load"),
                id=step_id
            )
        # Boilerplate: Check if step is complete and we are NOT reverting to it
        if user_val and state.get("_revert_target") != step_id:
            # Show completed view with Revert button
             return Div(
                pip.revert_control(step_id=step_id, app_name=app_name, message=f"{step.show}: {user_val}", steps=steps),
                # CRITICAL: Explicitly trigger next step loading - this pattern is required for reliable workflow progression
                Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load")
            )
        else:
            # Show the input form for this step
            # Determine value: Use existing if refill enabled, otherwise get suggestion (none for step_01)
            display_value = user_val if (step.refill and user_val and self.PRESERVE_REFILL) else await self.get_suggestion(step_id, state)
            # Add prompt message to UI
            await self.message_queue.add(pip, self.step_messages[step_id]["input"], verbatim=True)
            # Render the card with the form
            return Div(
                Card(
                    H3(f"{pip.fmt(step.id)}: Enter {step.show}"),
                    Form(
                        pip.wrap_with_inline_button(
                            Input( type="text", name=step.done, value=display_value,
                                   placeholder=f"Enter {step.show}", required=True, autofocus=True )
                        ),
                        hx_post=f"/{app_name}/{step.id}_submit", # Submit to step_01_submit
                        hx_target=f"#{step.id}"                 # Replace this Div on response
                    )
                ),
                Div(id=next_step_id), # Placeholder for the next step
                id=step.id            # This Div gets replaced by HTMX on submit/revert
            )
    async def step_01_submit(self, request):
        """Process the submission for placeholder Step 1.
        
        Chain Reaction Pattern:
        When a step completes, it MUST explicitly trigger the next step by including
        a div for the next step with hx_trigger="load". While this may seem redundant,
        it is more reliable than depending on HTMX event bubbling.
        
        This is a deliberate architectural decision in Pipulate workflows to ensure
        consistent behavior across browsers and complex DOM structures.
        """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        step_id = "step_01"
        step_index = self.steps_indices[step_id]
        step = steps[step_index]
        pipeline_id = db.get("pipeline_id", "unknown")
        # Boilerplate: Check finalized state (optional, submit shouldn't be possible)
        if step.done == 'finalized': return await pip.handle_finalized_step(pipeline_id, step_id, steps, app_name, self)
        # Get form data
        form = await request.form()
        user_val = form.get(step.done, "") # Get value for 'name' field
        # --- Custom Validation (Example) ---
        is_valid, error_msg, error_component = pip.validate_step_input(user_val, step.show)
        # Add more specific validation if needed:
        # if not is_valid:
        #     return error_component # Return error message UI
        # elif len(user_val) < 2:
        #     return P("Name must be at least 2 characters.", style=pip.get_style("error"))
        if not is_valid: return error_component
        # --- End Custom Validation ---
        # --- Custom Processing (Example) ---
        # processed_val = user_val.strip().title() # e.g., Clean up the name
        processed_val = user_val # Keep it simple for template
        # Add API calls, Playwright, etc. here if needed
        # --- End Custom Processing ---
        # Save the processed value to this step's state
        await pip.update_step_state(pipeline_id, step_id, processed_val, steps)
        # Send confirmation message to UI
        await self.message_queue.add(pip, f"{step.show}: {processed_val}", verbatim=True)
        # Check if this was the last step before finalize
        if pip.check_finalize_needed(step_index, steps):
            await self.message_queue.add(pip, self.step_messages["finalize"]["ready"], verbatim=True)
        # Return the standard navigation controls (Revert button + trigger for next step)
        return pip.create_step_navigation(step_id, step_index, steps, app_name, processed_val)

    # --- Step 2: Hello Message ---
    async def step_02(self, request):
        """ Handles GET request for Step 2: Displays input form or completed value. """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        step_id = "step_02"
        step_index = self.steps_indices[step_id]
        step = steps[step_index]
        next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize' # Next is finalize
        pipeline_id = db.get("pipeline_id", "unknown")
        state = pip.read_state(pipeline_id)
        step_data = pip.get_step_data(pipeline_id, step_id, {})
        user_val = step_data.get(step.done, "") # Get the saved value for 'greeting' if it exists
        # Boilerplate: Check if workflow is finalized
        finalize_data = pip.get_step_data(pipeline_id, "finalize", {})
        if "finalized" in finalize_data:
            # Show locked view
            return Div(
                Card(
                    H3(f"🔒 {step.show}: {user_val}")
                ),
                # Trigger loading the next step's (finalize) locked view
                Div(id=next_step_id, hx_get=f"/{self.app_name}/{next_step_id}", hx_trigger="load"),
                id=step_id
            )
        # Boilerplate: Check if step is complete and we are NOT reverting to it
        if user_val and state.get("_revert_target") != step_id:
            # Show completed view with Revert button
             return Div(
                pip.revert_control(step_id=step_id, app_name=app_name, message=f"{step.show}: {user_val}", steps=steps),
                # CRITICAL: Explicitly trigger next step loading - this pattern is required for reliable workflow progression
                Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load")
            )
        else:
            # Show the input form for this step
            # Determine value: Use existing if refill enabled, otherwise get suggestion (uses transform)
            display_value = user_val if (step.refill and user_val and self.PRESERVE_REFILL) else await self.get_suggestion(step_id, state)
            # Add prompt message to UI
            await self.message_queue.add(pip, self.step_messages[step_id]["input"], verbatim=True)
            # Render the card with the form
            return Div(
                Card(
                    H3(f"{pip.fmt(step.id)}: Enter {step.show}"),
                    Form(
                        pip.wrap_with_inline_button(
                            # Example: Using a readonly input because the value is generated by transform
                            Input( type="text", name=step.done, value=display_value,
                                   placeholder=f"{step.show} (generated)", required=True, autofocus=True)
                        ),
                        hx_post=f"/{app_name}/{step.id}_submit", # Submit to step_02_submit
                        hx_target=f"#{step.id}"                 # Replace this Div on response
                    )
                ),
                Div(id=next_step_id), # Placeholder for the next step (finalize)
                id=step.id            # This Div gets replaced by HTMX on submit/revert
            )
    async def step_02_submit(self, request):
        """ Handles POST submission for Step 2: Validates, saves state, returns navigation. """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        step_id = "step_02"
        step_index = self.steps_indices[step_id]
        step = steps[step_index]
        pipeline_id = db.get("pipeline_id", "unknown")
        # Boilerplate: Check finalized state
        if step.done == 'finalized': return await pip.handle_finalized_step(pipeline_id, step_id, steps, app_name, self)
        # Get form data
        form = await request.form()
        user_val = form.get(step.done, "") # Get value for 'greeting' field
        # Validate input using helper (basic check if required)
        is_valid, error_msg, error_component = pip.validate_step_input(user_val, step.show)
        if not is_valid: return error_component
        # --- Custom Processing ---
        # Value was likely generated by get_suggestion, so usually no processing needed here
        processed_val = user_val
        # --- End Custom Processing ---
        # Save the processed value to this step's state
        await pip.update_step_state(pipeline_id, step_id, processed_val, steps)
        # Send confirmation message to UI
        await self.message_queue.add(pip, f"{step.show}: {processed_val}", verbatim=True)
        # Check if this was the last step before finalize (it is in this template)
        if pip.check_finalize_needed(step_index, steps):
            await self.message_queue.add(pip, self.step_messages["finalize"]["ready"], verbatim=True)
        # Return the standard navigation controls
        return pip.create_step_navigation(step_id, step_index, steps, app_name, processed_val)
    # Add step_03, step_03_submit etc. here if you add more steps
# File token count: 6,757 tokens
# <<< END FILE: /home/mike/repos/pipulate/plugins/20_hello_workflow.py >>>
# <<< START FILE: /home/mike/repos/pipulate/plugins/60_widget_examples.py >>>
import asyncio
import json
from collections import namedtuple
from datetime import datetime
from pathlib import Path
import pandas as pd
from fasthtml.common import * # type: ignore
from starlette.responses import HTMLResponse
from loguru import logger
from rich.console import Console
from rich.table import Table
from fastcore.xml import NotStr
"""
Pipulate Widget Examples
This workflow demonstrates various widget types that can be integrated into Pipulate Workflows:
1. Simple HTMX Widget: Basic HTML content with no JavaScript execution
2. Pandas Table Widget: HTML table from DataFrame
3. JavaScript Execution Widget: DOM manipulation via JavaScript in HTMX-injected content
4. Mermaid Diagram Renderer: Client-side rendering using mermaid.js
5. Code Syntax Highlighter: Syntax highlighting with Prism.js
This serves as a reference implementation for creating visualization widgets in Pipulate.
--- Design Pattern Note ---
This workflow uses a "Combined Step" pattern where each step handles both:
1. Data collection (input form)
2. Widget rendering (visualization)
In each step, user input is collected and immediately transformed into the 
corresponding visualization in the same card upon submission. This approach:
- Reduces the total number of workflow steps (5 instead of 10)
- Creates a clear cause-effect relationship within each step
- Simplifies navigation for the end user
An alternative "Separated Step" pattern would:
- Split each feature into separate input and display steps
- Use one step for data collection, followed by a step for visualization
- Result in 10 steps total (plus finalize)
- Potentially simplify each individual step's implementation
- Allow for more focused step responsibilities
When adapting this example for your own workflows, consider which pattern 
best suits your needs:
- Combined: When immediate visualization feedback is valuable
- Separated: When data collection and visualization are distinct concerns
             or when complex transformations occur between input and display
"""
# Model for a workflow step (Do not change)
Step = namedtuple('Step', ['id', 'done', 'show', 'refill', 'transform'], defaults=(None,))

class WidgetExamples:
    """
    Widget Examples Workflow
    
    Demonstrates various widget types for Pipulate Workflows:
    1. Simple Text Widget - No JS execution
    2. Markdown Renderer (MarkedJS) - Client-side rendering using marked.js
    3. Mermaid Diagram Renderer - Client-side rendering using mermaid.js
    4. Pandas Table Widget - HTML table from DataFrame
    5. Code Syntax Highlighter - Syntax highlighting with Prism.js
    6. JavaScript Execution Widget - Running JS in HTMX-injected content
    
    Key Implementation Notes:
    - Widgets use pip.widget_container for consistent styling and DOM structure
    - JavaScript widgets use unique IDs for targeting in the DOM
    - Client-side libraries are loaded in server.py's hdrs tuple
    - HX-Trigger headers are used for reliable JS execution in HTMX-injected content
    
    --- Design Pattern: Combined vs. Separated Steps ---
    
    Current Implementation: "Combined Step" Pattern
    This workflow uses a pattern where each step handles both data collection
    and visualization in the same step. When the user submits an input form,
    the same card transforms to display the visualization widget.
    
    Key characteristics:
    - Each step_XX_submit handler creates and returns the widget immediately
    - Widgets are displayed in place of the input form after submission
    - The revert control shows the widget until user chooses to revert
    - This creates a compact 6-step workflow (plus finalize)
    
    Alternative Approach: "Separated Step" Pattern
    A different design would separate input collection and visualization:
    - One step for collecting input (e.g., step_01_data_input)
    - Next step for displaying the widget (e.g., step_02_display_widget)
    - This would result in 12 steps total (plus finalize)
    - Each step would have simpler, more focused responsibility
    
    Implementation Considerations:
    - When copying this example, you may want to separate complex input collection
      and visualization into discrete steps for clarity and maintainability
    - Use the transform parameter in the Step namedtuple to pass data between
      separated input and visualization steps
    - The current combined approach works well for simpler widgets where immediate
      feedback is valuable to the user
    """
    # --- Workflow Configuration ---
    APP_NAME = "widgets"
    DISPLAY_NAME = "Widget Examples"
    ENDPOINT_MESSAGE = (
        "This workflow demonstrates various widget types for Pipulate. "
        "Enter an ID to start or resume your workflow."
    )
    TRAINING_PROMPT = "widget_examples.md"
    PRESERVE_REFILL = True
    # --- Initialization ---
    def __init__(self, app, pipulate, pipeline, db, app_name=APP_NAME):
        """
        Initialize the workflow, define steps, and register routes.
        """
        self.app = app
        self.app_name = app_name
        self.pipulate = pipulate
        self.pipeline = pipeline
        self.steps_indices = {}
        self.db = db
        pip = self.pipulate
        self.message_queue = pip.message_queue
        
        # Define workflow steps
        steps = [
            Step(
                id='step_01',
                done='simple_content',
                show='Simple Text Widget',
                refill=True,
            ),
            Step(
                id='step_02',
                done='markdown_content',
                show='Markdown Renderer (MarkedJS)',
                refill=True,
            ),
            Step(
                id='step_03',
                done='mermaid_content',
                show='Mermaid Diagram Renderer',
                refill=True,
            ),
            Step(
                id='step_04',
                done='table_data',
                show='Pandas Table Widget',
                refill=True,
            ),
            Step(
                id='step_05',
                done='code_content',
                show='Code Syntax Highlighter',
                refill=True,
            ),
            Step(
                id='step_06',
                done='js_content',
                show='JavaScript Widget',
                refill=True,
            ),
            Step(
                id='step_07',
                done='counter_data',
                show='Matplotlib Histogram',
                refill=True,
            ),
            Step(
                id='step_08',
                done='new_placeholder',
                show='New Placeholder Step',
                refill=True,
            ),
        ]
        
        # Standard workflow routes
        routes = [
            (f"/{app_name}", self.landing),
            (f"/{app_name}/init", self.init, ["POST"]),
            (f"/{app_name}/jump_to_step", self.jump_to_step, ["POST"]),
            (f"/{app_name}/revert", self.handle_revert, ["POST"]),
            (f"/{app_name}/finalize", self.finalize, ["GET", "POST"]),
            (f"/{app_name}/unfinalize", self.unfinalize, ["POST"]),
        ]
        # Routes for each custom step
        self.steps = steps
        for step in steps:
            step_id = step.id
            routes.append((f"/{app_name}/{step_id}", getattr(self, step_id)))
            routes.append((f"/{app_name}/{step_id}_submit", getattr(self, f"{step_id}_submit"), ["POST"]))
        # Register routes with the FastHTML app
        for path, handler, *methods in routes:
            method_list = methods[0] if methods else ["GET"]
            app.route(path, methods=method_list)(handler)
        # Define UI messages
        self.step_messages = {
            "finalize": {
                "ready": "All steps complete. Ready to finalize workflow.",
                "complete": f"Workflow finalized. Use {pip.UNLOCK_BUTTON_LABEL} to make changes."
            },
            "new": "Please complete each step to explore different widget types.",
            "step_08": {
                "input": f"{pip.fmt('step_08')}: Please complete New Placeholder Step.",
                "complete": f"New Placeholder Step complete. Continue to next step."
            },
            "step_07": {
                "input": f"{pip.fmt('step_07')}: Enter counter data for Matplotlib Histogram.",
                "complete": f"Matplotlib Histogram complete. Continue to next step."
            }
        }
        # Default messages for each step
        for step in steps:
            self.step_messages[step.id] = {
                "input": f"{pip.fmt(step.id)}: Enter content for {step.show}.",
                "complete": f"{step.show} complete. Continue to next step."
            }
        # Add finalize step
        steps.append(Step(id='finalize', done='finalized', show='Finalize', refill=False))
        self.steps_indices = {step.id: i for i, step in enumerate(steps)}
    # --- Core Workflow Engine Methods ---
    async def landing(self):
        """ Renders the initial landing page with the key input form. """
        pip, pipeline, steps, app_name = self.pipulate, self.pipeline, self.steps, self.app_name
        context = pip.get_plugin_context(self)
        title = f"{self.DISPLAY_NAME or app_name.title()}"
        full_key, prefix, user_part = pip.generate_pipeline_key(self)
        default_value = full_key
        pipeline.xtra(app_name=app_name)
        matching_records = [record.pkey for record in pipeline() if record.pkey.startswith(prefix)]
        datalist_options = [f"{prefix}{record_key.replace(prefix, '')}" for record_key in matching_records]
        return Container(
            Card(
                H2(title),
                P(self.ENDPOINT_MESSAGE, style="font-size: 0.9em; color: #666;"),
                Form(
                    pip.wrap_with_inline_button(
                        Input(
                            placeholder="Existing or new 🗝 here (Enter for auto)", name="pipeline_id",
                            list="pipeline-ids", type="search", required=False, autofocus=True,
                            value=default_value, _onfocus="this.setSelectionRange(this.value.length, this.value.length)",
                            cls="contrast"
                        ),
                        button_label=f"Enter 🔑", button_class="secondary"
                    ),
                    pip.update_datalist("pipeline-ids", options=datalist_options if datalist_options else None),
                    hx_post=f"/{app_name}/init", hx_target=f"#{app_name}-container"
                )
            ),
            Div(id=f"{app_name}-container")
        )
    async def init(self, request):
        """ Initialize the workflow state and redirect to the first step. """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        form = await request.form()
        user_input = form.get("pipeline_id", "").strip()
        if not user_input:
            from starlette.responses import Response
            response = Response("")
            response.headers["HX-Refresh"] = "true"
            return response
        # Generate or parse the unique pipeline ID
        context = pip.get_plugin_context(self)
        plugin_name = context['plugin_name'] or app_name
        profile_name = context['profile_name'] or "default"
        profile_part = profile_name.replace(" ", "_")
        plugin_part = plugin_name.replace(" ", "_")
        expected_prefix = f"{profile_part}-{plugin_part}-"
        if user_input.startswith(expected_prefix):
            pipeline_id = user_input
        else:
            _, prefix, user_provided_id = pip.generate_pipeline_key(self, user_input)
            pipeline_id = f"{prefix}{user_provided_id}"
        db["pipeline_id"] = pipeline_id
        logger.debug(f"Using pipeline ID: {pipeline_id}")
        # Initialize state if missing
        state, error = pip.initialize_if_missing(pipeline_id, {"app_name": app_name})
        if error: return error
        all_steps_complete = all(step.id in state and step.done in state[step.id] for step in steps[:-1])
        is_finalized = "finalize" in state and "finalized" in state["finalize"]
        # Add initial status messages
        await self.message_queue.add(pip, f"Workflow ID: {pipeline_id}", verbatim=True, spaces_before=0)
        await self.message_queue.add(pip, f"Return later by selecting '{pipeline_id}' from the dropdown.", verbatim=True, spaces_before=0)
        if all_steps_complete:
            status_msg = f"Workflow is complete and finalized. Use {pip.UNLOCK_BUTTON_LABEL} to make changes." if is_finalized \
                else "Workflow is complete but not finalized. Press Finalize to lock your data."
            await self.message_queue.add(pip, status_msg, verbatim=True)
        elif not any(step.id in state for step in self.steps):
            await self.message_queue.add(pip, self.step_messages["new"], verbatim=True)
        # Update the datalist
        parsed = pip.parse_pipeline_key(pipeline_id)
        prefix = f"{parsed['profile_part']}-{parsed['plugin_part']}-"
        self.pipeline.xtra(app_name=app_name)
        matching_records = [record.pkey for record in self.pipeline() if record.pkey.startswith(prefix)]
        if pipeline_id not in matching_records: matching_records.append(pipeline_id)
        updated_datalist = pip.update_datalist("pipeline-ids", options=matching_records)
        # Rebuild the UI, triggering the first step load
        return pip.rebuild(app_name, steps)
    async def finalize(self, request):
        """ Handle GET/POST requests to finalize (lock) the workflow. """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        pipeline_id = db.get("pipeline_id", "unknown")
        finalize_step = steps[-1]
        finalize_data = pip.get_step_data(pipeline_id, finalize_step.id, {})
        if request.method == "GET":
            # Show locked view or finalize button
            if finalize_step.done in finalize_data:
                return Card(
                    H3("Workflow is locked."),
                    Form(
                        Button(pip.UNLOCK_BUTTON_LABEL, type="submit", cls="secondary outline"),
                        hx_post=f"/{app_name}/unfinalize", hx_target=f"#{app_name}-container", hx_swap="outerHTML"
                    ),
                    id=finalize_step.id
                )
            else:
                # Check if all steps are complete before offering finalize
                all_steps_complete = all(pip.get_step_data(pipeline_id, step.id, {}).get(step.done) for step in steps[:-1])
                if all_steps_complete:
                    return Card(
                        H3("All steps complete. Finalize?"),
                        P("You can revert to any step and make changes.", style="font-size: 0.9em; color: #666;"),
                        Form(
                            Button("Finalize", type="submit", cls="primary"),
                            hx_post=f"/{app_name}/finalize", hx_target=f"#{app_name}-container", hx_swap="outerHTML"
                        ),
                        id=finalize_step.id
                    )
                else:
                    return Div(id=finalize_step.id)
        else:  # POST request
            await pip.finalize_workflow(pipeline_id)
            await self.message_queue.add(pip, self.step_messages["finalize"]["complete"], verbatim=True)
            return pip.rebuild(app_name, steps)
    async def unfinalize(self, request):
        """ Handle POST request to unlock the workflow. """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        pipeline_id = db.get("pipeline_id", "unknown")
        await pip.unfinalize_workflow(pipeline_id)
        await self.message_queue.add(pip, "Workflow unfinalized! You can now revert to any step and make changes.", verbatim=True)
        return pip.rebuild(app_name, steps)
    async def jump_to_step(self, request):
        """ Handle POST request from breadcrumb navigation to jump to a step. """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        form = await request.form()
        step_id = form.get("step_id")
        db["step_id"] = step_id
        return pip.rebuild(app_name, steps)
    async def get_suggestion(self, step_id, state):
        """ Gets a suggested input value for a step, often using the previous step's transformed output. """
        pip, db, steps = self.pipulate, self.db, self.steps
        
        # Pre-populated examples for each widget type
        examples = {
            'step_01': """Simple text content example:
- Basic text formatting
- Preserves line breaks and formatting
- Great for lists, paragraphs, descriptions, etc.
- Easy to modify
This is a sample widget that shows basic text content.""",
            
            'step_02': """# Markdown Example
This is a **bold statement** about _markdown_.
## Features demonstrated:
1. Headings (h1, h2)
2. Formatted text (**bold**, _italic_)
3. Ordered lists
4. Unordered lists
   - Nested item 1
   - Nested item 2
5. Code blocks
### Code Example
```python
def hello_world():
    print("Hello from Markdown!")
    for i in range(3):
        print(f"Count: {i}")
```
> Blockquotes are also supported
> - With nested lists
> - And formatting
[Learn more about Markdown](https://www.markdownguide.org/)
""",
            
            'step_03': """graph TD
    A[Start] --> B{Decision}
    B -->|Yes| C[Action 1]
    B -->|No| D[Action 2]
    C --> E[Result 1]
    D --> F[Result 2]
    E --> G[End]
    F --> G""",
            
            'step_04': """[
    {"Name": "John", "Age": 32, "Role": "Developer", "Department": "Engineering"},
    {"Name": "Jane", "Age": 28, "Role": "Designer", "Department": "Product"},
    {"Name": "Bob", "Age": 45, "Role": "Manager", "Department": "Engineering"},
    {"Name": "Alice", "Age": 33, "Role": "PM", "Department": "Product"},
    {"Name": "Charlie", "Age": 40, "Role": "Architect", "Department": "Engineering"}
]""",
            
            'step_05': """function calculateFactorial(n) {
    // Base case: factorial of 0 or 1 is 1
    if (n <= 1) {
        return 1;
    }
    
    // Recursive case: n! = n * (n-1)!
    return n * calculateFactorial(n - 1);
}
// Example usage
for (let i = 0; i < 10; i++) {
    console.log(`Factorial of ${i} is ${calculateFactorial(i)}`);
}
""",
            'step_06': """// Simple counter example
let count = 0;
const countDisplay = document.createElement('div');
countDisplay.style.fontSize = '24px';
countDisplay.style.margin = '20px 0';
countDisplay.textContent = count;
const button = document.createElement('button');
button.textContent = 'Increment Count';
button.style.backgroundColor = '#9370DB';
button.style.borderColor = '#9370DB';
button.onclick = function() {
    count++;
    countDisplay.textContent = count;
};
widget.appendChild(countDisplay);
widget.appendChild(button);""",
            'step_07': """{
    "apples": 35,
    "oranges": 42, 
    "bananas": 28,
    "grapes": 51,
    "peaches": 22,
    "plums": 18,
    "mangoes": 39
}""",
            'step_08': """New placeholder step - no user content needed.
This step serves as a placeholder for future widget types."""
        }
        
        # Return pre-populated example or empty string
        return examples.get(step_id, "")
    async def handle_revert(self, request):
        """ Handle POST request to revert to a previous step. """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        form = await request.form()
        step_id = form.get("step_id")
        pipeline_id = db.get("pipeline_id", "unknown")
        if not step_id: return P("Error: No step specified", style=pip.get_style("error"))
        # Clear state from the target step onwards
        await pip.clear_steps_from(pipeline_id, step_id, steps)
        # Mark the target step for revert logic in GET handlers
        state = pip.read_state(pipeline_id)
        state["_revert_target"] = step_id
        pip.write_state(pipeline_id, state)
        # Add message and rebuild UI
        message = await pip.get_state_message(pipeline_id, steps, self.step_messages)
        await self.message_queue.add(pip, message, verbatim=True)
        return pip.rebuild(app_name, steps)
    # --- Step 1: Simple Text Widget ---
    async def step_01(self, request):
        """ 
        Handles GET request for Step 1: Simple Text Widget.
        
        This method demonstrates the "Combined Step" pattern:
        1. If the step is incomplete or being reverted to, shows an input form
        2. If the step is complete, shows the widget with a revert control
        3. If workflow is finalized, shows a locked version of the widget
        
        In a "Separated Step" pattern, this would only handle input collection,
        and a separate step would display the widget.
        """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        step_id = "step_01"
        step_index = self.steps_indices[step_id]
        step = steps[step_index]
        next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'
        pipeline_id = db.get("pipeline_id", "unknown")
        state = pip.read_state(pipeline_id)
        step_data = pip.get_step_data(pipeline_id, step_id, {})
        user_val = step_data.get(step.done, "")
        
        # Check if workflow is finalized
        finalize_data = pip.get_step_data(pipeline_id, "finalize", {})
        if "finalized" in finalize_data and user_val:
            # Still show the widget but with a locked indicator
            simple_widget = Pre(
                user_val,
                style="padding: 1rem; background-color: var(--pico-code-background); border-radius: var(--pico-border-radius); overflow-x: auto; font-family: monospace;"
            )
            return Div(
                Card(
                    H3(f"🔒 {step.show}"),
                    simple_widget
                ),
                Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load")
            )
            
        # Check if step is complete and not reverting
        if user_val and state.get("_revert_target") != step_id:
            # Create the simple widget from the existing data
            simple_widget = Pre(
                user_val,
                style="padding: 1rem; background-color: var(--pico-code-background); border-radius: var(--pico-border-radius); overflow-x: auto; font-family: monospace;"
            )
            content_container = pip.widget_container(
                step_id=step_id,
                app_name=app_name,
                message=f"{step.show} Configured",
                widget=simple_widget,
                steps=steps
            )
            return Div(
                content_container,
                Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load")
            )
        else:
            # Show input form
            display_value = user_val if step.refill and user_val else await self.get_suggestion(step_id, state)
            await self.message_queue.add(pip, self.step_messages[step_id]["input"], verbatim=True)
            
            return Div(
                Card(
                    H3(f"{pip.fmt(step_id)}: Configure {step.show}"),
                    P("Enter text content for the simple widget. Example is pre-populated."),
                    Form(
                        Div(
                            Textarea(
                                display_value,
                                name=step.done,
                                placeholder="Enter text content for the widget",
                                required=True,
                                rows=10,
                                style="width: 100%; font-family: monospace;"
                            ),
                            Div(
                                Button("Submit", type="submit", cls="primary"),
                                style="margin-top: 1vh; text-align: right;"
                            ),
                            style="width: 100%;"
                        ),
                        hx_post=f"/{app_name}/{step_id}_submit",
                        hx_target=f"#{step_id}"
                    )
                ),
                Div(id=next_step_id),
                id=step_id
            )
    async def step_01_submit(self, request):
        """ 
        Process the submission for Step 1.
        
        In the "Combined Step" pattern, this method:
        1. Validates the user input
        2. Saves the input to the workflow state
        3. Creates and returns the widget to display
        4. Sets up navigation to the next step
        
        This immediate transformation from input to widget in the same step
        creates a tight cause-effect relationship visible to the user.
        """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        step_id = "step_01"
        step_index = self.steps_indices[step_id]
        step = steps[step_index]
        pipeline_id = db.get("pipeline_id", "unknown")
        next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'
        # Get form data
        form = await request.form()
        user_val = form.get(step.done, "")
        # Validate input
        is_valid, error_msg, error_component = pip.validate_step_input(user_val, step.show)
        if not is_valid:
            return error_component
        # Save the value to state
        await pip.update_step_state(pipeline_id, step_id, user_val, steps)
        # Create a simple widget with the user's content in a Pre tag to preserve formatting
        simple_widget = Pre(
            user_val,
            style="padding: 1rem; background-color: var(--pico-code-background); border-radius: var(--pico-border-radius); overflow-x: auto; font-family: monospace;"
        )
        
        # Create content container with the widget
        content_container = pip.widget_container(
            step_id=step_id,
            app_name=app_name,
            message=f"{step.show}: Simple text content provided",
            widget=simple_widget,
            steps=steps
        )
        
        # Create full response structure
        response_content = Div(
            content_container,
            Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
            id=step_id
        )
        
        # Send confirmation message
        await self.message_queue.add(pip, f"{step.show} complete.", verbatim=True)
        # Return the HTMLResponse with the widget container
        return HTMLResponse(to_xml(response_content))
    # --- Step 2: Markdown Renderer using marked.js ---
    async def step_02(self, request):
        """
        Step 2 - Markdown Renderer using marked.js
        
        Allows the user to input markdown content that will be rendered
        using the marked.js library for a Jupyter notebook-like experience.
        """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        step_id = "step_02"
        step_index = self.steps_indices[step_id]
        step = steps[step_index]
        next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'
        pipeline_id = db.get("pipeline_id", "unknown")
        state = pip.read_state(pipeline_id)
        step_data = pip.get_step_data(pipeline_id, step_id, {})
        user_val = step_data.get(step.done, "")
        
        # Check if workflow is finalized
        finalize_data = pip.get_step_data(pipeline_id, "finalize", {})
        if "finalized" in finalize_data and user_val:
            # Show the markdown renderer in locked state
            try:
                widget_id = f"marked-widget-{pipeline_id.replace('-', '_')}-{step_id}"
                marked_widget = self.create_marked_widget(user_val, widget_id)
                
                # Create response with locked view
                response = HTMLResponse(
                    to_xml(
                        Div(
                            Card(
                                H3(f"🔒 {step.show}"),
                                marked_widget
                            ),
                            Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load")
                        )
                    )
                )
                
                # Add HX-Trigger to initialize Marked.js
                response.headers["HX-Trigger"] = json.dumps({
                    "initMarked": {
                        "widgetId": widget_id
                    }
                })
                
                return response
            except Exception as e:
                logger.error(f"Error creating Marked widget in locked view: {str(e)}")
                return Div(
                    Card(f"🔒 {step.show}: <content locked>"),
                    Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load")
                )
            
        # Check if step is complete and not reverting
        if user_val and state.get("_revert_target") != step_id:
            # Create the marked widget from the existing content
            try:
                widget_id = f"marked-widget-{pipeline_id.replace('-', '_')}-{step_id}"
                marked_widget = self.create_marked_widget(user_val, widget_id)
                content_container = pip.widget_container(
                    step_id=step_id,
                    app_name=app_name,
                    message=f"{step.show} Configured",
                    widget=marked_widget,
                    steps=steps
                )
                
                # Create response with HTMX trigger
                response = HTMLResponse(
                    to_xml(
                        Div(
                            content_container,
                            Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load")
                        )
                    )
                )
                
                # Add HX-Trigger to initialize Marked.js
                response.headers["HX-Trigger"] = json.dumps({
                    "initMarked": {
                        "widgetId": widget_id
                    }
                })
                
                return response
            except Exception as e:
                # If there's an error creating the widget, revert to input form
                logger.error(f"Error creating Marked widget: {str(e)}")
                state["_revert_target"] = step_id
                pip.write_state(pipeline_id, state)
        
        # Show input form
        display_value = user_val if step.refill and user_val else await self.get_suggestion(step_id, state)
        await self.message_queue.add(pip, self.step_messages[step_id]["input"], verbatim=True)
        
        return Div(
            Card(
                H3(f"{pip.fmt(step_id)}: Configure {step.show}"),
                P("Enter markdown content to be rendered. Example is pre-populated."),
                P("The markdown will be rendered with support for headings, lists, bold/italic text, and code blocks.", 
                  style="font-size: 0.8em; font-style: italic;"),
                Form(
                    Div(
                        Textarea(
                            display_value,
                            name=step.done,
                            placeholder="Enter markdown content",
                            required=True,
                            rows=15,
                            style="width: 100%; font-family: monospace;"
                        ),
                        Div(
                            Button("Submit", type="submit", cls="primary"),
                            style="margin-top: 1vh; text-align: right;"
                        ),
                        style="width: 100%;"
                    ),
                    hx_post=f"/{app_name}/{step_id}_submit",
                    hx_target=f"#{step_id}"
                )
            ),
            Div(id=next_step_id),
            id=step_id
        )
    async def step_02_submit(self, request):
        """
        Handle submission of markdown content in Step 2
        
        Takes the user's markdown input, creates a marked.js widget,
        and returns it as part of the response with MarkedJS initialization.
        """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        step_id = "step_02"
        step_index = self.steps_indices[step_id]
        step = steps[step_index]
        pipeline_id = db.get("pipeline_id", "unknown")
        next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'
        # Get form data
        form = await request.form()
        user_val = form.get(step.done, "")
        # Validate input
        is_valid, error_msg, error_component = pip.validate_step_input(user_val, step.show)
        if not is_valid:
            return error_component
        # Save the value to state
        await pip.update_step_state(pipeline_id, step_id, user_val, steps)
        
        # Generate unique widget ID for this step and pipeline
        widget_id = f"marked-widget-{pipeline_id.replace('-', '_')}-{step_id}"
        
        # Use the helper method to create a marked widget
        marked_widget = self.create_marked_widget(user_val, widget_id)
        
        # Create content container with the marked widget and initialization
        content_container = pip.widget_container(
            step_id=step_id,
            app_name=app_name,
            message=f"{step.show}: Markdown rendered with Marked.js",
            widget=marked_widget,
            steps=steps
        )
        
        # Create full response structure
        response_content = Div(
            content_container,
            Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
            id=step_id
        )
        
        # Create an HTMLResponse with the content
        response = HTMLResponse(to_xml(response_content))
        
        # Add HX-Trigger header to initialize Marked.js
        response.headers["HX-Trigger"] = json.dumps({
            "initMarked": {
                "widgetId": widget_id
            }
        })
        
        # Send confirmation message
        await self.message_queue.add(pip, f"{step.show} complete. Markdown rendered successfully.", verbatim=True)
        
        return response
    # --- Step 3: Mermaid Diagram Renderer ---
    async def step_03(self, request):
        """ Handles GET request for Step 3: Mermaid Diagram Renderer. """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        step_id = "step_03"
        step_index = self.steps_indices[step_id]
        step = steps[step_index]
        next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'
        pipeline_id = db.get("pipeline_id", "unknown")
        state = pip.read_state(pipeline_id)
        step_data = pip.get_step_data(pipeline_id, step_id, {})
        user_val = step_data.get(step.done, "")
        
        # Check if workflow is finalized
        finalize_data = pip.get_step_data(pipeline_id, "finalize", {})
        if "finalized" in finalize_data and user_val:
            # Show the diagram in locked state
            try:
                widget_id = f"mermaid-widget-{pipeline_id.replace('-', '_')}-{step_id}"
                mermaid_widget = self.create_mermaid_widget(user_val, widget_id)
                
                # Create response with locked view
                response = HTMLResponse(
                    to_xml(
                        Div(
                            Card(
                                H3(f"🔒 {step.show}"),
                                mermaid_widget
                            ),
                            Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load")
                        )
                    )
                )
                
                # Add HX-Trigger to render the Mermaid diagram
                response.headers["HX-Trigger"] = json.dumps({
                    "renderMermaid": {
                        "targetId": f"{widget_id}_output",
                        "diagram": user_val
                    }
                })
                
                return response
            except Exception as e:
                logger.error(f"Error creating mermaid widget in locked view: {str(e)}")
                return Div(
                    Card(f"🔒 {step.show}: <content locked>"),
                    Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load")
                )
            
        # Check if step is complete and not reverting
        if user_val and state.get("_revert_target") != step_id:
            # Create the mermaid diagram widget from the existing content
            try:
                widget_id = f"mermaid-widget-{pipeline_id.replace('-', '_')}-{step_id}"
                mermaid_widget = self.create_mermaid_widget(user_val, widget_id)
                content_container = pip.widget_container(
                    step_id=step_id,
                    app_name=app_name,
                    message=f"{step.show} Configured",
                    widget=mermaid_widget,
                    steps=steps
                )
                
                # Create response with HTMX trigger
                response = HTMLResponse(
                    to_xml(
                        Div(
                            content_container,
                            Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load")
                        )
                    )
                )
                
                # Add HX-Trigger to render the Mermaid diagram
                response.headers["HX-Trigger"] = json.dumps({
                    "renderMermaid": {
                        "targetId": f"{widget_id}_output",
                        "diagram": user_val
                    }
                })
                
                return response
            except Exception as e:
                # If there's an error creating the widget, revert to input form
                logger.error(f"Error creating mermaid widget: {str(e)}")
                state["_revert_target"] = step_id
                pip.write_state(pipeline_id, state)
        
        # Show input form
        display_value = user_val if step.refill and user_val else await self.get_suggestion(step_id, state)
        await self.message_queue.add(pip, self.step_messages[step_id]["input"], verbatim=True)
        
        return Div(
            Card(
                H3(f"{pip.fmt(step_id)}: Configure {step.show}"),
                P("Enter Mermaid diagram syntax for the widget. Example is pre-populated."),
                P("Supports flowcharts, sequence diagrams, class diagrams, etc.", 
                  style="font-size: 0.8em; font-style: italic;"),
                Form(
                    Div(
                        Textarea(
                            display_value,
                            name=step.done,
                            placeholder="Enter Mermaid diagram syntax",
                            required=True,
                            rows=15,
                            style="width: 100%; font-family: monospace;"
                        ),
                        Div(
                            Button("Submit", type="submit", cls="primary"),
                            style="margin-top: 1vh; text-align: right;"
                        ),
                        style="width: 100%;"
                    ),
                    hx_post=f"/{app_name}/{step_id}_submit",
                    hx_target=f"#{step_id}"
                )
            ),
            Div(id=next_step_id),
            id=step_id
        )
    async def step_03_submit(self, request):
        """ 
        Process the submission for Step 3.
        
        This method demonstrates client-side widget rendering:
        1. Saves the Mermaid diagram syntax to state
        2. Creates a container with the diagram source
        3. Adds initialization JavaScript that runs when the content is inserted
        4. Uses HX-Trigger header as a backup initialization method
        
        Client-side initialization is particularly challenging in HTMX applications
        due to the timing of DOM updates. The implementation includes:
        - Timeout delay to ensure DOM is fully updated
        - Force repaint to prevent rendering glitches
        - Support for different Mermaid API versions
        - Comprehensive error handling
        """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        step_id = "step_03"
        step_index = self.steps_indices[step_id]
        step = steps[step_index]
        pipeline_id = db.get("pipeline_id", "unknown")
        next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'
        # Get form data
        form = await request.form()
        user_val = form.get(step.done, "")
        # Validate input
        is_valid, error_msg, error_component = pip.validate_step_input(user_val, step.show)
        if not is_valid:
            return error_component
        # Save the value to state
        await pip.update_step_state(pipeline_id, step_id, user_val, steps)
        
        # Generate unique widget ID for this step and pipeline
        widget_id = f"mermaid-widget-{pipeline_id.replace('-', '_')}-{step_id}"
        
        # Use the helper method to create a mermaid widget
        mermaid_widget = self.create_mermaid_widget(user_val, widget_id)
        
        # Create content container with the mermaid widget and initialization
        content_container = pip.widget_container(
            step_id=step_id,
            app_name=app_name,
            message=f"{step.show}: Client-side Mermaid diagram rendering",
            widget=mermaid_widget,
            steps=steps
        )
        
        # Create full response structure
        response_content = Div(
            content_container,
            Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
            id=step_id
        )
        
        # Create an HTMLResponse with the content
        response = HTMLResponse(to_xml(response_content))
        
        # Add HX-Trigger header to initialize Mermaid rendering
        # This is a backup mechanism in case the inline script doesn't work
        response.headers["HX-Trigger"] = json.dumps({
            "renderMermaid": {
                "targetId": f"{widget_id}_output",
                "diagram": user_val
            }
        })
        
        # Send confirmation message
        await self.message_queue.add(pip, f"{step.show} complete. Mermaid diagram rendered.", verbatim=True)
        
        return response
    # --- Step 4: Pandas Table Widget ---
    async def step_04(self, request):
        """ 
        Handles GET request for Step 4: Pandas Table Widget.
        
        This method follows the same "Combined Step" pattern as step_01.
        Note that when displaying an existing widget, we recreate it from
        the saved data rather than storing the rendered widget itself.
        """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        step_id = "step_04"
        step_index = self.steps_indices[step_id]
        step = steps[step_index]
        next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'
        pipeline_id = db.get("pipeline_id", "unknown")
        state = pip.read_state(pipeline_id)
        step_data = pip.get_step_data(pipeline_id, step_id, {})
        user_val = step_data.get(step.done, "")
        
        # Check if workflow is finalized
        finalize_data = pip.get_step_data(pipeline_id, "finalize", {})
        if "finalized" in finalize_data and user_val:
            try:
                # Still show the widget but with a locked indicator
                table_widget = self.create_pandas_table(user_val)
                return Div(
                    Card(
                        H3(f"🔒 {step.show}"),
                        table_widget
                    ),
                    Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load")
                )
            except Exception as e:
                logger.error(f"Error creating table widget in finalized view: {str(e)}")
                return Div(
                    Card(f"🔒 {step.show}: <content locked>"),
                    Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load")
                )
            
        # Check if step is complete and not reverting
        if user_val and state.get("_revert_target") != step_id:
            # Create the table widget from the existing data
            try:
                table_widget = self.create_pandas_table(user_val)
                content_container = pip.widget_container(
                    step_id=step_id,
                    app_name=app_name,
                    message=f"{step.show} Configured",
                    widget=table_widget,
                    steps=steps
                )
                return Div(
                    content_container,
                    Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load")
                )
            except Exception as e:
                # If there's an error creating the widget, revert to input form
                logger.error(f"Error creating table widget: {str(e)}")
                state["_revert_target"] = step_id
                pip.write_state(pipeline_id, state)
        
        # Show input form
        display_value = user_val if step.refill and user_val else await self.get_suggestion(step_id, state)
        await self.message_queue.add(pip, self.step_messages[step_id]["input"], verbatim=True)
        
        return Div(
            Card(
                H3(f"{pip.fmt(step_id)}: Configure {step.show}"),
                P("Enter table data as JSON array of objects. Example is pre-populated."),
                P("Format: [{\"column1\": value1, \"column2\": value2}, {...}, ...]", 
                  style="font-size: 0.8em; font-style: italic;"),
                Form(
                    Div(
                        Textarea(
                            display_value,
                            name=step.done,
                            placeholder="Enter JSON array of objects for the DataFrame",
                            required=True,
                            rows=10,
                            style="width: 100%; font-family: monospace;"
                        ),
                        Div(
                            Button("Submit", type="submit", cls="primary"),
                            style="margin-top: 1vh; text-align: right;"
                        ),
                        style="width: 100%;"
                    ),
                    hx_post=f"/{app_name}/{step_id}_submit",
                    hx_target=f"#{step_id}"
                )
            ),
            Div(id=next_step_id),
            id=step_id
        )
    async def step_04_submit(self, request):
        """ 
        Process the submission for Step 4.
        
        This method demonstrates using pandas to generate an HTML table:
        1. Parses and validates the JSON input
        2. Creates a pandas DataFrame from the data
        3. Generates the HTML table using DataFrame.to_html()
        4. Embeds the raw HTML in a FastHTML component
        
        When using the "Combined Step" pattern with complex widgets, it's
        important to handle errors gracefully to avoid breaking the workflow.
        """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        step_id = "step_04"
        step_index = self.steps_indices[step_id]
        step = steps[step_index]
        pipeline_id = db.get("pipeline_id", "unknown")
        # Get form data
        form = await request.form()
        user_val = form.get(step.done, "")
        # Validate input
        is_valid, error_msg, error_component = pip.validate_step_input(user_val, step.show)
        if not is_valid:
            return error_component
            
        # Additional validation for JSON format
        try:
            json_data = json.loads(user_val)
            if not isinstance(json_data, list) or not json_data:
                return P("Invalid JSON: Must be a non-empty array of objects", style=pip.get_style("error"))
            if not all(isinstance(item, dict) for item in json_data):
                return P("Invalid JSON: All items must be objects (dictionaries)", style=pip.get_style("error"))
        except json.JSONDecodeError:
            return P("Invalid JSON format. Please check your syntax.", style=pip.get_style("error"))
        # Save the value to state
        await pip.update_step_state(pipeline_id, step_id, user_val, steps)
        # Create a pandas table from the JSON data
        try:
            data = json.loads(user_val)
            
            # Create a pandas DataFrame
            df = pd.DataFrame(data)
            
            # Generate HTML table with styling
            html_table = df.to_html(
                index=False,            # Don't include DataFrame index
                classes='table',        # Add a CSS class for styling
                border=0,               # Remove default HTML border attribute
                escape=True,            # Keep default HTML escaping for security
                justify='left'          # Align text to left
            )
            
            # Create a styled container for the table with responsive design
            table_container = Div(
                H5("Pandas DataFrame Table:"),
                # Add the HTML table with NotStr to prevent escaping
                Div(
                    NotStr(html_table),
                    style="overflow-x: auto; max-width: 100%;"
                ),
                style="margin-top: 1rem;"
            )
            
            # Send confirmation message
            await self.message_queue.add(pip, f"{step.show} complete. Table rendered successfully.", verbatim=True)
            
            # Create complete response with widget container
            response = HTMLResponse(to_xml(
                Div(
                    pip.widget_container(
                        step_id=step_id,
                        app_name=app_name,
                        message=f"{step.show}: Table rendered from pandas DataFrame",
                        widget=table_container,
                        steps=steps
                    ),
                    Div(id=f"{steps[step_index + 1].id}", hx_get=f"/{app_name}/{steps[step_index + 1].id}", hx_trigger="load"),
                    id=step_id
                )
            ))
            
            return response
            
        except Exception as e:
            logger.error(f"Error creating pandas table: {e}")
            return Div(NotStr(f"<div style='color: red;'>Error creating table: {str(e)}</div>"), _raw=True)
    # --- Step 5: Code Syntax Highlighter ---
    async def step_05(self, request):
        """ Handles GET request for Step 5: Code Syntax Highlighter. """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        step_id = "step_05"
        step_index = self.steps_indices[step_id]
        step = steps[step_index]
        next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'
        pipeline_id = db.get("pipeline_id", "unknown")
        state = pip.read_state(pipeline_id)
        step_data = pip.get_step_data(pipeline_id, step_id, {})
        user_val = step_data.get(step.done, "")
        
        # Check if workflow is finalized
        finalize_data = pip.get_step_data(pipeline_id, "finalize", {})
        if "finalized" in finalize_data and user_val:
            # Show the syntax highlighter in locked state
            try:
                # Check if user specified a language in format: ```language\ncode```
                language = 'javascript'  # Default language
                code_to_display = user_val
                
                if user_val.startswith('```'):
                    # Try to extract language from markdown-style code block
                    first_line = user_val.split('\n', 1)[0].strip()
                    if len(first_line) > 3:
                        detected_lang = first_line[3:].strip()
                        if detected_lang:
                            language = detected_lang
                            # Remove the language specification line from the code
                            code_to_display = user_val.split('\n', 1)[1] if '\n' in user_val else user_val
                    
                    # Remove trailing backticks if present
                    if code_to_display.endswith('```'):
                        code_to_display = code_to_display.rsplit('```', 1)[0]
                
                # Generate unique widget ID for this step and pipeline
                widget_id = f"prism-widget-{pipeline_id.replace('-', '_')}-{step_id}"
                
                # Use the helper method to create a prism widget with detected language
                prism_widget = self.create_prism_widget(code_to_display, widget_id, language)
                
                # Create response with locked view
                response = HTMLResponse(
                    to_xml(
                        Div(
                            Card(
                                H3(f"🔒 {step.show} ({language})"),
                                prism_widget
                            ),
                            Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load")
                        )
                    )
                )
                
                # Add HX-Trigger header to initialize Prism highlighting
                response.headers["HX-Trigger"] = json.dumps({
                    "initializePrism": {
                        "targetId": widget_id
                    }
                })
                
                return response
            except Exception as e:
                logger.error(f"Error creating Prism widget in locked view: {str(e)}")
                return Div(
                    Card(f"🔒 {step.show}: <content locked>"),
                    Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load")
                )
            
        # Check if step is complete and not reverting
        if user_val and state.get("_revert_target") != step_id:
            # Create the prism widget from the existing code
            try:
                # Check if user specified a language in format: ```language\ncode```
                language = 'javascript'  # Default language
                code_to_display = user_val
                
                if user_val.startswith('```'):
                    # Try to extract language from markdown-style code block
                    first_line = user_val.split('\n', 1)[0].strip()
                    if len(first_line) > 3:
                        detected_lang = first_line[3:].strip()
                        if detected_lang:
                            language = detected_lang
                            # Remove the language specification line from the code
                            code_to_display = user_val.split('\n', 1)[1] if '\n' in user_val else user_val
                    
                    # Remove trailing backticks if present
                    if code_to_display.endswith('```'):
                        code_to_display = code_to_display.rsplit('```', 1)[0]
                
                widget_id = f"prism-widget-{pipeline_id.replace('-', '_')}-{step_id}"
                prism_widget = self.create_prism_widget(code_to_display, widget_id, language)
                content_container = pip.widget_container(
                    step_id=step_id,
                    app_name=app_name,
                    message=f"{step.show}: Syntax highlighting with Prism.js ({language})",
                    widget=prism_widget,
                    steps=steps
                )
                
                response = HTMLResponse(
                    to_xml(
                        Div(
                            content_container,
                            Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load")
                        )
                    )
                )
                
                # Add HX-Trigger to initialize Prism highlighting
                response.headers["HX-Trigger"] = json.dumps({
                    "initializePrism": {
                        "targetId": widget_id
                    }
                })
                
                return response
            except Exception as e:
                # If there's an error creating the widget, revert to input form
                logger.error(f"Error creating Prism widget: {str(e)}")
                state["_revert_target"] = step_id
                pip.write_state(pipeline_id, state)
        
        # Show input form
        display_value = user_val if step.refill and user_val else await self.get_suggestion(step_id, state)
        await self.message_queue.add(pip, self.step_messages[step_id]["input"], verbatim=True)
        
        return Div(
            Card(
                H3(f"{pip.fmt(step_id)}: Configure {step.show}"),
                P("Enter code to be highlighted with syntax coloring. JavaScript example is pre-populated."),
                P("The code will be displayed with syntax highlighting and a copy button.", 
                  style="font-size: 0.8em; font-style: italic;"),
                Form(
                    Div(
                        Textarea(
                            display_value,
                            name=step.done,
                            placeholder="Enter code for syntax highlighting",
                            required=True,
                            rows=15,
                            style="width: 100%; font-family: monospace;"
                        ),
                        Div(
                            Button("Submit", type="submit", cls="primary"),
                            style="margin-top: 1vh; text-align: right;"
                        ),
                        style="width: 100%;"
                    ),
                    hx_post=f"/{app_name}/{step_id}_submit",
                    hx_target=f"#{step_id}"
                )
            ),
            Div(id=next_step_id),
            id=step_id
        )
    async def step_05_submit(self, request):
        """ Process the submission for Step 5. """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        step_id = "step_05"
        step_index = self.steps_indices[step_id]
        step = steps[step_index]
        pipeline_id = db.get("pipeline_id", "unknown")
        next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'
        # Get form data
        form = await request.form()
        user_val = form.get(step.done, "")
        # Check if user specified a language in format: ```language\ncode```
        language = 'javascript'  # Default language
        if user_val.startswith('```'):
            # Try to extract language from markdown-style code block
            first_line = user_val.split('\n', 1)[0].strip()
            if len(first_line) > 3:
                detected_lang = first_line[3:].strip()
                if detected_lang:
                    language = detected_lang
                    # Remove the language specification line from the code
                    user_val = user_val.split('\n', 1)[1] if '\n' in user_val else user_val
            
            # Remove trailing backticks if present
            if user_val.endswith('```'):
                user_val = user_val.rsplit('```', 1)[0]
        # Validate input
        is_valid, error_msg, error_component = pip.validate_step_input(user_val, step.show)
        if not is_valid:
            return error_component
        # Save the value to state
        await pip.update_step_state(pipeline_id, step_id, user_val, steps)
        
        # Generate unique widget ID for this step and pipeline
        widget_id = f"prism-widget-{pipeline_id.replace('-', '_')}-{step_id}"
        
        # Use the helper method to create a prism widget with detected language
        prism_widget = self.create_prism_widget(user_val, widget_id, language)
        
        # Create content container with the prism widget and initialization
        content_container = pip.widget_container(
            step_id=step_id,
            app_name=app_name,
            message=f"{step.show}: Syntax highlighting with Prism.js ({language})",
            widget=prism_widget,
            steps=steps
        )
        
        # Create full response structure
        response_content = Div(
            content_container,
            Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
            id=step_id
        )
        
        # Create an HTMLResponse with the content
        response = HTMLResponse(to_xml(response_content))
        
        # Add HX-Trigger header to initialize Prism highlighting
        response.headers["HX-Trigger"] = json.dumps({
            "initializePrism": {
                "targetId": widget_id
            }
        })
        
        # Send confirmation message
        await self.message_queue.add(pip, f"{step.show} complete. Code syntax highlighted with {language}.", verbatim=True)
        
        return response
    # --- Step 6: JavaScript Execution Widget ---
    async def step_06(self, request):
        """ Handles GET request for Step 6: JavaScript Widget. """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        step_id = "step_06"
        step_index = self.steps_indices[step_id]
        step = steps[step_index]
        next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'
        pipeline_id = db.get("pipeline_id", "unknown")
        state = pip.read_state(pipeline_id)
        step_data = pip.get_step_data(pipeline_id, step_id, {})
        user_val = step_data.get(step.done, "")
        
        # Check if workflow is finalized
        finalize_data = pip.get_step_data(pipeline_id, "finalize", {})
        if "finalized" in finalize_data and user_val:
            # Show the widget in locked state
            try:
                widget_id = f"js-widget-{pipeline_id}-{step_id}".replace("-", "_")
                target_id = f"{widget_id}_target"
                
                # Create a JavaScript widget for locked view with re-run button
                js_widget = Div(
                    # Container that will be manipulated by the JS code
                    P(
                        "JavaScript will execute here...", 
                        id=target_id, 
                        style="padding: 1.5rem; background-color: var(--pico-card-background-color); border-radius: var(--pico-border-radius); min-height: 100px;"
                    ),
                    # Keep the Re-run button even in locked state
                    Button(
                        "Re-run JavaScript", 
                        type="button", 
                        _onclick=f"runJsWidget('{widget_id}', `{user_val.replace('`', '\\`')}`, '{target_id}')",
                        style="margin-top: 1rem; background-color: #9370DB; border-color: #9370DB;"
                    ),
                    id=widget_id
                )
                
                # Create response with content in locked view
                response = HTMLResponse(
                    to_xml(
                        Div(
                            Card(
                                H3(f"🔒 {step.show}"),
                                js_widget
                            ),
                            Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load")
                        )
                    )
                )
                
                # Add HX-Trigger header to execute the JS code, even in locked state
                response.headers["HX-Trigger"] = json.dumps({
                    "runJavaScript": {
                        "widgetId": widget_id,
                        "code": user_val,
                        "targetId": target_id
                    }
                })
                
                return response
            except Exception as e:
                logger.error(f"Error creating JS widget in locked view: {str(e)}")
                return Div(
                    Card(f"🔒 {step.show}: <content locked>"),
                    Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load")
                )
            
        # Check if step is complete and not reverting
        if user_val and state.get("_revert_target") != step_id:
            # Create the JS widget from the existing code
            try:
                widget_id = f"js-widget-{pipeline_id}-{step_id}".replace("-", "_")
                target_id = f"{widget_id}_target"
                
                # Create a simple container with just the target element and re-run button
                js_widget = Div(
                    # Container that will be manipulated by the JS code
                    P(
                        "JavaScript will execute here...", 
                        id=target_id, 
                        style="padding: 1.5rem; background-color: var(--pico-card-background-color); border-radius: var(--pico-border-radius); min-height: 100px;"
                    ),
                    # Button to re-run the JavaScript
                    Button(
                        "Re-run JavaScript", 
                        type="button", 
                        _onclick=f"runJsWidget('{widget_id}', `{user_val.replace('`', '\\`')}`, '{target_id}')",
                        style="margin-top: 1rem; background-color: #9370DB; border-color: #9370DB;"
                    ),
                    id=widget_id
                )
                
                # Create content container with the widget
                content_container = pip.widget_container(
                    step_id=step_id,
                    app_name=app_name,
                    message=f"{step.show} Configured",
                    widget=js_widget,
                    steps=steps
                )
                
                # Create response with HX-Trigger
                response = HTMLResponse(
                    to_xml(
                        Div(
                            content_container,
                            Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load")
                        )
                    )
                )
                
                # Add HX-Trigger header to execute the JS code
                response.headers["HX-Trigger"] = json.dumps({
                    "runJavaScript": {
                        "widgetId": widget_id,
                        "code": user_val,
                        "targetId": target_id
                    }
                })
                
                return response
                
            except Exception as e:
                # If there's an error creating the widget, revert to input form
                logger.error(f"Error creating JS widget: {str(e)}")
                state["_revert_target"] = step_id
                pip.write_state(pipeline_id, state)
        
        # Show input form
        display_value = user_val if step.refill and user_val else await self.get_suggestion(step_id, state)
        await self.message_queue.add(pip, self.step_messages[step_id]["input"], verbatim=True)
        
        return Div(
            Card(
                H3(f"{pip.fmt(step_id)}: Configure {step.show}"),
                P("Enter JavaScript code for the widget. Example is pre-populated."),
                P("Use the 'widget' variable to access the container element.", 
                  style="font-size: 0.8em; font-style: italic;"),
                Form(
                    Div(
                        Textarea(
                            display_value,
                            name=step.done,
                            placeholder="Enter JavaScript code",
                            required=True,
                            rows=12,
                            style="width: 100%; font-family: monospace;"
                        ),
                        Div(
                            Button("Submit", type="submit", cls="primary"),
                            style="margin-top: 1vh; text-align: right;"
                        ),
                        style="width: 100%;"
                    ),
                    hx_post=f"/{app_name}/{step_id}_submit",
                    hx_target=f"#{step_id}"
                )
            ),
            Div(id=next_step_id),
            id=step_id
        )
    async def step_06_submit(self, request):
        """ Process the submission for Step 6. """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        step_id = "step_06"
        step_index = self.steps_indices[step_id]
        step = steps[step_index]
        pipeline_id = db.get("pipeline_id", "unknown")
        next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'
        # Get form data
        form = await request.form()
        user_val = form.get(step.done, "")
        # Validate input
        is_valid, error_msg, error_component = pip.validate_step_input(user_val, step.show)
        if not is_valid:
            return error_component
        # Save the value to state
        await pip.update_step_state(pipeline_id, step_id, user_val, steps)
        
        # Generate unique widget ID for this step and pipeline
        widget_id = f"js-widget-{pipeline_id}-{step_id}".replace("-", "_")
        target_id = f"{widget_id}_target"
        
        # Create a simple container with just the target element and re-run button
        js_widget = Div(
            # Container that will be manipulated by the JS code
            P(
                "JavaScript will execute here...", 
                id=target_id, 
                style="padding: 1.5rem; background-color: var(--pico-card-background-color); border-radius: var(--pico-border-radius); min-height: 100px;"
            ),
            # Button to re-run the JavaScript
            Button(
                "Re-run JavaScript", 
                type="button", 
                _onclick=f"runJsWidget('{widget_id}', `{user_val.replace('`', '\\`')}`, '{target_id}')",
                style="margin-top: 1rem; background-color: #9370DB; border-color: #9370DB;"
            ),
            id=widget_id
        )
        
        # Create content container with the widget
        content_container = pip.widget_container(
            step_id=step_id,
            app_name=app_name,
            message=f"{step.show}: Interactive JavaScript example",
            widget=js_widget,
            steps=steps
        )
        
        # Create full response structure
        response_content = Div(
            content_container,
            Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
            id=step_id
        )
        
        # Create an HTMLResponse with the content
        response = HTMLResponse(to_xml(response_content))
        
        # Add HX-Trigger header to execute the JS code
        response.headers["HX-Trigger"] = json.dumps({
            "runJavaScript": {
                "widgetId": widget_id,
                "code": user_val,
                "targetId": target_id
            }
        })
        
        # Send confirmation message
        await self.message_queue.add(pip, f"{step.show} complete. JavaScript executed.", verbatim=True)
        
        return response
    
    def create_marked_widget(self, markdown_content, widget_id):
        """
        Create a widget for rendering markdown content using marked.js
        
        Args:
            markdown_content: The markdown text to render
            widget_id: Unique ID for the widget
            
        Returns:
            Div element containing the widget
        """
        # Create a container for the markdown content
        widget = Div(
            # Hidden div containing the raw markdown content
            Div(
                markdown_content,
                id=f"{widget_id}_source",
                style="display: none;"
            ),
            # Container where the rendered HTML will be inserted
            Div(
                id=f"{widget_id}_rendered",
                cls="markdown-body p-3 border rounded bg-light"
            ),
            # JavaScript to initialize marked.js rendering
            Script(f"""
                document.addEventListener('htmx:afterOnLoad', function() {{
                    // Function to render markdown
                    function renderMarkdown() {{
                        const source = document.getElementById('{widget_id}_source');
                        const target = document.getElementById('{widget_id}_rendered');
                        if (source && target) {{
                            // Use marked.js to convert markdown to HTML
                            const html = marked.parse(source.textContent);
                            target.innerHTML = html;
                            // Apply syntax highlighting to code blocks if Prism is available
                            if (typeof Prism !== 'undefined') {{
                                Prism.highlightAllUnder(target);
                            }}
                        }}
                    }}
                    
                    // Check if marked.js is loaded
                    if (typeof marked !== 'undefined') {{
                        renderMarkdown();
                    }} else {{
                        console.error('marked.js is not loaded');
                    }}
                }});
                
                // Also listen for custom event from HX-Trigger
                document.addEventListener('initMarked', function(event) {{
                    if (event.detail.widgetId === '{widget_id}') {{
                        setTimeout(function() {{
                            const source = document.getElementById('{widget_id}_source');
                            const target = document.getElementById('{widget_id}_rendered');
                            if (source && target && typeof marked !== 'undefined') {{
                                const html = marked.parse(source.textContent);
                                target.innerHTML = html;
                                // Apply syntax highlighting to code blocks if Prism is available
                                if (typeof Prism !== 'undefined') {{
                                    Prism.highlightAllUnder(target);
                                }}
                            }}
                        }}, 100);
                    }}
                }});
            """),
            cls="marked-widget"
        )
        
        return widget
    # --- Helper Methods (Widget Creation) ---
    
    def create_pandas_table(self, data_str):
        """
        Create a pandas HTML table from JSON string data.
        
        This helper method encapsulates the widget creation logic, which:
        1. Makes the code more maintainable
        2. Allows reuse in both step_02 and step_02_submit
        3. Centralizes error handling
        
        When implementing complex widgets, consider using helper methods
        like this to separate widget creation logic from workflow logic.
        
        Note on FastHTML raw HTML handling:
        - Uses Div(NotStr(html_fragment), _raw=True) to embed raw HTML
        - NotStr prevents string escaping during XML rendering
        - _raw=True flag informs the component to accept unprocessed HTML
        """
        try:
            # Try parsing the JSON data
            data = json.loads(data_str)
            
            # Create a pandas DataFrame
            if isinstance(data, list) and all(isinstance(item, dict) for item in data):
                # Data is a list of dictionaries (most common format)
                df = pd.DataFrame(data)
            elif isinstance(data, list) and all(isinstance(item, list) for item in data):
                # Data is a list of lists, with first row as headers
                headers = data[0]
                rows = data[1:]
                df = pd.DataFrame(rows, columns=headers)
            else:
                return Div(NotStr("<div style='color: red;'>Unsupported data format. Please provide a list of objects.</div>"), _raw=True)
            
            # Generate HTML table with styling
            html_table = df.to_html(
                index=False,            # Don't include DataFrame index
                classes='table',        # Add a CSS class for styling
                border=0,               # Remove default HTML border attribute
                escape=True,            # Keep default HTML escaping for security
                justify='left'          # Align text to left
            )
            
            # Create a styled container for the table with responsive design
            table_container = Div(
                H5("Pandas DataFrame Table:"),
                # Add the HTML table with NotStr to prevent escaping
                Div(
                    NotStr(html_table),
                    style="overflow-x: auto; max-width: 100%;"
                ),
                style="margin-top: 1rem;"
            )
            
            return table_container
            
        except Exception as e:
            logger.error(f"Error creating pandas table: {e}")
            return Div(NotStr(f"<div style='color: red;'>Error creating table: {str(e)}</div>"), _raw=True)
    def create_mermaid_widget(self, diagram_syntax, widget_id):
        """Create a mermaid diagram widget container."""
        # Create container for the widget
        container = Div(
            Div(
                # Container to render the mermaid diagram
                H5("Rendered Diagram:"),
                Div(
                    # This div with class="mermaid" will be targeted by the mermaid.js library
                    Div(
                        diagram_syntax,
                        cls="mermaid",
                        style="width: 100%; background-color: var(--pico-card-background-color); border-radius: var(--pico-border-radius); padding: 1rem;"
                    ),
                    id=f"{widget_id}_output"
                )
            ),
            id=widget_id
        )
        
        # Create a script to initialize and run mermaid on this container
        init_script = Script(
            f"""
            (function() {{
                // Give the DOM time to fully render before initializing Mermaid
                setTimeout(function() {{
                    // Initialize mermaid
                    if (typeof mermaid !== 'undefined') {{
                        try {{
                            mermaid.initialize({{ 
                                startOnLoad: false,  // Important - don't auto-init
                                theme: 'dark',       // Use dark theme for better visibility
                                securityLevel: 'loose',
                                flowchart: {{
                                    htmlLabels: true
                                }}
                            }});
                            
                            // Find all mermaid divs in this widget and render them
                            const container = document.getElementById('{widget_id}');
                            if (!container) return;
                            
                            const mermaidDiv = container.querySelector('.mermaid');
                            if (mermaidDiv) {{
                                // Force a repaint before initializing
                                void container.offsetWidth;
                                
                                // Render the diagram
                                if (typeof mermaid.run === 'function') {{
                                    // Newer Mermaid API
                                    mermaid.run({{ nodes: [mermaidDiv] }});
                                }} else {{
                                    // Older Mermaid API
                                    mermaid.init(undefined, mermaidDiv);
                                }}
                                console.log('Mermaid rendering successful');
                            }}
                        }} catch(e) {{
                            console.error("Mermaid rendering error:", e);
                        }}
                    }} else {{
                        console.error("Mermaid library not found. Make sure it's included in the page headers.");
                    }}
                }}, 300); // 300ms delay to ensure DOM is ready
            }})();
            """,
            type="text/javascript"
        )
        
        return Div(container, init_script)
    def create_prism_widget(self, code, widget_id, language='javascript'):
        """Create a Prism.js syntax highlighting widget with copy functionality.
        
        Args:
            code (str): The code to highlight
            widget_id (str): Unique ID for the widget
            language (str): The programming language for syntax highlighting (default: javascript)
        """
        # Generate a unique ID for the hidden textarea
        textarea_id = f"{widget_id}_raw_code"
        
        # Create container for the widget
        container = Div(
            Div(
                H5("Syntax Highlighted Code:"),
                # Add a hidden textarea to hold the raw code (much safer than trying to escape it for JS)
                Textarea(
                    code,
                    id=textarea_id,
                    style="display: none;"  # Hide the textarea
                ),
                # This pre/code structure is required for Prism.js
                Pre(
                    Code(
                        code,
                        cls=f"language-{language}"  # Language class for Prism
                    ),
                    cls="line-numbers"  # Enable line numbers
                ),
                style="margin-top: 1rem;"
            ),
            id=widget_id
        )
        
        # Create script to initialize Prism with debugging
        init_script = Script(
            f"""
            (function() {{
                console.log('Prism widget loaded, ID: {widget_id}');
                // Check if Prism is loaded
                if (typeof Prism === 'undefined') {{
                    console.error('Prism library not found');
                    return;
                }}
                
                // Attempt to manually trigger highlighting
                setTimeout(function() {{
                    try {{
                        console.log('Manually triggering Prism highlighting for {widget_id}');
                        Prism.highlightAllUnder(document.getElementById('{widget_id}'));
                    }} catch(e) {{
                        console.error('Error during manual Prism highlighting:', e);
                    }}
                }}, 300);
            }})();
            """,
            type="text/javascript"
        )
        
        return Div(container, init_script) 
    
    # --- Step 7: Simple Text Widget (Duplicate) ---
    async def step_07(self, request):
        """ 
        Handles GET request for Step 7: Matplotlib Histogram Widget.
        
        This step allows users to input counter data and visualizes it as a histogram.
        """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        step_id = "step_07"
        step_index = self.steps_indices[step_id]
        step = steps[step_index]
        next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'
        pipeline_id = db.get("pipeline_id", "unknown")
        state = pip.read_state(pipeline_id)
        step_data = pip.get_step_data(pipeline_id, step_id, {})
        counter_data = step_data.get(step.done, "")
        
        # Check if workflow is finalized
        finalize_data = pip.get_step_data(pipeline_id, "finalize", {})
        if "finalized" in finalize_data and counter_data:
            # Show the histogram in locked state
            try:
                histogram_widget = self.create_matplotlib_histogram(counter_data)
                return Div(
                    Card(
                        H3(f"🔒 {step.show}"),
                        histogram_widget
                    ),
                    Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load")
                )
            except Exception as e:
                logger.error(f"Error creating histogram in finalized view: {str(e)}")
                return Div(
                    Card(f"🔒 {step.show}: <content locked>"),
                    Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load")
                )
            
        # Check if step is complete and not reverting
        if counter_data and state.get("_revert_target") != step_id:
            # Create the histogram widget from the existing data
            try:
                histogram_widget = self.create_matplotlib_histogram(counter_data)
                content_container = pip.widget_container(
                    step_id=step_id,
                    app_name=app_name,
                    message=f"{step.show} Configured",
                    widget=histogram_widget,
                    steps=steps
                )
                return Div(
                    content_container,
                    Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load")
                )
            except Exception as e:
                # If there's an error creating the widget, revert to input form
                logger.error(f"Error creating histogram widget: {str(e)}")
                state["_revert_target"] = step_id
                pip.write_state(pipeline_id, state)
        
        # Show input form
        display_value = counter_data if step.refill and counter_data else await self.get_suggestion(step_id, state)
        await self.message_queue.add(pip, self.step_messages[step_id]["input"], verbatim=True)
        
        return Div(
            Card(
                H3(f"{pip.fmt(step_id)}: Configure {step.show}"),
                P("Enter counter data as JSON object (keys and values):"),
                P("Format: {\"category1\": count1, \"category2\": count2, ...}", 
                  style="font-size: 0.8em; font-style: italic;"),
                Form(
                    Div(
                        Textarea(
                            display_value,
                            name=step.done,
                            placeholder="Enter JSON object for Counter data",
                            required=True,
                            rows=10,
                            style="width: 100%; font-family: monospace;"
                        ),
                        Div(
                            Button("Create Histogram", type="submit", cls="primary"),
                            style="margin-top: 1vh; text-align: right;"
                        ),
                        style="width: 100%;"
                    ),
                    hx_post=f"/{app_name}/{step_id}_submit",
                    hx_target=f"#{step_id}"
                )
            ),
            Div(id=next_step_id),
            id=step_id
        )
    async def step_07_submit(self, request):
        """ 
        Process the submission for Step 7 (Matplotlib Histogram).
        
        Takes counter data as input and creates a histogram visualization.
        """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        step_id = "step_07"
        step_index = self.steps_indices[step_id]
        step = steps[step_index]
        pipeline_id = db.get("pipeline_id", "unknown")
        next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'
        # Get form data
        form = await request.form()
        counter_data = form.get(step.done, "").strip()
        # Validate input
        is_valid, error_msg, error_component = pip.validate_step_input(counter_data, step.show)
        if not is_valid:
            return error_component
        
        # Additional validation for JSON format
        try:
            import json
            data = json.loads(counter_data)
            if not isinstance(data, dict):
                return P("Invalid JSON: Must be an object (dictionary) with keys and values", style=pip.get_style("error"))
            if not data:
                return P("Invalid data: Counter cannot be empty", style=pip.get_style("error"))
        except json.JSONDecodeError:
            return P("Invalid JSON format. Please check your syntax.", style=pip.get_style("error"))
        # Save the counter data to state
        await pip.update_step_state(pipeline_id, step_id, counter_data, steps)
        # Create the matplotlib histogram widget
        try:
            histogram_widget = self.create_matplotlib_histogram(counter_data)
            
            # Create content container with the widget
            content_container = pip.widget_container(
                step_id=step_id,
                app_name=app_name,
                message=f"{step.show}: Histogram created from Counter data",
                widget=histogram_widget,
                steps=steps
            )
            
            # Create full response structure
            response_content = Div(
                content_container,
                Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
                id=step_id
            )
            
            # Send confirmation message
            await self.message_queue.add(pip, f"{step.show} complete. Histogram created.", verbatim=True)
            # Return the HTMLResponse with the widget container
            return HTMLResponse(to_xml(response_content))
            
        except Exception as e:
            logger.error(f"Error creating histogram visualization: {e}")
            return P(f"Error creating histogram: {str(e)}", style=pip.get_style("error"))
    # --- Step 8: New Placeholder Step ---
    async def step_08(self, request):
        """ 
        Handles GET request for Step 8: New Placeholder Step.
        
        This is a minimal placeholder step with just a Proceed button.
        It maintains the same workflow pattern but without collecting user data.
        """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        step_id = "step_08"
        step_index = self.steps_indices[step_id]
        step = steps[step_index]
        next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'
        pipeline_id = db.get("pipeline_id", "unknown")
        state = pip.read_state(pipeline_id)
        step_data = pip.get_step_data(pipeline_id, step_id, {})
        placeholder_value = step_data.get(step.done, "")
        
        # Check if workflow is finalized
        finalize_data = pip.get_step_data(pipeline_id, "finalize", {})
        if "finalized" in finalize_data and placeholder_value:
            # Show a simple confirmation in finalized state
            return Div(
                Card(
                    H3(f"🔒 {step.show}"),
                    P("New placeholder step completed")
                ),
                Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load")
            )
            
        # Check if step is complete and not reverting
        if placeholder_value and state.get("_revert_target") != step_id:
            # Show completion message
            content_container = pip.widget_container(
                step_id=step_id,
                app_name=app_name,
                message=f"{step.show} Completed",
                widget=P("New placeholder step completed"),
                steps=steps
            )
            return Div(
                content_container,
                Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load")
            )
        else:
            # Show just a Proceed button
            await self.message_queue.add(pip, self.step_messages[step_id]["input"], verbatim=True)
            
            return Div(
                Card(
                    H3(f"{pip.fmt(step_id)}: {step.show}"),
                    P("This is a new placeholder step. No input is required."),
                    Form(
                        Div(
                            Button("Proceed", type="submit", cls="primary"),
                            style="margin-top: 1vh; text-align: right;"
                        ),
                        hx_post=f"/{app_name}/{step_id}_submit",
                        hx_target=f"#{step_id}"
                    )
                ),
                Div(id=next_step_id),
                id=step_id
            )
    async def step_08_submit(self, request):
        """ 
        Process the submission for Step 8 (New Placeholder).
        
        This is a simplified version that doesn't collect user input
        but maintains the same workflow progression pattern.
        """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        step_id = "step_08"
        step_index = self.steps_indices[step_id]
        step = steps[step_index]
        pipeline_id = db.get("pipeline_id", "unknown")
        next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'
        # For placeholder, we use a fixed value instead of form data
        placeholder_value = "completed"
        # Save the placeholder value to state
        await pip.update_step_state(pipeline_id, step_id, placeholder_value, steps)
        # Create a simple confirmation widget
        placeholder_widget = P("New placeholder step completed")
        
        # Create content container with the widget
        content_container = pip.widget_container(
            step_id=step_id,
            app_name=app_name,
            message=f"{step.show} Completed",
            widget=placeholder_widget,
            steps=steps
        )
        
        # Create full response structure
        response_content = Div(
            content_container,
            Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
            id=step_id
        )
        
        # Send confirmation message
        await self.message_queue.add(pip, f"{step.show} complete.", verbatim=True)
        # Return the HTMLResponse with the widget container
        return HTMLResponse(to_xml(response_content))
    # Add the helper method to create a matplotlib histogram
    def create_matplotlib_histogram(self, data_str):
        """
        Create a matplotlib histogram visualization from JSON counter data.
        
        Args:
            data_str: A JSON string representing counter data
            
        Returns:
            A Div element containing the histogram image
        """
        try:
            # Parse the JSON data
            import json
            from collections import Counter
            
            # Try to parse as a dict (direct Counter format)
            data = json.loads(data_str)
            
            if not isinstance(data, dict):
                return Div(NotStr("<div style='color: red;'>Error: Data must be a JSON object with keys and values</div>"), _raw=True)
            
            # Create a Counter from the data
            counter = Counter(data)
            
            # Check if we have data to plot
            if not counter:
                return Div(NotStr("<div style='color: red;'>Error: No data to plot</div>"), _raw=True)
            
            # Generate the matplotlib figure
            import matplotlib.pyplot as plt
            from io import BytesIO
            import base64
            
            # Create the figure
            plt.figure(figsize=(10, 6))
            
            # Sort data by keys for better visualization
            labels = sorted(counter.keys())
            values = [counter[label] for label in labels]
            
            # Create the bar plot
            plt.bar(labels, values, color='skyblue')
            
            # Add labels and title
            plt.xlabel('Categories')
            plt.ylabel('Counts')
            plt.title('Histogram from Counter Data')
            
            # Add grid for better readability
            plt.grid(axis='y', linestyle='--', alpha=0.7)
            
            # Rotate x-axis labels if there are many categories
            if len(labels) > 5:
                plt.xticks(rotation=45, ha='right')
            
            # Adjust layout
            plt.tight_layout()
            
            # Save figure to a bytes buffer
            buffer = BytesIO()
            plt.savefig(buffer, format='png')
            plt.close()
            
            # Convert to base64 for embedding in HTML
            img_str = base64.b64encode(buffer.getvalue()).decode('utf-8')
            
            # Create an HTML component with the image and some metadata
            return Div(
                H4("Histogram Visualization:"),
                P(f"Data: {len(counter)} categories, {sum(counter.values())} total counts"),
                Div(
                    NotStr(f'<img src="data:image/png;base64,{img_str}" style="max-width:100%; height:auto;" />'),
                    style="text-align: center; margin-top: 1rem;"
                ),
                style="overflow-x: auto;"
            )
        
        except Exception as e:
            import traceback
            tb = traceback.format_exc()
            return Div(NotStr(f"<div style='color: red;'>Error creating histogram: {str(e)}<br><pre>{tb}</pre></div>"), _raw=True)
# File token count: 19,775 tokens
# <<< END FILE: /home/mike/repos/pipulate/plugins/60_widget_examples.py >>>
# <<< START FILE: /home/mike/repos/pipulate/plugins/70_blank_workflow.py >>>
import asyncio
from collections import namedtuple
from datetime import datetime
from fasthtml.common import * # type: ignore
from loguru import logger
"""
Pipulate Workflow Template
A minimal starter template for creating step-based Pipulate workflows.
"""
# Model for a workflow step
Step = namedtuple('Step', ['id', 'done', 'show', 'refill', 'transform'], defaults=(None,))

class BlankWorkflow:
    """
    Blank Workflow Template
    
    A minimal starting point for creating new workflows.
    """
    # --- Workflow Configuration ---
    APP_NAME = "blank"              # Unique identifier for this workflow's routes and data
    DISPLAY_NAME = "Blank Workflow" # User-friendly name shown in the UI
    ENDPOINT_MESSAGE = (            # Message shown on the workflow's landing page
        "This is a blank workflow template. "
        "Enter an ID to start or resume your workflow."
    )
    TRAINING_PROMPT = "widget_implementation_guide.md" # Filename (in /training) or text for AI context
    PRESERVE_REFILL = True          # Whether to keep input values when reverting
    # --- Initialization ---
    def __init__(self, app, pipulate, pipeline, db, app_name=APP_NAME):
        """Initialize the workflow, define steps, and register routes."""
        self.app = app
        self.app_name = app_name
        self.pipulate = pipulate
        self.pipeline = pipeline
        self.steps_indices = {}
        self.db = db
        pip = self.pipulate
        self.message_queue = pip.message_queue
        # Define workflow steps
        steps = [
            Step(
                id='step_01',
                done='placeholder',
                show='Step 1 Placeholder',
                refill=False,
            ),
            # Add more steps as needed
        ]
        
        # Register standard workflow routes
        routes = [
            (f"/{app_name}", self.landing),
            (f"/{app_name}/init", self.init, ["POST"]),
            (f"/{app_name}/jump_to_step", self.jump_to_step, ["POST"]),
            (f"/{app_name}/revert", self.handle_revert, ["POST"]),
            (f"/{app_name}/finalize", self.finalize, ["GET", "POST"]),
            (f"/{app_name}/unfinalize", self.unfinalize, ["POST"]),
        ]
        # Register routes for each step
        self.steps = steps
        for step in steps:
            step_id = step.id
            routes.append((f"/{app_name}/{step_id}", getattr(self, step_id)))
            routes.append((f"/{app_name}/{step_id}_submit", getattr(self, f"{step_id}_submit"), ["POST"]))
        # Register all routes with the FastHTML app
        for path, handler, *methods in routes:
            method_list = methods[0] if methods else ["GET"]
            app.route(path, methods=method_list)(handler)
        # Define UI messages
        self.step_messages = {
            "finalize": {
                "ready": "All steps complete. Ready to finalize workflow.",
                "complete": f"Workflow finalized. Use {pip.UNLOCK_BUTTON_LABEL} to make changes."
            }
        }
        # Create default messages for each step
        for step in steps:
            self.step_messages[step.id] = {
                "input": f"{pip.fmt(step.id)}: Please complete {step.show}.",
                "complete": f"{step.show} complete. Continue to next step."
            }
        # Add the finalize step internally
        steps.append(Step(id='finalize', done='finalized', show='Finalize', refill=False))
        self.steps_indices = {step.id: i for i, step in enumerate(steps)}
    # --- Core Workflow Engine Methods ---
    async def landing(self):
        """Renders the initial landing page with the key input form."""
        pip, pipeline, steps, app_name = self.pipulate, self.pipeline, self.steps, self.app_name
        title = f"{self.DISPLAY_NAME or app_name.title()}"
        full_key, prefix, user_part = pip.generate_pipeline_key(self)
        default_value = full_key
        pipeline.xtra(app_name=app_name)
        matching_records = [record.pkey for record in pipeline() if record.pkey.startswith(prefix)]
        datalist_options = [f"{prefix}{record_key.replace(prefix, '')}" for record_key in matching_records]
        return Container(
            Card(
                H2(title),
                P(self.ENDPOINT_MESSAGE, style="font-size: 0.9em; color: #666;"),
                Form(
                    pip.wrap_with_inline_button(
                        Input(
                            placeholder="Existing or new 🗝 here (Enter for auto)", name="pipeline_id",
                            list="pipeline-ids", type="search", required=False, autofocus=True,
                            value=default_value, _onfocus="this.setSelectionRange(this.value.length, this.value.length)",
                            cls="contrast"
                        ),
                        button_label=f"Enter 🔑", button_class="secondary"
                    ),
                    pip.update_datalist("pipeline-ids", options=datalist_options if datalist_options else None),
                    hx_post=f"/{app_name}/init", hx_target=f"#{app_name}-container"
                )
            ),
            Div(id=f"{app_name}-container")
        )
    async def init(self, request):
        """Handles the key submission, initializes state, and renders the step UI placeholders."""
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        form = await request.form()
        user_input = form.get("pipeline_id", "").strip()
        if not user_input:
            from starlette.responses import Response
            response = Response("")
            response.headers["HX-Refresh"] = "true"
            return response
        context = pip.get_plugin_context(self)
        profile_name = context['profile_name'] or "default"
        plugin_name = context['plugin_name'] or app_name
        profile_part = profile_name.replace(" ", "_")
        plugin_part = plugin_name.replace(" ", "_")
        expected_prefix = f"{profile_part}-{plugin_part}-"
        if user_input.startswith(expected_prefix):
            pipeline_id = user_input
        else:
            _, prefix, user_provided_id = pip.generate_pipeline_key(self, user_input)
            pipeline_id = f"{prefix}{user_provided_id}"
        db["pipeline_id"] = pipeline_id
        state, error = pip.initialize_if_missing(pipeline_id, {"app_name": app_name})
        if error: return error
        await self.message_queue.add(pip, f"Workflow ID: {pipeline_id}", verbatim=True, spaces_before=0)
        await self.message_queue.add(pip, f"Return later by selecting '{pipeline_id}' from the dropdown.", verbatim=True, spaces_before=0)
        
        # Build UI starting with first step
        return Div(
            Div(id="step_01", hx_get=f"/{app_name}/step_01", hx_trigger="load"),
            id=f"{app_name}-container"
        )
    async def finalize(self, request):
        """Handles GET request to show Finalize button and POST request to lock the workflow."""
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        pipeline_id = db.get("pipeline_id", "unknown")
        finalize_step = steps[-1]
        finalize_data = pip.get_step_data(pipeline_id, finalize_step.id, {})
        if request.method == "GET":
            if finalize_step.done in finalize_data:
                return Card(
                    H3("Workflow is locked."),
                    Form(
                        Button(pip.UNLOCK_BUTTON_LABEL, type="submit", cls="secondary outline"),
                        hx_post=f"/{app_name}/unfinalize", 
                        hx_target=f"#{app_name}-container"
                    ),
                    id=finalize_step.id
                )
            else:
                all_steps_complete = all(
                    pip.get_step_data(pipeline_id, step.id, {}).get(step.done) 
                    for step in steps[:-1]
                )
                if all_steps_complete:
                    return Card(
                        H3("All steps complete. Finalize?"),
                        P("You can revert to any step and make changes.", style="font-size: 0.9em; color: #666;"),
                        Form(
                            Button("Finalize", type="submit", cls="primary"),
                            hx_post=f"/{app_name}/finalize", 
                            hx_target=f"#{app_name}-container"
                        ),
                        id=finalize_step.id
                    )
                else:
                    return Div(id=finalize_step.id)
        else:
            await pip.finalize_workflow(pipeline_id)
            await self.message_queue.add(pip, self.step_messages["finalize"]["complete"], verbatim=True)
            return pip.rebuild(app_name, steps)
    async def unfinalize(self, request):
        """Handles POST request to unlock the workflow."""
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        pipeline_id = db.get("pipeline_id", "unknown")
        await pip.unfinalize_workflow(pipeline_id)
        await self.message_queue.add(pip, "Workflow unfinalized! You can now revert to any step and make changes.", verbatim=True)
        return pip.rebuild(app_name, steps)
    async def jump_to_step(self, request):
        """Handles POST request from breadcrumb navigation to jump to a specific step."""
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        form = await request.form()
        step_id = form.get("step_id")
        db["step_id"] = step_id
        return pip.rebuild(app_name, steps)
    async def get_suggestion(self, step_id, state):
        """Gets a suggested input value for a step, often using the previous step's transformed output."""
        pip, db, steps = self.pipulate, self.db, self.steps
        step = next((s for s in steps if s.id == step_id), None)
        if not step or not step.transform: return ""
        prev_index = self.steps_indices[step_id] - 1
        if prev_index < 0: return ""
        prev_step = steps[prev_index]
        prev_data = pip.get_step_data(db["pipeline_id"], prev_step.id, {})
        prev_value = prev_data.get(prev_step.done, "")
        return step.transform(prev_value) if prev_value else ""
    async def handle_revert(self, request):
        """Handles POST request to revert to a previous step, clearing subsequent step data."""
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        form = await request.form()
        step_id = form.get("step_id")
        pipeline_id = db.get("pipeline_id", "unknown")
        if not step_id: return P("Error: No step specified", style=self.pipulate.get_style("error"))
        await pip.clear_steps_from(pipeline_id, step_id, steps)
        state = pip.read_state(pipeline_id)
        state["_revert_target"] = step_id
        pip.write_state(pipeline_id, state)
        message = await pip.get_state_message(pipeline_id, steps, self.step_messages)
        await self.message_queue.add(pip, message, verbatim=True)
        return pip.rebuild(app_name, steps)
    # --- Placeholder Step Methods ---
    async def step_01(self, request):
        """Handles GET request for placeholder Step 1.
        
        Widget Conversion Points:
        1. CUSTOMIZE_STEP_DEFINITION: Change 'done' field to specific data field name
        2. CUSTOMIZE_FORM: Replace the Proceed button with specific form elements
        3. CUSTOMIZE_DISPLAY: Update the finalized state display for your widget
        4. CUSTOMIZE_COMPLETE: Enhance the completion state with widget display
        
        Critical Elements to Preserve:
        - Chain reaction with next_step_id
        - Finalization state handling pattern
        - Revert control mechanism
        - Overall Div structure and ID patterns
        """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        step_id = "step_01"
        step_index = self.steps_indices[step_id]
        step = steps[step_index]
        next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'
        pipeline_id = db.get("pipeline_id", "unknown")
        state = pip.read_state(pipeline_id)
        step_data = pip.get_step_data(pipeline_id, step_id, {})
        placeholder_value = step_data.get(step.done, "")  # CUSTOMIZE_VALUE_ACCESS: Rename to match your data field
        # Check if workflow is finalized
        finalize_data = pip.get_step_data(pipeline_id, "finalize", {})
        if "finalized" in finalize_data and placeholder_value:
            # CUSTOMIZE_DISPLAY: Enhanced finalized state display for your widget
            return Div(
                Card(
                    H3(f"🔒 {step.show}: Completed")  # Combined headline with completion status
                ),
                Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
                id=step_id
            )
            
        # Check if step is complete and not being reverted to
        if placeholder_value and state.get("_revert_target") != step_id:
            # CUSTOMIZE_COMPLETE: Enhanced completion display for your widget
            return Div(
                pip.revert_control(step_id=step_id, app_name=app_name, message=f"{step.show}: Complete", steps=steps),
                Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
                id=step_id
            )
        else:
            # CUSTOMIZE_FORM: Replace with your widget's input form
            await self.message_queue.add(pip, self.step_messages[step_id]["input"], verbatim=True)
            
            return Div(
                Card(
                    H3(f"{step.show}"),
                    P("This is a placeholder step. Click Proceed to continue to the next step."),
                    Form(
                        Button("Proceed", type="submit", cls="primary"),
                        hx_post=f"/{app_name}/{step_id}_submit", 
                        hx_target=f"#{step_id}"
                    )
                ),
                Div(id=next_step_id),  # PRESERVE: Empty div for next step - DO NOT ADD hx_trigger HERE
                id=step_id
            )
    async def step_01_submit(self, request):
        """Process the submission for placeholder Step 1.
        
        Chain Reaction Pattern:
        When a step completes, it MUST explicitly trigger the next step by including
        a div for the next step with hx-trigger="load". While this may seem redundant,
        it is more reliable than depending on HTMX event bubbling.
        """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        step_id = "step_01"
        step_index = self.steps_indices[step_id]
        step = steps[step_index]
        next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'
        pipeline_id = db.get("pipeline_id", "unknown")
        
        # Process and save data...
        placeholder_value = "completed"
        await pip.update_step_state(pipeline_id, step_id, placeholder_value, steps)
        await self.message_queue.add(pip, f"{step.show} complete.", verbatim=True)
        
        # CRITICAL: Return the completed view WITH explicit next step trigger
        return Div(
            pip.revert_control(step_id=step_id, app_name=app_name, message=f"{step.show}: Complete", steps=steps),
            Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
            id=step_id
        )
# File token count: 3,390 tokens
# <<< END FILE: /home/mike/repos/pipulate/plugins/70_blank_workflow.py >>>
# <<< START FILE: /home/mike/repos/pipulate/plugins/80_splice_workflow.py >>>
import asyncio
from collections import namedtuple
from datetime import datetime
from fasthtml.common import * # type: ignore
from loguru import logger
"""
Pipulate Workflow Template
A guide for creating multi-step workflows with proper chain reaction behavior.
"""
# Model for a workflow step
Step = namedtuple('Step', ['id', 'done', 'show', 'refill', 'transform'], defaults=(None,))

class SpliceWorkflow:
    """
    Splice Workflow Template
    
    A demonstration workflow showing how to extend from a simple single-step workflow 
    (like 70_blank_workflow.py) to a multi-step workflow with proper HTMX chain reactions.
    
    ## Critical Chain Reaction Pattern
    
    Pipulate workflows use an explicit HTMX triggering pattern where:
    
    1. Each step must explicitly trigger the next step in the sequence when completed
    2. This is done by returning a div with the next step's ID and hx_trigger="load"
    3. Removing or altering this pattern will break the workflow progression
    
    ## Steps Progression Mechanism:
    
    1. init(): Creates placeholder for step_01 with hx_trigger="load"
    2. step_01(): Loads and either:
       - If incomplete: Shows the input form
       - If complete: Shows completion state AND explicitly triggers step_02
    3. step_01_submit(): Processes data and returns a view that:
       - Shows the completion state for step_01
       - EXPLICITLY triggers step_02 with <Div id="step_02" hx_get="/app/step_02" hx_trigger="load">
    4. Each subsequent step follows the same pattern
    5. The last step triggers the finalize step
    
    This explicit triggering is more reliable than depending on HTMX event bubbling.
    """
    # --- Workflow Configuration ---
    APP_NAME = "splice"           # Unique identifier for this workflow's routes and data
    DISPLAY_NAME = "Splice Workflow" # User-friendly name shown in the UI
    ENDPOINT_MESSAGE = (            # Message shown on the workflow's landing page
        "This is a splice workflow template. "
        "Enter an ID to start or resume your workflow."
    )
    TRAINING_PROMPT = "widget_implementation_guide.md" # Filename (in /training) or text for AI context
    PRESERVE_REFILL = True          # Whether to keep input values when reverting
    # --- Initialization ---
    def __init__(self, app, pipulate, pipeline, db, app_name=APP_NAME):
        """Initialize the workflow, define steps, and register routes."""
        self.app = app
        self.app_name = app_name
        self.pipulate = pipulate
        self.pipeline = pipeline
        self.steps_indices = {}
        self.db = db
        pip = self.pipulate
        self.message_queue = pip.message_queue
        # Define workflow steps
        # SPLICING GUIDE: When adding new steps to a workflow:
        # 1. Add each step in order in this list
        # 2. Create corresponding step_XX and step_XX_submit methods
        # 3. The chain reaction happens automatically as long as each step's 
        #    completion state includes a div triggering the next step
        steps = [
            Step(
                id='step_01',
                done='placeholder',
                show='Step 1 Placeholder',
                refill=False,
            ),
            Step(
                id='step_02',
                done='placeholder',
                show='Step 2 Placeholder',
                refill=False,
            ),
            Step(
                id='step_03',
                done='placeholder',
                show='Step 3 Placeholder',
                refill=False,
            ),
            # Add more steps as needed
        ]
        
        # CRITICAL: Register standard workflow routes
        # DO NOT MODIFY this routes registration pattern
        routes = [
            (f"/{app_name}", self.landing),
            (f"/{app_name}/init", self.init, ["POST"]),
            (f"/{app_name}/jump_to_step", self.jump_to_step, ["POST"]),
            (f"/{app_name}/revert", self.handle_revert, ["POST"]),
            (f"/{app_name}/finalize", self.finalize, ["GET", "POST"]),
            (f"/{app_name}/unfinalize", self.unfinalize, ["POST"]),
        ]
        # CRITICAL: Register routes for each step
        # This creates the endpoints that each step will call via HTMX
        self.steps = steps
        for step in steps:
            step_id = step.id
            routes.append((f"/{app_name}/{step_id}", getattr(self, step_id)))
            routes.append((f"/{app_name}/{step_id}_submit", getattr(self, f"{step_id}_submit"), ["POST"]))
        # Register all routes with the FastHTML app
        for path, handler, *methods in routes:
            method_list = methods[0] if methods else ["GET"]
            app.route(path, methods=method_list)(handler)
        # Define UI messages
        self.step_messages = {
            "finalize": {
                "ready": "All steps complete. Ready to finalize workflow.",
                "complete": f"Workflow finalized. Use {pip.UNLOCK_BUTTON_LABEL} to make changes."
            }
        }
        # Create default messages for each step
        for step in steps:
            self.step_messages[step.id] = {
                "input": f"{pip.fmt(step.id)}: Please complete {step.show}.",
                "complete": f"{step.show} complete. Continue to next step."
            }
        # CRITICAL: Add the finalize step internally
        # The finalize step must be added after registering routes but before creating step indices
        # It's included in the steps list but doesn't get its own routes
        steps.append(Step(id='finalize', done='finalized', show='Finalize', refill=False))
        self.steps_indices = {step.id: i for i, step in enumerate(steps)}
    # --- Core Workflow Engine Methods ---
    # DO NOT modify these methods when extending a workflow
    # These handle the core mechanics for all workflows
    async def landing(self):
        """Renders the initial landing page with the key input form."""
        pip, pipeline, steps, app_name = self.pipulate, self.pipeline, self.steps, self.app_name
        title = f"{self.DISPLAY_NAME or app_name.title()}"
        full_key, prefix, user_part = pip.generate_pipeline_key(self)
        default_value = full_key
        pipeline.xtra(app_name=app_name)
        matching_records = [record.pkey for record in pipeline() if record.pkey.startswith(prefix)]
        datalist_options = [f"{prefix}{record_key.replace(prefix, '')}" for record_key in matching_records]
        return Container(
            Card(
                H2(title),
                P(self.ENDPOINT_MESSAGE, style="font-size: 0.9em; color: #666;"),
                Form(
                    pip.wrap_with_inline_button(
                        Input(
                            placeholder="Existing or new 🗝 here (Enter for auto)", name="pipeline_id",
                            list="pipeline-ids", type="search", required=False, autofocus=True,
                            value=default_value, _onfocus="this.setSelectionRange(this.value.length, this.value.length)",
                            cls="contrast"
                        ),
                        button_label=f"Enter 🔑", button_class="secondary"
                    ),
                    pip.update_datalist("pipeline-ids", options=datalist_options if datalist_options else None),
                    hx_post=f"/{app_name}/init", hx_target=f"#{app_name}-container"
                )
            ),
            Div(id=f"{app_name}-container")
        )
    async def init(self, request):
        """Handles the key submission, initializes state, and renders the step UI placeholders.
        
        CRITICAL: This method starts the chain reaction by triggering the first step.
        DO NOT modify the structure that adds the first step with hx_trigger="load".
        """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        form = await request.form()
        user_input = form.get("pipeline_id", "").strip()
        if not user_input:
            from starlette.responses import Response
            response = Response("")
            response.headers["HX-Refresh"] = "true"
            return response
        context = pip.get_plugin_context(self)
        profile_name = context['profile_name'] or "default"
        plugin_name = context['plugin_name'] or app_name
        profile_part = profile_name.replace(" ", "_")
        plugin_part = plugin_name.replace(" ", "_")
        expected_prefix = f"{profile_part}-{plugin_part}-"
        if user_input.startswith(expected_prefix):
            pipeline_id = user_input
        else:
            _, prefix, user_provided_id = pip.generate_pipeline_key(self, user_input)
            pipeline_id = f"{prefix}{user_provided_id}"
        db["pipeline_id"] = pipeline_id
        state, error = pip.initialize_if_missing(pipeline_id, {"app_name": app_name})
        if error: return error
        
        await self.message_queue.add(pip, f"Workflow ID: {pipeline_id}", verbatim=True, spaces_before=0)
        await self.message_queue.add(pip, f"Return later by selecting '{pipeline_id}' from the dropdown.", verbatim=True, spaces_before=0)
        
        # CRITICAL: Start the chain reaction with step_01
        # This sets up the first div with hx_trigger="load" to kick off the chain
        # All subsequent steps will be triggered in sequence by the completion of the previous step
        return Div(
            Div(id="step_01", hx_get=f"/{app_name}/step_01", hx_trigger="load"),
            id=f"{app_name}-container"
        )
    async def finalize(self, request):
        """Handles GET request to show Finalize button and POST request to lock the workflow.
        
        CRITICAL: This method MUST:
        1. Check if all steps are complete and show the finalize button if so
        2. Process finalization by locking the workflow
        3. Handle the finalized state display
        
        DO NOT modify this method's structure when extending a workflow.
        """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        pipeline_id = db.get("pipeline_id", "unknown")
        finalize_step = steps[-1]
        finalize_data = pip.get_step_data(pipeline_id, finalize_step.id, {})
        if request.method == "GET":
            if finalize_step.done in finalize_data:
                return Card(
                    H3("Workflow is locked."),
                    Form(
                        Button(pip.UNLOCK_BUTTON_LABEL, type="submit", cls="secondary outline"),
                        hx_post=f"/{app_name}/unfinalize", 
                        hx_target=f"#{app_name}-container"
                    ),
                    id=finalize_step.id
                )
            else:
                all_steps_complete = all(
                    pip.get_step_data(pipeline_id, step.id, {}).get(step.done) 
                    for step in steps[:-1]
                )
                if all_steps_complete:
                    return Card(
                        H3("All steps complete. Finalize?"),
                        P("You can revert to any step and make changes.", style="font-size: 0.9em; color: #666;"),
                        Form(
                            Button("Finalize", type="submit", cls="primary"),
                            hx_post=f"/{app_name}/finalize", 
                            hx_target=f"#{app_name}-container"
                        ),
                        id=finalize_step.id
                    )
                else:
                    return Div(id=finalize_step.id)
        else:
            await pip.finalize_workflow(pipeline_id)
            await self.message_queue.add(pip, self.step_messages["finalize"]["complete"], verbatim=True)
            return pip.rebuild(app_name, steps)
    async def unfinalize(self, request):
        """Handles POST request to unlock the workflow."""
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        pipeline_id = db.get("pipeline_id", "unknown")
        await pip.unfinalize_workflow(pipeline_id)
        await self.message_queue.add(pip, "Workflow unfinalized! You can now revert to any step and make changes.", verbatim=True)
        return pip.rebuild(app_name, steps)
    async def jump_to_step(self, request):
        """Handles POST request from breadcrumb navigation to jump to a specific step."""
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        form = await request.form()
        step_id = form.get("step_id")
        db["step_id"] = step_id
        return pip.rebuild(app_name, steps)
    async def get_suggestion(self, step_id, state):
        """Gets a suggested input value for a step, often using the previous step's transformed output."""
        pip, db, steps = self.pipulate, self.db, self.steps
        step = next((s for s in steps if s.id == step_id), None)
        if not step or not step.transform: return ""
        prev_index = self.steps_indices[step_id] - 1
        if prev_index < 0: return ""
        prev_step = steps[prev_index]
        prev_data = pip.get_step_data(db["pipeline_id"], prev_step.id, {})
        prev_value = prev_data.get(prev_step.done, "")
        return step.transform(prev_value) if prev_value else ""
    async def handle_revert(self, request):
        """Handles POST request to revert to a previous step, clearing subsequent step data."""
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        form = await request.form()
        step_id = form.get("step_id")
        pipeline_id = db.get("pipeline_id", "unknown")
        if not step_id: return P("Error: No step specified", style=self.pipulate.get_style("error"))
        # This is the key operation for forward-only flow:
        # Clear all state data from the reverted step forward
        await pip.clear_steps_from(pipeline_id, step_id, steps)
        
        # Mark the current step as the revert target
        state = pip.read_state(pipeline_id)
        state["_revert_target"] = step_id
        pip.write_state(pipeline_id, state)
        # Add user message about the revert
        message = await pip.get_state_message(pipeline_id, steps, self.step_messages)
        await self.message_queue.add(pip, message, verbatim=True)
        await self.message_queue.add(pip, f"Reverted to {step_id}. All subsequent data has been cleared.", verbatim=True)
        
        # Rebuild the UI to start from the reverted step
        return pip.rebuild(app_name, steps)
    # --- Step 1 Methods ---
    async def step_01(self, request):
        """Handles GET request for Step 1.
        
        STEP PATTERN: Each step_XX method follows this pattern:
        1. Check if workflow is finalized -> Show locked state
        2. Check if step is complete -> Show completion with trigger to next step
        3. Otherwise -> Show input form
        
        CRITICAL: When step is complete, return a div that EXPLICITLY triggers the next step 
        with <Div id="next_step_id" hx_get="/app_name/next_step_id" hx_trigger="load">
        """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        step_id = "step_01"
        step_index = self.steps_indices[step_id]
        step = steps[step_index]
        next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'
        pipeline_id = db.get("pipeline_id", "unknown")
        state = pip.read_state(pipeline_id)
        step_data = pip.get_step_data(pipeline_id, step_id, {})
        placeholder_value = step_data.get(step.done, "")
        # Check if workflow is finalized
        finalize_data = pip.get_step_data(pipeline_id, "finalize", {})
        if "finalized" in finalize_data and placeholder_value:
            # Show a simple confirmation in finalized state
            # CRITICAL: Include trigger to next step even in finalized state
            return Div(
                Card(
                    H3(f"🔒 {step.show}: Completed")
                ),
                # CRITICAL: This explicit next step trigger ensures the chain reaction continues
                Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
                id=step_id
            )
            
        # Check if step is complete and not being reverted to
        if placeholder_value and state.get("_revert_target") != step_id:
            # Show completion message with revert control
            # CRITICAL: Include trigger to next step in completed state
            return Div(
                pip.revert_control(step_id=step_id, app_name=app_name, message=f"{step.show}: Complete", steps=steps),
                # CRITICAL: This explicit next step trigger ensures the chain reaction continues
                Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
                id=step_id
            )
        else:
            # Show input form
            await self.message_queue.add(pip, self.step_messages[step_id]["input"], verbatim=True)
            
            return Div(
                Card(
                    H3(f"{step.show}"),
                    P("This is a placeholder step. Click Proceed to continue to the next step."),
                    Form(
                        Button("Proceed", type="submit", cls="primary"),
                        # CRITICAL: Form must target the current step_id to ensure proper replacement
                        hx_post=f"/{app_name}/{step_id}_submit", 
                        hx_target=f"#{step_id}"
                    )
                ),
                # Empty next step placeholder - DO NOT add hx_trigger here!
                # The next step will be triggered after form submission
                Div(id=next_step_id),
                id=step_id
            )
    async def step_01_submit(self, request):
        """Process the submission for Step 1.
        
        STEP PATTERN: Each step_XX_submit method follows this pattern:
        1. Process and validate form data
        2. Store state data with pip.update_step_state()
        3. Return completion view WITH explicit trigger to next step
        
        CRITICAL: The return MUST include:
        1. A Div with id="step_id" (preserve the original ID)
        2. A Div that explicitly triggers the next step with hx_trigger="load"
        """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        step_id = "step_01"
        step_index = self.steps_indices[step_id]
        step = steps[step_index]
        next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'
        pipeline_id = db.get("pipeline_id", "unknown")
        # For placeholder, we use a fixed value instead of form data
        placeholder_value = "completed"
        # Store state data
        await pip.update_step_state(pipeline_id, step_id, placeholder_value, steps)
        await self.message_queue.add(pip, f"{step.show} complete.", verbatim=True)
        
        # CRITICAL: Return the revert control WITH explicit trigger to next step
        # This pattern MUST be followed to ensure proper workflow progression
        return Div(
            pip.revert_control(step_id=step_id, app_name=app_name, message=f"{step.show}: Complete", steps=steps),
            # CRITICAL: This explicit trigger activates the next step!
            Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
            id=step_id  # CRITICAL: Keep the original ID to ensure proper replacement
        )
        
    # --- Step 2 Methods ---
    # When adding new steps, copy this pattern for each step
    # Use consistent naming: step_XX and step_XX_submit
    
    async def step_02(self, request):
        """Handles GET request for Step 2.
        
        COPY THIS PATTERN: When adding new steps, follow this exact structure to maintain
        the chain reaction. The critical elements are:
        
        1. Computing the proper next_step_id
        2. Including the trigger to next step in completed states
        3. Maintaining the step_id on the outer div
        """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        step_id = "step_02"
        step_index = self.steps_indices[step_id]
        step = steps[step_index]
        # CRITICAL: Compute the next step ID - points to finalize if this is the last step
        next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'
        pipeline_id = db.get("pipeline_id", "unknown")
        state = pip.read_state(pipeline_id)
        step_data = pip.get_step_data(pipeline_id, step_id, {})
        placeholder_value = step_data.get(step.done, "")
        # Check if workflow is finalized
        finalize_data = pip.get_step_data(pipeline_id, "finalize", {})
        if "finalized" in finalize_data and placeholder_value:
            return Div(
                Card(
                    H3(f"🔒 {step.show}: Completed")
                ),
                # CRITICAL: Include trigger to next step even in finalized state
                Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
                id=step_id
            )
            
        # Check if step is complete and not being reverted to
        if placeholder_value and state.get("_revert_target") != step_id:
            return Div(
                pip.revert_control(step_id=step_id, app_name=app_name, message=f"{step.show}: Complete", steps=steps),
                # CRITICAL: Include trigger to next step in completed state
                Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
                id=step_id
            )
        else:
            await self.message_queue.add(pip, self.step_messages[step_id]["input"], verbatim=True)
            
            return Div(
                Card(
                    H3(f"{step.show}"),
                    P("This is a placeholder step. Click Proceed to continue to the next step."),
                    Form(
                        Button("Proceed", type="submit", cls="primary"),
                        hx_post=f"/{app_name}/{step_id}_submit", 
                        hx_target=f"#{step_id}"
                    )
                ),
                # Empty placeholder - without trigger
                Div(id=next_step_id),
                id=step_id
            )
    async def step_02_submit(self, request):
        """Process the submission for Step 2.
        
        COPY THIS PATTERN: When adding steps, follow this same structure with:
        1. Correct step_id and next_step_id calculation
        2. Data processing appropriate to the step
        3. Explicit trigger to the next step
        """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        step_id = "step_02"
        step_index = self.steps_indices[step_id]
        step = steps[step_index]
        # CRITICAL: Compute the next step ID - points to finalize if this is the last step
        next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'
        pipeline_id = db.get("pipeline_id", "unknown")
        # Process form data - customize as needed for your step
        placeholder_value = "completed"
        # Store state data
        await pip.update_step_state(pipeline_id, step_id, placeholder_value, steps)
        await self.message_queue.add(pip, f"{step.show} complete.", verbatim=True)
        
        # CRITICAL: Return completion view WITH explicit trigger to next step
        return Div(
            pip.revert_control(step_id=step_id, app_name=app_name, message=f"{step.show}: Complete", steps=steps),
            # CRITICAL: This explicit trigger activates the next step!
            Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
            id=step_id
        )
        
    # --- Step 3 Methods ---
    # This demonstrates adding a third step using the same pattern
    
    async def step_03(self, request):
        """Handles GET request for Step 3.
        
        SPLICING GUIDE: This shows how to add a third step following the exact same pattern.
        
        CRITICAL PATTERN:
        1. Each step computes the correct next_step_id (or 'finalize' if last step)
        2. Completed steps explicitly trigger the next step with hx_trigger="load"
        3. Input forms target the current step's container for proper replacement
        """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        step_id = "step_03"
        step_index = self.steps_indices[step_id]
        step = steps[step_index]
        # For the last regular step, next_step_id will be 'finalize'
        next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'
        pipeline_id = db.get("pipeline_id", "unknown")
        state = pip.read_state(pipeline_id)
        step_data = pip.get_step_data(pipeline_id, step_id, {})
        placeholder_value = step_data.get(step.done, "")
        # Check if workflow is finalized
        finalize_data = pip.get_step_data(pipeline_id, "finalize", {})
        if "finalized" in finalize_data and placeholder_value:
            return Div(
                Card(
                    H3(f"🔒 {step.show}: Completed")
                ),
                # Even the last step must trigger finalize when finalized
                Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
                id=step_id
            )
            
        # Check if step is complete and not being reverted to
        if placeholder_value and state.get("_revert_target") != step_id:
            return Div(
                pip.revert_control(step_id=step_id, app_name=app_name, message=f"{step.show}: Complete", steps=steps),
                # CRITICAL: Last step must trigger the finalize step
                Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
                id=step_id
            )
        else:
            await self.message_queue.add(pip, self.step_messages[step_id]["input"], verbatim=True)
            
            return Div(
                Card(
                    H3(f"{step.show}"),
                    P("This is a placeholder step. Click Proceed to continue to the next step."),
                    Form(
                        Button("Proceed", type="submit", cls="primary"),
                        hx_post=f"/{app_name}/{step_id}_submit", 
                        hx_target=f"#{step_id}"
                    )
                ),
                # Empty placeholder without trigger
                Div(id=next_step_id),
                id=step_id
            )
    async def step_03_submit(self, request):
        """Process the submission for Step 3.
        
        TRANSITION TO FINALIZE:
        This step demonstrates the transition to the finalize step.
        The pattern is identical - the last step triggers finalize just like
        any other step would trigger the next step in sequence.
        """
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        step_id = "step_03"
        step_index = self.steps_indices[step_id]
        step = steps[step_index]
        # CRITICAL: For the last step, next_step_id will be 'finalize'
        next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'
        pipeline_id = db.get("pipeline_id", "unknown")
        # Process form data - customize as needed for your step
        placeholder_value = "completed"
        # Store state data
        await pip.update_step_state(pipeline_id, step_id, placeholder_value, steps)
        await self.message_queue.add(pip, f"{step.show} complete.", verbatim=True)
        
        # CRITICAL: The last step must trigger the finalize step
        # The pattern is identical to any other step transition
        return Div(
            pip.revert_control(step_id=step_id, app_name=app_name, message=f"{step.show}: Complete", steps=steps),
            # CRITICAL: This triggers the finalize step!
            Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
            id=step_id
        )
# File token count: 6,185 tokens
# <<< END FILE: /home/mike/repos/pipulate/plugins/80_splice_workflow.py >>>
# <<< START FILE: /home/mike/repos/.cursor/rules/htmx-chain-reactions.mdc >>>
---
description: 
globs: 
alwaysApply: false
---
# chain-reaction-pattern
## Overview
The chain reaction pattern is the core mechanism for step progression in Pipulate workflows. It enables automatic advancement through workflow steps without requiring manual user intervention for each transition.
## CRITICAL Implementation Pattern - DO NOT MODIFY
```python
return Div(
    Card(...),  # Current step content
    Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),  # Next step loader
    id=step_id
)
```
## Why This Pattern Is Required
- The inner `Div` with `id=next_step_id` serves as a container for the next step
- The `hx_get` attribute requests the next step from the server
- **IMPORTANT**: The `hx_trigger="load"` makes this happen automatically when current step renders
- Removing `hx_trigger="load"` breaks the auto-progression functionality 
- Alternative approaches using event bubbling are NOT reliable in this application
## Key Elements
- The inner `Div` with `id=next_step_id` serves as a container for the next step
- The `hx_get` attribute requests the next step from the server
- `hx_trigger="load"` makes this happen automatically when current step renders
- The outer `Div` with `id=step_id` is replaced when the current step completes
## Breaking the Chain (Cautionary Pattern)
The `no-chain-reaction` class should only be used in two specific scenarios:
1. **Terminal responses** - For endpoints requiring explicit user action:
```python
return Div(
    result_card,
    download_button,
    cls="terminal-response no-chain-reaction",
    id=step_id
)
```
2. **Polling states** - For continuous status checking without progression:
```python
return Div(
    result_card,
    progress_indicator,
    cls="polling-status no-chain-reaction",
    hx_get=f"/{app_name}/check_status",
    hx_trigger="load, every 2s",
    hx_target=f"#{step_id}",
    id=step_id
)
```
## Best Practices
- Always maintain the chain reaction pattern unless absolutely necessary
- When breaking the chain, provide clear UI indicators of what's happening
- Resume the chain reaction as soon as the exceptional condition is complete
- Document any use of `no-chain-reaction` with explicit comments explaining why
## Example in Botify Export
See [50_botify_export.py](mdc:pipulate/plugins/50_botify_export.py) lines 1515-1540 for implementation examples of both patterns.
# File token count: 552 tokens
# <<< END FILE: /home/mike/repos/.cursor/rules/htmx-chain-reactions.mdc >>>
# <<< START FILE: /home/mike/repos/.cursor/rules/nix-rules.mdc >>>
---
description: 
globs: 
alwaysApply: true
---
# NixOS Configuration Access Rules (Updated)
## Source Location
- PRIMARY: /home/mike/repos/pipulate/*
- All edits should target the repo location directly
## Environment Setup
- For interactive use (human): Run `nix develop` or `nix develop .#default` from /home/mike/repos/pipulate
- For AI assistants and debugging: Use `nix develop .#quiet` to avoid verbose output
- Never "Run the Server" to check things. It's on Watchdog. It'll run itself.
- Standard command pattern:
  ```bash
  cd ~/repos/pipulate && pkill -f "python server.py" || true && nix develop .#quiet --command <your_command>
  ```
- For monitoring specific output:
  ```bash
  cd ~/repos/pipulate && pkill -f "python server.py" || true && nix develop .#quiet --command bash -c "python server.py 2>&1 | grep -A 5 -B 5 'search_term'"
  ```
- Work exclusively in ~/repos/pipulate
- Use relative paths from repo root
## Data Libraries and Visualization
- Pandas and data visualization libraries are included in the Nix environment
- Test pandas availability in the environment:
  ```bash
  cd ~/repos/pipulate && nix develop .#quiet --command python -c "import pandas; print(pandas.__version__)"
  ```
- For CSV processing issues, verify pandas installation:
  ```bash
  cd ~/repos/pipulate && nix develop .#quiet --command python -c "import pandas as pd; print(pd.read_csv('path/to/test.csv', nrows=5))"
  ```
- When implementing table widgets, ensure HTML generation is properly escaped for FastHTML:
  ```bash
  cd ~/repos/pipulate && nix develop .#quiet --command python -c "import pandas as pd; from fasthtml.components import HTML; print(repr(HTML(pd.DataFrame({'A': [1,2]}).to_html()).to_xml()))"
  ```
- Always specify `nrows` parameter when reading large CSV files to prevent performance issues
## Process Management
- Always include `pkill -f "command_pattern" || true` before starting long-running processes
- This prevents multiple instances of the same process from running simultaneously
- Use `ps aux | grep python` to check for orphaned processes
## Output Interpretation
- The `.#quiet` shell only displays "Quiet Nix environment activated." before your command output
- This provides maximum visibility for important command output within the AI's limited window
## System Updates
- Save changes in repo location
- Run system rebuilds in external terminal
- Let symlinks handle system-level access
## Nix Environment Detection Guide
### Quick Detection Methods
- Look for environment variables: `IN_NIX_SHELL`, `NIX_BUILD_TOP`, `NIX_STORE`
- Check PATH for `/nix/store` entries
- Look for `.#` format in prompt indicating flake-based environment
- Check for `/nix` directory existence
### Terminal Indicators
- PS1 prompt often shows `[nix-shell]` or `[dev]` prefix
- Command `echo $IN_NIX_SHELL` returns `1` in nix-shell
- Running `type nix` shows it's available
### Usage Context
- Python environment paths in `/nix/store/` rather than system paths
- Package availability differs from base system
### Best Practice
- When requesting system changes, first check if in proper Nix environment
- Always prefer running tools via `nix develop .#quiet --command` when performing debugging or analysis
- Use relative paths within the repository structure
## Troubleshooting
- If a command fails, try running with full output:
  ```bash
  cd ~/repos/pipulate && nix develop .#quiet --command <command> 2>&1 | head -50
  ```
- For Python package issues:
  ```bash
  cd ~/repos/pipulate && nix develop .#quiet --command python -c "import importlib.util; print('Module exists:' if importlib.util.find_spec('module_name') else 'Module missing:')"
  ```
- To check server startup specifically:
  ```bash
  cd ~/repos/pipulate && pkill -f "python server.py" || true && nix develop .#quiet --command python server.py 2>&1 | head -30
  ```
# File token count: 964 tokens
# <<< END FILE: /home/mike/repos/.cursor/rules/nix-rules.mdc >>>
# <<< START FILE: /home/mike/repos/.cursor/rules/placeholder-step-pattern.mdc >>>
---
description: 
globs: 
alwaysApply: false
---
# placeholder-step-pattern
## Overview
Placeholder steps are skeletal workflow steps that serve as preparation points for inserting fully-functional steps later. They maintain the standard workflow progression pattern while collecting minimal or no user data.
## When to Use Placeholder Steps
- When planning a workflow's structure before implementing detailed functionality
- When creating a step that will be replaced with more complex widgets later
- When needing a "confirmation" or "review" step between functional steps
- When creating a template for different widget types
## Implementation Pattern
To add a placeholder step to an existing workflow:
### 1. Add the Step Definition
```python
Step(
    id='step_XX',            # Use proper sequential numbering
    done='placeholder',      # Simple state field name
    show='Placeholder Step', # Descriptive UI text
    refill=True,             # Usually True for consistency
),
```
### 2. Create the GET Handler Method
```python
async def step_XX(self, request):
    """Handles GET request for placeholder step."""
    pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
    step_id = "step_XX"
    step_index = self.steps_indices[step_id]
    step = steps[step_index]
    next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'
    pipeline_id = db.get("pipeline_id", "unknown")
    state = pip.read_state(pipeline_id)
    
    # Simple form with just a proceed button
    return Div(
        Card(
            H4(f"{step.show}"),
            P("Click Proceed to continue to the next step."),
            Form(
                Button("Proceed", type="submit", cls="primary"),
                Button("Revert", type="button", cls="secondary",
                       hx_post=f"/{app_name}/handle_revert",
                       hx_vals=f'{{"step_id": "{step_id}"}}'),
                hx_post=f"/{app_name}/{step_id}_submit",
            ),
        ),
        # CRITICAL: Chain reaction to next step - DO NOT MODIFY OR REMOVE
        Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
        id=step_id
    )
```
### 3. Create the POST Handler Method
```python
async def step_XX_submit(self, request):
    """Process the submission for placeholder step."""
    pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
    step_id = "step_XX"
    step_index = self.steps_indices[step_id]
    step = steps[step_index]
    pipeline_id = db.get("pipeline_id", "unknown")
    next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'
    # Store minimal state data
    placeholder_value = "completed"
    state = pip.read_state(pipeline_id)
    state[step.done] = placeholder_value
    pip.write_state(pipeline_id, state)
    
    # Confirm completion and configure next step display
    await pip.update_step_state(pipeline_id, step_id, placeholder_value, steps)
    await self.message_queue.add(pip, f"{step.show} complete.", verbatim=True)
    
    # Return response with chain reaction to next step
    response = Div(
        Card(
            H4(f"{step.show} Complete"),
            P("Proceeding to next step..."),
        ),
        # CRITICAL: Chain reaction to next step - DO NOT MODIFY OR REMOVE
        Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
        id=step_id
    )
    return response
```
### 4. Add Suggestion for Step (Optional)
In the `get_suggestion` method, add a simple text for the placeholder:
```python
'step_XX': """Placeholder step - no user content needed.
This step serves as a placeholder for future functionality."""
```
## Critical Elements to Preserve
1. **Chain Reaction Pattern**: 
   ```python
   # CRITICAL - DO NOT MODIFY OR REMOVE
   Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load")
   ```
   - The `id=next_step_id` identifies the container for the next step
   - The `hx_get` attribute loads the next step's content
   - The `hx_trigger="load"` attribute is REQUIRED for automatic progression
   - NEVER remove `hx_trigger="load"` even if you think event bubbling would work
   - This explicit triggering pattern is the standard throughout the codebase
2. **Revert Button**: Always include for consistent user experience
3. **Step Numbering**: Maintain proper sequential numbering
4. **State Management**: Always store state even if minimal
5. **Message Queue Updates**: Always notify of step completion
## Common Implementation Pitfalls
- **SERIOUS ERROR**: Removing `hx_trigger="load"` from the chain reaction div will break progression
- **SERIOUS ERROR**: Using an empty div without the required attributes
- **SERIOUS ERROR**: Using event bubbling or implicit triggering instead of explicit triggers
- Using incorrect next_step_id calculation (especially for the last step)
- Forgetting to update steps_indices after adding new steps
- Not preserving the chain reaction pattern in both GET and POST handlers
## Placement Considerations
- **First Step**: If replacing the first step, ensure proper initialization
- **Middle Step**: Ensure proper next_step_id and previous step chain reaction
- **Last Step**: Properly handle transition to 'finalize' instead of next_step_id
## Example
See [60_widget_examples.py](mdc:pipulate/plugins/60_widget_examples.py) step_07 for a complete placeholder implementation.
## Upgrading Later
When ready to replace the placeholder with functional content:
1. Keep the same step_id and step definition
2. Add necessary form elements to collect data
3. Enhance the submit handler to process the collected data
4. Preserve the chain reaction pattern and revert functionality
# File token count: 1,311 tokens
# <<< END FILE: /home/mike/repos/.cursor/rules/placeholder-step-pattern.mdc >>>
# <<< START FILE: /home/mike/repos/.cursor/rules/wet-workflows.mdc >>>
---
description: When working in the Pipulate repo
globs: 
alwaysApply: false
---
# Pipulate Workflow Development Guide
## Core Structure
Every workflow must follow this basic structure:
```python
class WorkflowName:
    APP_NAME = "unique_name"        # Unique identifier
    DISPLAY_NAME = "User Name"      # UI display name
    ENDPOINT_MESSAGE = "..."        # User guidance
    TRAINING_PROMPT = "name.md"     # Training file
    PRESERVE_REFILL = True/False    # State preservation
```
## Required Files
- Main workflow file in `pipulate/plugins/` with format `XX_name.py`
- Training prompt file referenced in `TRAINING_PROMPT`
- Plugin numbering indicates load order and dependencies
## Step Definition
Steps use the namedtuple pattern:
```python
Step = namedtuple('Step', ['id', 'done', 'show', 'refill', 'transform'])
steps = [
    Step(
        id='step_01',           # Format: step_XX
        done='field_name',      # State field name
        show='Display Name',    # UI display text
        refill=True/False,      # Preserve on revert
        transform=lambda x: x   # Optional transform
    )
]
```
## Required Methods
Every workflow must implement:
1. `__init__`: Setup routes and steps
2. `landing`: Initial page display
3. `init`: Workflow initialization
4. `finalize/unfinalize`: State management
5. `handle_revert`: Step reversal
6. Per-step handlers: `step_XX` and `step_XX_submit`
## UI Components
- Use FastHTML components consistently
- Follow HTMX patterns for dynamic updates
- Maintain chain reaction pattern (NEVER remove `hx_trigger="load"`)
- Example structure:
```python
return Div(
    Card(
        H4(f"{pip.fmt(step_id)}: {title}"),
        Form(...),
    ),
    Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
    id=step_id
)
```
## Step Progression Pattern
The standard step progression pattern has these key elements:
1. **GET Handler Pattern**:
```python
async def step_XX(self, request):
    """Handles GET request for Step XX."""
    pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
    step_id = "step_XX"
    step_index = self.steps_indices[step_id]
    step = steps[step_index]
    next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'
    pipeline_id = db.get("pipeline_id", "unknown")
    state = pip.read_state(pipeline_id)
    step_data = pip.get_step_data(pipeline_id, step_id, {})
    
    # Form with required fields and revert button
    return Div(
        Card(...),
        Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
        id=step_id
    )
```
2. **POST Handler Pattern**:
```python
async def step_XX_submit(self, request):
    """Process the submission for Step XX."""
    pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
    step_id = "step_XX"
    step_index = self.steps_indices[step_id]
    step = steps[step_index]
    pipeline_id = db.get("pipeline_id", "unknown")
    next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'
    
    # Process form data
    form = await request.form()
    value = form.get("field_name", "")
    
    # Validate
    if not value:
        return P("Error: Field is required", style=pip.get_style("error"))
    
    # Store in state
    state = pip.read_state(pipeline_id)
    state[step.done] = value
    pip.write_state(pipeline_id, state)
    
    # Update progress and message
    await pip.update_step_state(pipeline_id, step_id, value, steps)
    await self.message_queue.add(pip, f"{step.show} complete: {value}", verbatim=True)
    
    # Return response with chain reaction
    return Div(
        Card(...),
        Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
        id=step_id
    )
```
## Adding or Inserting Steps
To add a new step or insert one between existing steps:
1. **Add to the steps list** in the correct position
2. **Update step indices** in the steps_indices dictionary in __init__
3. **Create both handler methods** following the patterns above
4. **Verify chain reactions** in surrounding steps
5. **Add suggestion text** in the get_suggestion method
For placeholder steps, see the [placeholder-step-pattern](mdc:.cursor/rules/placeholder-step-pattern.mdc) rule.
## State Management
- Use Pipulate helpers for state:
  - `pip.read_state(pipeline_id)`
  - `pip.get_step_data(pipeline_id, step_id, {})`
  - `pip.update_step_state(pipeline_id, step_id, val, steps)`
- Handle finalization properly
- Clear state appropriately on revert
## Message Queue Usage
- Use ordered message delivery:
```python
await self.message_queue.add(
    pip,
    message,
    verbatim=True,
    spaces_before=0,
    spaces_after=1
)
```
## Error Handling
- Validate all inputs
- Use consistent error presentation
- Provide clear user feedback
- Handle edge cases gracefully
- Example:
```python
try:
    # Operation
except Exception as e:
    return P(f"Error: {str(e)}", style=pip.get_style("error"))
```
## Advanced Features
- Use transform functions for step data flow
- Implement custom state preservation
- Use advanced revert controls when needed
- Track progress for long operations
- Handle file operations safely
## Documentation
- Provide clear docstrings
- Document step dependencies
- Explain state management
- Detail UI/UX considerations
- Document error handling
## Testing Considerations
- Test step progression
- Verify state management
- Check revert functionality
- Validate error handling
- Test chain reactions
## Special Cases and Edge Case Handling
1. **Terminal steps** may break the chain reaction pattern
2. **Polling operations** require special HTMX handling
3. **File downloads** use no-chain-reaction with manual continuation
4. **Error recoveries** should guide users on how to proceed
Remember: Workflows are intentionally WET (Write Everything Twice) to allow maximum customization while maintaining consistent patterns.
Reference Examples:
- [10_connect_with_botify.py](mdc:pipulate/plugins/10_connect_with_botify.py): Simple authentication workflow
- [20_hello_workflow.py](mdc:pipulate/plugins/20_hello_workflow.py): Basic workflow template
- [50_botify_export.py](mdc:pipulate/plugins/50_botify_export.py): Complex multi-step workflow
- [60_widget_examples.py](mdc:pipulate/plugins/60_widget_examples.py): Visualizing data in workflow
# Workflow Architecture in Pipulate
## Dual-Identity Pattern: Filename vs APP_NAME
Pipulate workflows maintain two separate identities:
### 1. Filename-based Endpoint Identity
- **Source**: The Python filename (minus numeric prefix and .py extension)
- **Example**: `110_parameter_buster_workflow.py` → `/parameter_buster_workflow` endpoint
- **Purpose**: Determines the URL path users will access in the browser
- **Navigation**: Controls what appears in the UI navigation menu
- **Flexibility**: Can be changed to improve user-facing URLs without breaking stored data
### 2. APP_NAME-based Storage Identity
- **Source**: The `APP_NAME` constant in the workflow class
- **Example**: `APP_NAME = "parameter_buster"` → Database keys use "parameter_buster"
- **Purpose**: Used for database keys and internal state management
- **Data Integrity**: Maintains connection to existing records in the database
- **Consistency**: Must remain stable to avoid orphaning existing workflow data
### Best Practices
- **Make Them Different**: Using different values for filename and APP_NAME (like `110_parameter_buster_workflow.py` with `APP_NAME = "parameter_buster"`) provides maximum flexibility
- **Descriptive Filenames**: Use more descriptive filenames for better URL clarity
- **Simple APP_NAMEs**: Keep APP_NAMEs shorter and simpler for cleaner database keys
- **Version Transitions**: When creating a major revision, you can create a new file (e.g., `parameter_buster_v2_workflow.py`) while keeping the same APP_NAME to preserve all existing data
### Examples
- Improving a URL without breaking data:
  ```python
  # Old: 110_pb.py
  class ParameterBusterWorkflow:
      APP_NAME = "parameter_buster"
      # ...
  
  # New: 110_parameter_buster_workflow.py (better URL)
  class ParameterBusterWorkflow:
      APP_NAME = "parameter_buster"  # Same APP_NAME preserves data
      # ...
  ```
- Creating multiple entry points to the same workflow data:
  ```python
  # 110_parameter_buster_workflow.py (primary endpoint)
  class ParameterBusterWorkflow:
      APP_NAME = "parameter_buster"
      # ...
  
  # 120_parameter_buster_quick.py (alternative entry point)
  class QuickParameterBusterWorkflow:
      APP_NAME = "parameter_buster"  # Same data, different UI
      # ...
  ```
### Technical Implementation
This separation works because:
1. The server discovers plugin files and creates navigation entries based on filenames
2. Each workflow class registers its own routes using its APP_NAME
3. All database operations are performed using the APP_NAME, not the filename
This architecture allows developers to improve and evolve the user interface and URL structures without disrupting existing workflows or losing user data.
# File token count: 2,155 tokens
# <<< END FILE: /home/mike/repos/.cursor/rules/wet-workflows.mdc >>>
# <<< START FILE: /home/mike/repos/pipulate/training/workflow_implementation_guide.md >>>
# Guide and Primer On Pipulate Workflow Patterns
This serves as a comprehensive guide and primer on the fundamental patterns used for building
and modifying workflows within the Pipulate framework, particularly focusing on
step insertion and maintaining the crucial HTMX chain reaction mechanism. It
doesn't introduce new requirements *for* the codebase but rather documents *how*
the codebase works and how developers (or AI assistants) should interact with it
when adding or modifying workflow steps.
# PIPULATE WORKFLOW PROGRESSION GUIDE
## 1. EMPTY WORKFLOW (LANDING → FINALIZE)
┌─────────────┐                  ┌───────────┐
│   landing   │                  │  finalize │
│  (method)   │ ---------------> │  (method) │
└─────────────┘                  └───────────┘
Key Code Connection:
```python
# In landing method return statement
return Div(
    Card(...),
    # Chain reaction initiator - NEVER REMOVE OR MODIFY THIS PATTERN
    Div(id="finalize", hx_get=f"/{app_name}/finalize", hx_trigger="load"),
    id="landing"
)
```
## 2. INSERTING STEP_01 (LANDING → STEP_01 → FINALIZE)
┌─────────────┐        ┌──────────────┐        ┌───────────┐
│   landing   │        │    step_01   │        │  finalize │
│  (method)   │ -----> │ (placeholder)│ -----> │  (method) │
└─────────────┘        └──────────────┘        └───────────┘
Changes Required:
1. Add step_01 to steps list in __init__
2. Create step_01 and step_01_submit methods
3. Modify landing chain reaction to point to step_01
```python
# Updated landing return statement 
return Div(
    Card(...),
    # Chain reaction now points to step_01 - CRITICAL PATTERN, DO NOT MODIFY
    Div(id="step_01", hx_get=f"/{app_name}/step_01", hx_trigger="load"),
    id="landing"
)
# step_01 method 
return Div(
    Card(...),
    # Chain reaction to finalize - CRITICAL PATTERN, DO NOT MODIFY
    Div(id="finalize", hx_get=f"/{app_name}/finalize", hx_trigger="load"),
    id="step_01"
)
```
## 3. ADDING STEP_02 (LANDING → STEP_01 → STEP_02 → FINALIZE)
┌─────────────┐        ┌──────────────┐        ┌──────────────┐        ┌───────────┐
│   landing   │        │    step_01   │        │    step_02   │        │  finalize │
│  (method)   │ -----> │ (placeholder)│ -----> │ (placeholder)│ -----> │  (method) │
└─────────────┘        └──────────────┘        └──────────────┘        └───────────┘
Changes Required:
1. Add step_02 to steps list in __init__
2. Create step_02 and step_02_submit methods
3. Modify step_01 chain reaction to point to step_02
```python
# Updated step_01 return statement
return Div(
    Card(...),
    # Chain reaction now points to step_02 - CRITICAL PATTERN, DO NOT MODIFY
    Div(id="step_02", hx_get=f"/{app_name}/step_02", hx_trigger="load"),
    id="step_01"
)
# step_02 method
return Div(
    Card(...),
    # Chain reaction to finalize - CRITICAL PATTERN, DO NOT MODIFY
    Div(id="finalize", hx_get=f"/{app_name}/finalize", hx_trigger="load"),
    id="step_02"
)
```
## 4. COMPLETE WORKFLOW WITH STEP_03 (LANDING → STEP_01 → STEP_02 → STEP_03 → FINALIZE)
┌─────────────┐        ┌──────────────┐        ┌──────────────┐        ┌──────────────┐        ┌───────────┐
│   landing   │        │    step_01   │        │    step_02   │        │    step_03   │        │  finalize │
│  (method)   │ -----> │ (placeholder)│ -----> │ (placeholder)│ -----> │ (placeholder)│ -----> │  (method) │
└─────────────┘        └──────────────┘        └──────────────┘        └──────────────┘        └───────────┘
Changes Required:
1. Add step_03 to steps list in __init__
2. Create step_03 and step_03_submit methods
3. Modify step_02 chain reaction to point to step_03
```python
# Updated step_02 return statement
return Div(
    Card(...),
    # Chain reaction now points to step_03 - CRITICAL PATTERN, DO NOT MODIFY
    Div(id="step_03", hx_get=f"/{app_name}/step_03", hx_trigger="load"),
    id="step_02"
)
# step_03 method
return Div(
    Card(...),
    # Chain reaction to finalize - CRITICAL PATTERN, DO NOT MODIFY
    Div(id="finalize", hx_get=f"/{app_name}/finalize", hx_trigger="load"),
    id="step_03"
)
```
## 5. DYNAMIC CHAIN REACTION (GENERALIZED PATTERN)
For any step_XX in a workflow:
┌──────────────┐        ┌──────────────┐        ┌──────────────┐
│   step_prev  │        │    step_XX   │        │   step_next  │
│   (method)   │ -----> │  (your step) │ -----> │   (method)   │
└──────────────┘        └──────────────┘        └──────────────┘
Key Pattern Code:
```python
# Determine the next step dynamically
next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'
# Return with proper chain reaction
return Div(
    Card(...),
    # Dynamic chain reaction - CRITICAL PATTERN, DO NOT MODIFY
    Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
    id=step_id
)
```
## 6. CRITICAL CHAIN REACTION ELEMENTS
┌───────────────────────────────────────────────────────────────────┐
│ CHAIN REACTION COMPONENT                                          │
├───────────────────────────────────────────────────────────────────┤
│ Div(id=next_step_id,                                              │
│     hx_get=f"/{app_name}/{next_step_id}",                         │
│     hx_trigger="load")                                            │
└───────────────────────────────────────────────────────────────────┘
   │
   │ Must preserve these three attributes
   ▼
┌───────────────────────────────────────────────────────────────────┐
│ id=next_step_id   : Container to be replaced with next step       │
│ hx_get=...        : URL to fetch next step content                │
│ hx_trigger="load" : Automatically triggers when this div appears  │
└───────────────────────────────────────────────────────────────────┘
## 7. STEP METHOD STRUCTURE AND CONNECTIONS
           ┌── Shared step_id = "step_XX"
           │
           │         ┌─ Common code pattern
           ▼         ▼
┌────────────────────────────────────────┐      ┌────────────────────────────────────────┐
│           step_XX (GET)                │      │          step_XX_submit (POST)         │
├────────────────────────────────────────┤      ├────────────────────────────────────────┤
│ 1. Get step metadata                   │      │ 1. Get step metadata                   │
│ 2. Get pipeline state                  │──┐   │ 2. Process form submission             │
│ 3. Display form with submit button     │  │   │ 3. Validate input                      │
│ 4. Include revert button               │  │   │ 4. Save state                          │
│ 5. Setup chain reaction to next step   │  │   │ 5. Update progress message             │
└────────────────────────────────────────┘  │   │ 6. Setup chain reaction to next step   │
                                            │   └────────────────────────────────────────┘
                                            │                      │
                                            │                      │
                                            ▼                      ▼
                               ┌────────────────────────────────────────────┐
                               │              hx_post                       │
                               │  Form(...                                  │
                               │    hx_post=f"/{app_name}/{step_id}_submit" │
                               │  )                                         │
                               └────────────────────────────────────────────┘

## 8. SPLICING IN NEW STEPS (BETWEEN STEP_01 AND STEP_02)
Before:
  step_01 → step_02
After:
  step_01 → new_step → step_02
Required Changes:
1. Add new_step to steps list between step_01 and step_02
2. Update step_indices in __init__
3. Create new_step and new_step_submit methods
4. Modify step_01's chain reaction to point to new_step
5. Set new_step's chain reaction to point to step_02

## 9. REFILL PARAMETER AND STATE FLOW BEHAVIOR
┌─────────────────────────────────────────────────────────────┐
│ REFILL=FALSE (Forward-Only Flow)                            │
├─────────────────────────────────────────────────────────────┤
│ 1. User completes steps: 01 → 02 → 03                       │
│ 2. User reverts to step_01                                  │
│ 3. Form shows with NO pre-filled values                     │
│ 4. Step_02 and step_03 data completely cleared              │
│ 5. Must fill each step again sequentially                   │
└─────────────────────────────────────────────────────────────┘
  vs.
┌─────────────────────────────────────────────────────────────┐
│ REFILL=TRUE (Iterative Flow)                                │
├─────────────────────────────────────────────────────────────┤
│ 1. User completes steps: 01 → 02 → 03                       │
│ 2. User reverts to step_01                                  │
│ 3. Form shows with PREVIOUS values pre-filled               │
│ 4. Step_02 and step_03 data still cleared                   │
│ 5. Previous inputs remembered but still must progress again │
└─────────────────────────────────────────────────────────────┘
For true "forward-only" workflows with strict dependencies between steps,
use `refill=False` to reinforce that reverting means starting over from that point.
## Important: The refill Parameter
- For strict forward-only workflows (where changing a previous step should completely invalidate
  subsequent steps), use `refill=False`
- For more flexible workflows where users might iterate and refine inputs, use `refill=True`
- This choice affects both the user experience and the conceptual integrity of the workflow
# CRITICAL PATTERN WARNING
When implementing workflows in Pipulate, one pattern is absolutely critical and must never be modified:
## The Chain Reaction Pattern
```python
# In step_XX or step_XX_submit return statement
return Div(
    Card(...), # Current step's content
    # CRITICAL: This inner Div triggers loading of the next step
    # DO NOT REMOVE OR MODIFY these attributes:
        Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
        id=step_id
    )
```
### Why This Pattern Is Essential
1. **Explicit Triggering**: The `hx_trigger="load"` attribute explicitly tells HTMX to load the next step immediately after this content is rendered
2. **Direct Initialization**: This approach eliminates race conditions and timing issues that may occur with event bubbling
3. **Reliable Implementation**: This pattern has been tested across the entire codebase and ensures consistent progression
4. **Documented Standard**: All workflow examples follow this pattern, and it should be considered immutable
### Dangerous Modifications to Avoid
- **DO NOT** remove `hx_trigger="load"` even if it seems redundant
- **DO NOT** attempt to replace explicit chain reaction with implicit event bubbling
- **DO NOT** implement alternative flow mechanisms without extensive testing
Such changes will appear to work in limited testing but will inevitably break more complex workflows.
### Breaking the Chain (Cautionary Pattern)
    The `no-chain-reaction` class should only be used in two specific scenarios:
    1. **Terminal responses** - For endpoints requiring explicit user action:
    ```python
    return Div(
        result_card,
        download_button,
        cls="terminal-response no-chain-reaction",
        id=step_id
    )
    ```
    2. **Polling states** - For continuous status checking without progression:
    ```python
    return Div(
        result_card,
        progress_indicator,
        cls="polling-status no-chain-reaction",
        hx_get=f"/{app_name}/check_status",
        hx_trigger="load, every 2s",
        hx_target=f"#{step_id}",
        id=step_id
    )
    ```
### Best Practices
    - Always maintain the chain reaction pattern unless absolutely necessary
    - When breaking the chain, provide clear UI indicators of what's happening
    - Resume the chain reaction as soon as the exceptional condition is complete
    - Document any use of `no-chain-reaction` with explicit comments explaining why
# PLACEHOLDER STEP PATTERN
## Overview
Placeholder steps are skeletal workflow steps that serve as preparation points for inserting fully-functional steps later. They maintain the standard workflow progression pattern while collecting minimal or no user data.
## When to Use Placeholder Steps
- When planning a workflow's structure before implementing detailed functionality
- When creating a step that will be replaced with more complex widgets later
- When needing a "confirmation" or "review" step between functional steps
- When creating a template for different widget types
## Implementation Pattern
To add a placeholder step to an existing workflow:
### 1. Add the Step Definition
    ```python
        Step(
    id='step_XX',            # Use proper sequential numbering
    done='placeholder',      # Simple state field name
    show='Placeholder Step', # Descriptive UI text
    refill=True,             # Usually True for consistency
),
```
### 2. Create the GET Handler Method
    ```python
    async def step_XX(self, request):
    """Handles GET request for placeholder step."""
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        step_id = "step_XX"
        step_index = self.steps_indices[step_id]
        step = steps[step_index]
        next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'
        pipeline_id = db.get("pipeline_id", "unknown")
        state = pip.read_state(pipeline_id)
        
    # Simple form with just a proceed button
        return Div(
        Card(
            H4(f"{step.show}"),
            P("Click Proceed to continue to the next step."),
            Form(
                Button("Proceed", type="submit", cls="primary"),
                Button("Revert", type="button", cls="secondary",
                       hx_post=f"/{app_name}/handle_revert",
                       hx_vals=f'{{"step_id": "{step_id}"}}'),
                hx_post=f"/{app_name}/{step_id}_submit",
            ),
        ),
        # CRITICAL: Chain reaction to next step - DO NOT MODIFY OR REMOVE
            Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
            id=step_id
        )
    ```
    2. **POST Handler Pattern**:
    ```python
    async def step_XX_submit(self, request):
        """Process the submission for Step XX."""
        pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
        step_id = "step_XX"
        step_index = self.steps_indices[step_id]
        step = steps[step_index]
        pipeline_id = db.get("pipeline_id", "unknown")
        next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'
        
        # Process form data
        form = await request.form()
        value = form.get("field_name", "")
        
        # Validate
        if not value:
            return P("Error: Field is required", style=pip.get_style("error"))
        
        # Store in state
        state = pip.read_state(pipeline_id)
        state[step.done] = value
        pip.write_state(pipeline_id, state)
        
        # Update progress and message
        await pip.update_step_state(pipeline_id, step_id, value, steps)
        await self.message_queue.add(pip, f"{step.show} complete: {value}", verbatim=True)
        
        # Return response with chain reaction
        return Div(
            Card(...),
            Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
            id=step_id
        )
    ```
    ## Adding or Inserting Steps
    To add a new step or insert one between existing steps:
    1. **Add to the steps list** in the correct position
    2. **Update step indices** in the steps_indices dictionary in __init__
    3. **Create both handler methods** following the patterns above
    4. **Verify chain reactions** in surrounding steps
    5. **Add suggestion text** in the get_suggestion method
    For placeholder steps, see the [placeholder-step-pattern](mdc:.cursor/rules/placeholder-step-pattern.mdc) rule.
    ## State Management
    - Use Pipulate helpers for state:
      - `pip.read_state(pipeline_id)`
      - `pip.get_step_data(pipeline_id, step_id, {})`
      - `pip.update_step_state(pipeline_id, step_id, val, steps)`
    - Handle finalization properly
    - Clear state appropriately on revert
    ## Message Queue Usage
    - Use ordered message delivery:
    ```python
    await self.message_queue.add(
        pip,
        message,
        verbatim=True,
        spaces_before=0,
        spaces_after=1
    )
    ```
    ## Error Handling
    - Validate all inputs
    - Use consistent error presentation
    - Provide clear user feedback
    - Handle edge cases gracefully
    - Example:
    ```python
    try:
        # Operation
    except Exception as e:
        return P(f"Error: {str(e)}", style=pip.get_style("error"))
    ```
    ## Advanced Features
    - Use transform functions for step data flow
    - Implement custom state preservation
    - Use advanced revert controls when needed
    - Track progress for long operations
    - Handle file operations safely
    ## Documentation
    - Provide clear docstrings
    - Document step dependencies
    - Explain state management
    - Detail UI/UX considerations
    - Document error handling
    ## Testing Considerations
    - Test step progression
    - Verify state management
    - Check revert functionality
    - Validate error handling
    - Test chain reactions
    ## Special Cases and Edge Case Handling
    1. **Terminal steps** may break the chain reaction pattern
    2. **Polling operations** require special HTMX handling
    3. **File downloads** use no-chain-reaction with manual continuation
    4. **Error recoveries** should guide users on how to proceed
    Remember: Workflows are intentionally WET (Write Everything Twice) to allow maximum customization while maintaining consistent patterns.
    Reference Examples:
    - [10_connect_with_botify.py](mdc:pipulate/plugins/10_connect_with_botify.py): Simple authentication workflow
    - [20_hello_workflow.py](mdc:pipulate/plugins/20_hello_workflow.py): Basic workflow template
    - [50_botify_export.py](mdc:pipulate/plugins/50_botify_export.py): Complex multi-step workflow
    - [60_widget_examples.py](mdc:pipulate/plugins/60_widget_examples.py): Visualizing data in workflow
These rules will make it easier to consistently add and modify steps in Pipulate workflows, ensuring proper chain reactions, state management, and UI patterns are preserved.
The key insight from our implementation was recognizing the importance of maintaining the HTMX chain reaction pattern and revert functionality, while creating a minimal step that can be expanded later with specific widget functionality.
---
Let me create a Cursor rule that documents the pattern for placeholder steps in Pipulate workflows:
```
# placeholder-step-pattern
## Overview
Placeholder steps are skeletal workflow steps that serve as preparation points for inserting fully-functional steps later. They maintain the standard workflow progression pattern while collecting minimal or no user data.
## When to Use Placeholder Steps
- When planning a workflow's structure before implementing detailed functionality
- When creating a step that will be replaced with more complex widgets later
- When needing a "confirmation" or "review" step between functional steps
- When creating a template for different widget types
## Implementation Pattern
To add a placeholder step to an existing workflow:
### 1. Add the Step Definition
```python
Step(
    id='step_XX',            # Use proper sequential numbering
    done='placeholder',      # Simple state field name
    show='Placeholder Step', # Descriptive UI text
    refill=True,             # Usually True for consistency
),
```
### 2. Create the GET Handler Method
```python
async def step_XX(self, request):
    """Handles GET request for placeholder step."""
    pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
    step_id = "step_XX"
    step_index = self.steps_indices[step_id]
    step = steps[step_index]
    next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'
    pipeline_id = db.get("pipeline_id", "unknown")
    state = pip.read_state(pipeline_id)
    
    # Simple form with just a proceed button
        return Div(
            Card(
            H4(f"{step.show}"),
            P("Click Proceed to continue to the next step."),
                Form(
                    Button("Proceed", type="submit", cls="primary"),
                Button("Revert", type="button", cls="secondary",
                       hx_post=f"/{app_name}/handle_revert",
                       hx_vals=f'{{"step_id": "{step_id}"}}'),
                    hx_post=f"/{app_name}/{step_id}_submit", 
            ),
        ),
        # CRITICAL: Chain reaction to next step - DO NOT MODIFY OR REMOVE
        Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
            id=step_id
        )
```
### 3. Create the POST Handler Method
```python
async def step_XX_submit(self, request):
    """Process the submission for placeholder step."""
    pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
    step_id = "step_XX"
    step_index = self.steps_indices[step_id]
    step = steps[step_index]
    pipeline_id = db.get("pipeline_id", "unknown")
    next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'
    
    # Set a fixed completion value
    placeholder_value = "completed"
    
    # Update state and notify user
    await pip.update_step_state(pipeline_id, step_id, placeholder_value, steps)
    await self.message_queue.add(pip, f"{step.show} complete.", verbatim=True)
    
    # Return with revert control and chain reaction to next step
    return Div(
        pip.revert_control(step_id=step_id, app_name=app_name, message=f"{step.show}: Complete", steps=steps),
        Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
        id=step_id
    )
```
### 4. Add Suggestion for Step (Optional)
In the `get_suggestion` method, add a simple text for the placeholder:
```python
'step_XX': """Placeholder step - no user content needed.
This step serves as a placeholder for future functionality."""
```
## Critical Elements to Preserve
1. **Chain Reaction Pattern**: 
   ```python
   # CRITICAL - DO NOT MODIFY OR REMOVE
   Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load")
   ```
   - The `id=next_step_id` identifies the container for the next step
   - The `hx_get` attribute loads the next step's content
   - The `hx_trigger="load"` attribute is REQUIRED for automatic progression
   - NEVER remove `hx_trigger="load"` even if you think event bubbling would work
   - This explicit triggering pattern is the standard throughout the codebase
2. **Revert Button**: Always include for consistent user experience
3. **Step Numbering**: Maintain proper sequential numbering
4. **State Management**: Always store state even if minimal
5. **Message Queue Updates**: Always notify of step completion
## Common Implementation Pitfalls
- **SERIOUS ERROR**: Removing `hx_trigger="load"` from the chain reaction div will break progression
- **SERIOUS ERROR**: Using an empty div without the required attributes
- **SERIOUS ERROR**: Using event bubbling or implicit triggering instead of explicit triggers
- Using incorrect next_step_id calculation (especially for the last step)
- Forgetting to update steps_indices after adding new steps
- Not preserving the chain reaction pattern in both GET and POST handlers
## Placement Considerations
- **First Step**: If replacing the first step, ensure proper initialization
- **Middle Step**: Ensure proper next_step_id and previous step chain reaction
- **Last Step**: Properly handle transition to 'finalize' instead of next_step_id
## Example
See [60_widget_examples.py](mdc:pipulate/plugins/60_widget_examples.py) step_07 for a complete placeholder implementation.
## Upgrading Later
When ready to replace the placeholder with functional content:
1. Keep the same step_id and step definition
2. Add necessary form elements to collect data
3. Enhance the submit handler to process the collected data
4. Preserve the chain reaction pattern and revert functionality
## Workflow Step Progression at a Glance
```
Empty Workflow                              Workflow With Multiple Steps
┌───────────────┐                          ┌───────────────┐
│ Landing Page  │                          │ Landing Page  │
└───────┬───────┘                          └───────┬───────┘
        │                                          │
        ▼                                          ▼
┌───────────────┐                          ┌───────────────┐
│    Form UI    │                          │    Form UI    │
│ (pipeline_id) │                          │ (pipeline_id) │
└───────┬───────┘                          └───────┬───────┘
        │                                          │
        ▼                                          ▼
┌───────────────┐                          ┌───────────────┐
│ Init Response │                          │ Init Response │
│  with step_01 │                          │  with step_01 │
│ div(hx_trigger│                          │ div(hx_trigger│
│    ="load")   │                          │    ="load")   │
└───────┬───────┘                          └───────┬───────┘
        │                                          │
        │ Chain Reaction                           │ Chain Reaction
        ▼                                          ▼
┌───────────────┐                          ┌───────────────┐
│   step_01     │                          │   step_01     │
│   GET UI      │                          │   GET UI      │
└───────┬───────┘                          └───────┬───────┘
        │                                          │
        │ User Clicks "Proceed"                    │ User Clicks "Proceed"
        ▼                                          ▼
┌───────────────┐                          ┌───────────────┐
│   step_01     │                          │   step_01     │
│  Submit UI    │                          │  Submit UI    │
│  revert_ctrl  │                          │  revert_ctrl  │
│ next_step div │                          │ next_step div │
│(hx_trigger=   │                          │(hx_trigger=   │
│    "load")    │                          │    "load")    │
└───────┬───────┘                          └───────┬───────┘
        │                                          │
        │ Chain Reaction                           │ Chain Reaction
        ▼                                          ▼
┌───────────────┐                          ┌───────────────┐
│   finalize    │                          │   step_02     │
│      GET      │                          │     GET       │
└───────────────┘                          └───────┬───────┘
                                                   │
                                                   │ More steps...
                                                   ▼
                                           ┌───────────────┐
                                           │   finalize    │
                                           │      GET      │
                                           └───────────────┘
```
## Key Components of a Placeholder Step
1. **Step Definition**
```python
Step(
    id='step_XX',            # Use proper sequential numbering
    done='placeholder',      # Simple state field name
    show='Placeholder Step', # Descriptive UI text
    refill=False,            # Use False for strict forward-only flow, True for iterative workflows
),
```
2. **GET Handler**
```python
async def step_XX(self, request):
    """Handles GET request for placeholder Step XX."""
    pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
    step_id = "step_XX"
    step_index = self.steps_indices[step_id]
    step = steps[step_index]
    next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'
    pipeline_id = db.get("pipeline_id", "unknown")
    state = pip.read_state(pipeline_id)
    step_data = pip.get_step_data(pipeline_id, step_id, {})
    placeholder_value = step_data.get(step.done, "")
    
    # Check workflow finalization
    finalize_data = pip.get_step_data(pipeline_id, "finalize", {})
    if "finalized" in finalize_data and placeholder_value:
        return Div(
            Card(
                H3(f"🔒 {step.show}"),
                P("Placeholder step completed")
            ),
            Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
            id=step_id
        )
        
    # Check completion status
    if placeholder_value and state.get("_revert_target") != step_id:
        return Div(
            pip.revert_control(step_id=step_id, app_name=app_name, message=f"{step.show}: Complete", steps=steps),
            Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
            id=step_id
        )
    else:
        # Show minimal UI with just a Proceed button
        await self.message_queue.add(pip, self.step_messages[step_id]["input"], verbatim=True)
        
        return Div(
            Card(
                H3(f"{step.show}"),
                P("This is a placeholder step. Click Proceed to continue to the next step."),
                Form(
                    Button("Proceed", type="submit", cls="primary"),
                    hx_post=f"/{app_name}/{step_id}_submit", 
                    hx_target=f"#{step_id}"
                )
            ),
            Div(id=next_step_id),  # Note: No hx_trigger="load" here to prevent auto-progression
            id=step_id
        )
```
3. **POST Handler**
```python
async def step_XX_submit(self, request):
    """Process the submission for placeholder Step XX."""
    pip, db, steps, app_name = self.pipulate, self.db, self.steps, self.app_name
    step_id = "step_XX"
    step_index = self.steps_indices[step_id]
    step = steps[step_index]
    pipeline_id = db.get("pipeline_id", "unknown")
    next_step_id = steps[step_index + 1].id if step_index < len(steps) - 1 else 'finalize'
    # Set a fixed completion value
    placeholder_value = "completed"
    
    # Update state and notify user
    await pip.update_step_state(pipeline_id, step_id, placeholder_value, steps)
    await self.message_queue.add(pip, f"{step.show} complete.", verbatim=True)
    
    # Return with revert control and chain reaction to next step
        return Div(
        pip.revert_control(step_id=step_id, app_name=app_name, message=f"{step.show}: Complete", steps=steps),
        Div(id=next_step_id, hx_get=f"/{app_name}/{next_step_id}", hx_trigger="load"),
        id=step_id
    )
```
### Why This Pattern Is Essential
1. **Explicit Triggering**: The `hx_trigger="load"` attribute explicitly tells HTMX to load the next step immediately after this content is rendered
2. **Direct Initialization**: This approach eliminates race conditions and timing issues that may occur with event bubbling
3. **Reliable Implementation**: This pattern has been tested across the entire codebase and ensures consistent progression
4. **Documented Standard**: All workflow examples follow this pattern, and it should be considered immutable
### Dangerous Modifications to Avoid
- **DO NOT** remove `hx_trigger="load"` even if it seems redundant
- **DO NOT** attempt to replace explicit chain reaction with implicit event bubbling
- **DO NOT** implement alternative flow mechanisms without extensive testing
Such changes will appear to work in limited testing but will inevitably break more complex workflows.
# File token count: 7,471 tokens
# <<< END FILE: /home/mike/repos/pipulate/training/workflow_implementation_guide.md >>>
# <<< START FILE: /home/mike/repos/pipulate/precursors/prompt.md >>>
I have finished the first and potentially most important of the Pipulate
workflows for actual day-to-day use by my coworkers. It is Parameter Buster. It
is the type of thing that will mostly be useful for Botify customers as it
leverages all 3 of the major data sources Botify takes advantage of:
- Web logs, which are not easy to get these days
- Crawl data, already pre-analyzed to those not in Google Search
- Search Console, all the URLs that are active in search
It uses these three data sources to create a optimization that will remove
querystring parameters from the URLs it finds during a Google Crawl that would
result in crawl budget waste. The end result is a copy/pastable PageWorkers
optimization, perhaps one of the best tricks in the book.
Today is about banking wins and banking more wins. It's about polish,
documentation and enabling my coworkers to actually use this thing. It's a lot
like letting Pipulate out in the wild generally, but really only of much use to
Botify employees and customers. This is a reasonable first step. More general
purpose SEO stuff comes later.
Avoid rabbit hole projects today. A single one could ruin you for another week.
You have this big solid open block of Sunday, and then back to work. By the time
you go back to work you will have a private YouTube video for this thing planted
as a copy/pastable link-example payload to ricochet around on Slack. The idea is
to quietly and self-evidently announce a total game-changer that those who can
recognize such things will recognize. This is much about that story and that
script. Speak quietly and deliver a big demo.
I'm doing a few passes to improve the overall system based on the considerable
learnings implementing `100_parameter_buster.py`. My first stop is
`50_botify_export.py` to capture all the nuance and subtlety surrounding CSV
downloads, of which there are many. It's a wild maze to navigate — from BQLv1
which is easy to get examples of but which you shouldn't be using vs. BQLv2
which you should be using but is hard to get examples of. Then there's the
`/query` endpoint vs. the `/jobs` endpoint, and really also the `/export`
endpoint which is all over the place in terms of examples but which really has
been deprecated by the `/jobs` endpoint... even when it's a BQLv1 query! And
then the polling... Oh, don't get me started. 
There's vast divide of experience with the Botify API that must be mastered
before everything stops being some sort of show-stopping obstacle. You really
have to be an engineer. However, I am not. And so this kind of post-successful
project documentation where I bank my winnings in documentation that helps the
next round of AI Assistants pick apart why things went well the last time is so
important. It's part of the accelerating success effect. Success leads to
success leads to success, and perhaps few places as well as in training AIs with
really good and forever-improving documentation.
I feel the underlying AI Code Assistants and the way they are integrated with
the Cursor AI editor shifting and evolving underneath of me as I go. I believe
it's going to be too resource intensive and wasteful to train all the frontier
AI models that are being used for such things, Claude, Gemini, ChatGPT, etc. to
handle this process radically differently between Cursor, VSCode, Windsurf,
Cline and the like. I believe we are experiencing User Interface / User
Experience / Application Programming Interface (UI/UX/API) convergence here. The
way "Agent" mode is different from "Manual" mode is different from "Ask" mode,
while the labels of these modes may vary from AI assisted editor to editor, the
spirit stays the same.
It used to be that there was one simple way you got AI-assisted coding. More or
less, it was the same way we used ChatGPT through the Web UI at first, which is
we send a prompt and a bunch of code together in-context, and it responded back
with new code that we somehow had to figure out how to work into our existing
codebase. Pedantic hair-splitting definition people are calling this former case
AI assisted coding, while the later case that is springing up all over the place
*Agentic Coding.* People thing Agentic Coding is new, but as fast as the ChatGPT
API was out, so was AutoGPT, CrewAI, Microsoft's AutoGen and others. Agentic
mode was there from the beginning, but relegated to us techies. Extremely
recently the flurry of GooseAI, Manus, Cline and Claude Code showed us that
Agentic operation was for the masses. And so now it's popping up as "Agent" mode
everywhere, including Cursor. And it all comes down to calling tools with
iterative back-and-forth self-prompting.
Implementations may vary, but the end result is the same. The AI goes off
half-cocked and loosey goosey fulfilling your request until it feels its done to
your satisfaction and whatever other criteria. It's not terribly different than
the original coding assistants except that all their output is fed back into
them as the new input automatically, including the output of the use of external
tools that can search your codebase, use git, check the Web and whatever else.
The precise details of how they do this and made such a big leap forward so
quickly is part of where this new fangled protocol MCP (model context protocol)
that is becoming so popular. If all the frontier models need to know how to do
this stuff we can't fragment it into a thousand different ways because its too
expensive and brittle to get all the models abiding by the schisming rules that
started popping up with different tool-call protocols, differing annoyingly
slightly between OpenAI, Google and Anthropic. Anthropic leading the way with
new protocol proposals such as they seem to do a lot lately proposed MCP and
everyone jumped on the bandwagon (including Google!) and now all the AI models
know how to do this agentic dance.
And so we have Agent, Manual and Ask "modes" to choose from. And we have AIs
going off half-cocked doing stuff to the point of downwards spiraling collapse
or the narrow-path to success. Try stuff, break things, back-up, undo, try again
refactoring while factoring in what we learned. Basically AIs are working a lot
like humans but exploring all these potential paths at 100x the rate a human
could. And so yeah, agentic behavior is big and important like all the hype, but
then so is controlling that half-cocked loosey goosey behavior, steering and
directing it with the kind of talent that defines where the jobs are going in
the new age of AI — riding the bucking bronco — or the sandworm if you prefer
and are a Dune nerd like me.
And so with such a potentially disastrous (to your codebase) process, obviously
they need some sort of safety-net letting them revert and branch in the
background, and obviously they're going to choose `git` just like humans and the
rest of the world. And so equally obviously Cursor AI, and I presume all the
others like Microsoft, Cline and Windsurf who must be implementing such things,
are using their own bizarro parallel git server in the background for their own
code assistants through some MCP tool-calling standard. Git through MCP must be
just about the most delicious secret sauce in the AI code editor arms race right
now. 
Cursor AI's implementation is good. I feel free to experiment wildly. I have
`git reset --hard HEAD` ready on my end. I know Claude has something similar on
its end. When an experiment spirals out of control it's almost like an inside
joke between the human and the AI who is going to revert first and inform the
other of the restore-point details. Claude doesn't have or know my git hashes
(unless I instruct it to use them through the terminal, haha), and I don't know
it's. But what used to be downward spirals of AI code-assisted ruin are now just
easy peasy experimental branches, and thus the sought-after acceleration effect
is possible. Collapsing house of cards become reassemblable construction
projects with instant undo/redo — from two sides! The git-using AI and the human
who is learning to use git better, because AI.
It doesn't matter whether these things are sentient or whether they have "true"
creativity or not. Their value as a pedantic housekeeper of deep arcane detail
make them infinitely useful from a pragmatic standpoint. How creative does a
superpowered librarian need to be? How creative does a superpowered automechanic
need to be? If something is there to immediately find the unfindable and fix the
unfixable that just frees up all your creative potential. And when you learn to
tap these superpowered assistants like driving a car, you can talk and drive at
the same time. See? When steering AI becomes second nature like driving, your
own deliberate cognitive capacity — the kind that needs to be front-and-center
which you can't throw on autopilot — gets freed up for the important stuff like
adapting to changing conditions.
And that's very much where we are now on the Pipulate project. I am learning to
use the AI coding assistants naturally. It's not a struggle every time screaming
at them FastHTML is not FastAPI. With a critical mass of code examples they have
to look at every time when navigating responses they are effectively cornered
into understanding the things they need to understand to be useful. Your local
context is overwhelmingly overriding their over-training on all the full web
stack enterprise redux kubernetes react stuff they've been brainwashed on. But
sometimes you need to use a wedge like: It's like the Electron Platform. Yeah
that's right. Web UI's can be used for localhost apps (VSCode, Slack, Zoom,
Discord, etc). And they don't have to be written scale like Netflix. Surprise!
So, I'm sorting out the rules. This is part of my cleaning and polish. When you
drop a `.cursorrules` in your local git repo, it's tied to the repo moving
around with it and part of your vendor-independent portability powers. However,
the new workspace-scoped `.cursor/rules/something.mdc` are not. And so part of
this morning's cleanup as the day gets underway is me taking what I've broken up
over multiple non-repo-bound `.mdc` files and wrapping them into one. I'm going
to use Gemini 2.5 to do this, even though it's been letting me down a lot lately
by not being able to do long replies without logging me out. However, it's also
given the best responses so the strategy is just to keep it short. Let's get the
context together. First, the prompt.
I have a system. The documentation of this system is spread out over a lot of
places and files which I have gathered together here. I have also included
parts of the codebase this documentation refers to so you can check the accuracy
of the documentation against the single source of truth: the code itself, the
behavior of which when running is what's being documented.
The system is full of counterintuitive anti-patterns as a remedy for much of
what ails bloated Conway's Law-infested modern web development. A single
webmaster sitting at a single system can interact with a software product in the
web browser much as one would with an Electron platform app, but instead of an
opinionated bundle there is a whole normalized deterministic Linux subsystem
running out of a git repo folder provided by nix flakes, solving the "not on my
machine" problem, blurring the lines between the development platform and the
app runtime environment. This provides full transparency to the user by moving
almost all responsibilities and concerns that would be handled by a fat
JavaScript client library onto the server through FastHTML and HTMX, down to and
including the cookies. Think server-side cookies whose state is shown through
the webserver console output which the user is free to watch while using the
app. There are no mysteries concerning client-side state because all that state
is shifted to the server and exposed through its server console. That's on top
of the client-side DevTools console which still also can be used to monitor the
reduced and simplified minimal JavaScript that remains. So in short, there is
nothing that cannot be easily known. And with this total knowledge comes
enhanced control and with this enhanced control comes accelerated feedback loop
of app improvement, especially AI-assisted as it can be leveraging that same
said transparency for the Coding Assistant.
Is the vision becoming clear? None of this is theoretical. All of this exists
right now today as you can see from the code and documentation I am providing
you. In fact I am leaving many things out so as to not overwhelm you with the
quantity and details of the antipattern corralling examples that overcome your
enterprise-concerns over-training. I've given you just enough examples of the
DRY CRUD apps and WET Workflow examples to allay any concern that they might not
exist or be as powerful as this system implies. They exist and are quite
powerful. Basically, anything able to be expressed in Python and organized in
the Jupyter Notebook style can be ported into this system and have a superior
user interface and experience for the non-technical user who doesn't want to and
shouldn't need to look at the Python code powering it all. So in other words,
Pipulate brings the already transformative and liberating power of Notebooks to
the rest of the world by taking that extra step and allowing the refinement of
notebooks into code-free (as far as the user is concerned) Web Apps!
So there are 2 audience for every bit of documentation made. Can that. There are
FOUR audiences for the documentation:
1. The human merely using the apps who need not even know nix but for the 2
   commands to get an app installed and running
2. The human developing the apps who need be near a pulsing-brain alien to port
   Notebooks to FastHTML/HTMX.
3. The frontier-model AI Coding Assistant (like you) there to reduce the human's
   dependency on actually being a pulsing-brain alien
4. The Ollama-powered LLM baked into the locally running web app who understands
   it from real-time training and is there to help the human merely using the app
Together these four audiences have a beautiful dance, rapidly customizing
different instances of this system into endless customized variations for the
SEO, Finance, Science industries and others — basally any industry or situation
that could benefit from having a clearly documented semi-automated linear
workflow with a local AI riding shotgun to help you make sure those parts that
can't be fully automated are at least well understood by the human while it
shepherded them through whatever part of the process that still needs a human in
the loop.
The way this becomes a feedback loop independent of any particular AI platform
(including Cursor, Windsurf, Cline, VSCode, etc) or even any particular API,
application or even Web UI, is to bundle it all up into an XML package that can
be 1-shot submitted to you and your kind. It's so easy to do this way I am not
even limited to doing it once against you nor to just you. I can do variations
of this very prompt and rapidly re-test it against you and other models to
compare your output. It is a wonderful way to probe for the best answers using
different approaches, and even to benchmark the frontier models like you. So it
is with that sort of eye I will be examining your response to this prompt.
With that in mind, I have given you both the code that drives the system (for
the most part) and some of the already existing documentation. I need to create
documentation for each of the audiences discussed:
1. A human just using web apps
2. A human developing those web apps
2. A Frontier Model AI (like you) helping the developer make those web apps (port Notebooks)
4. A local model helping the user use those web apps (step through Pythonless Notebooks)
For audience 1, the documentation will be:
- Introduction on Pipulate.com
- Install instructions
- Philosophy document (why the keys, chain reacting flow, etc)
For audience 2, the documentation will be:
- Explanation of Nix/.venv environment
- High level Notebook-to-FastHTML/HTMX concepts
- Workflow Implementation Guide
For audience 3, the documentation will be:
- The mega super-complete `.cusorrules` file (replacing need for `.mdc` files)
- The mega super-complete Workflow Implementation Guide
- Recipes for every kind of Workflow Widget
For audience 4, the documentation will be:
- System prompt instilling persona and giving overview of its role
- Real-time training markdown documents per crud/workflow web app
- Tool-use instructions (probably MCP) for agentic "steps" within workflows
I think that about covers it. That's to give you the broad overview. But now to
the actual prompt for you for right now, what I expect you to do in response to
this. My priority is to reduce the reliance on `.mdc` files that are not bound
to the repo and to instead roll all their good and knowledge into a combination
of `.cursorrules`, perhaps the `README.md` (serving a lot of audiences and
purposes right now), and the `plugins/workflow_implementation_guide.md`, which
seems to be where a lot of the deep precise knowledge is ending up that's too
big to feed to the LLM on every request the way `.cursorrules` does.
And so the request here is really for you to within a reasonable response size
because anything larger than what appears to be about 1000 lines automatically
logs me off of Gemini and loses all the good work of your reply (no way to
retrieve your up-to-that output — lost forever!). So give me what you think is
the right first-pass output to this request with further instructions as to how
I should refine THIS PROMPT for the next iterative round because it is very easy
for me to re-prompt you with one of these super-prompts in a wholly new session
freeing up all your tokens and starting fresh, but with your directional advice
incorporated into the prompt-at-the-end (which this is).
Is that clear? I understand it is a bit meta, but you can appreciate what I'm
going for with the accelerating effect implied by this document and the effect
that good documentation has towards this cause by enabling entities such as you
to do even better the next time.
Please and thank you!
# File token count: 4,045 tokens
# <<< END FILE: /home/mike/repos/pipulate/precursors/prompt.md >>>
==================== END CONTEXT ====================
<response_request><introduction>
Now that you've reviewed the provided materials, please respond thoughtfully to the prompt.
Your response can include analysis, insights, implementation suggestions, or other relevant
observations based on what was requested.
</introduction>
<response_areas><area><title>Material Analysis</title>
<questions>
<question>What are the key concepts, patterns, or architecture details in the provided materials?</question>
<question>What interesting aspects of the system stand out to you?</question>
<question>How would you characterize the approach taken in this codebase?</question>
</questions></area>
<area><title>Strategic Considerations</title>
<questions>
<question>How might the content of the materials inform future development?</question>
<question>What patterns or conventions should be considered in any response?</question>
<question>What alignment exists between the provided materials and the prompt?</question>
</questions></area>
<area><title>Concrete Response</title>
<questions>
<question>What specific actionable insights can be provided based on the prompt?</question>
<question>If implementation is requested, how might it be approached?</question>
<question>What recommendations or observations are most relevant to the prompt?</question>
</questions></area></response_areas>
<focus_areas><area>Responding directly to the core request in the prompt</area>
<area>Drawing connections between the materials and the prompt</area>
<area>Providing value in the form requested (analysis, implementation, etc.)</area></focus_areas></response_request></content>
<post_prompt><response_request><introduction>
Now that you've reviewed the provided materials, please respond thoughtfully to the prompt.
Your response can include analysis, insights, implementation suggestions, or other relevant
observations based on what was requested.
</introduction>
<response_areas><area><title>Material Analysis</title>
<questions>
<question>What are the key concepts, patterns, or architecture details in the provided materials?</question>
<question>What interesting aspects of the system stand out to you?</question>
<question>How would you characterize the approach taken in this codebase?</question>
</questions></area>
<area><title>Strategic Considerations</title>
<questions>
<question>How might the content of the materials inform future development?</question>
<question>What patterns or conventions should be considered in any response?</question>
<question>What alignment exists between the provided materials and the prompt?</question>
</questions></area>
<area><title>Concrete Response</title>
<questions>
<question>What specific actionable insights can be provided based on the prompt?</question>
<question>If implementation is requested, how might it be approached?</question>
<question>What recommendations or observations are most relevant to the prompt?</question>
</questions></area></response_areas>
<focus_areas><area>Responding directly to the core request in the prompt</area>
<area>Drawing connections between the materials and the prompt</area>
<area>Providing value in the form requested (analysis, implementation, etc.)</area></focus_areas></response_request></post_prompt>
<token_summary><total_context_size>89,170 tokens</total_context_size>
<files_tokens>88,688 tokens</files_tokens>
<prompt_tokens>482 tokens</prompt_tokens></token_summary>
</context>